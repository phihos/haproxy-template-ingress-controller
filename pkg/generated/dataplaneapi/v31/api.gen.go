// Package v31 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v31

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Basic_authScopes = "basic_auth.Scopes"
)

// Defines values for AwsRegionIpv4Address.
const (
	AwsRegionIpv4AddressPrivate AwsRegionIpv4Address = "private"
	AwsRegionIpv4AddressPublic  AwsRegionIpv4Address = "public"
)

// Defines values for AwsRegionServerSlotsGrowthType.
const (
	AwsRegionServerSlotsGrowthTypeExponential AwsRegionServerSlotsGrowthType = "exponential"
	AwsRegionServerSlotsGrowthTypeLinear      AwsRegionServerSlotsGrowthType = "linear"
)

// Defines values for BackendAbortonclose.
const (
	BackendAbortoncloseDisabled BackendAbortonclose = "disabled"
	BackendAbortoncloseEnabled  BackendAbortonclose = "enabled"
)

// Defines values for BackendAcceptInvalidHttpResponse.
const (
	BackendAcceptInvalidHttpResponseDisabled BackendAcceptInvalidHttpResponse = "disabled"
	BackendAcceptInvalidHttpResponseEnabled  BackendAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendAcceptUnsafeViolationsInHttpResponse.
const (
	BackendAcceptUnsafeViolationsInHttpResponseDisabled BackendAcceptUnsafeViolationsInHttpResponse = "disabled"
	BackendAcceptUnsafeViolationsInHttpResponseEnabled  BackendAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for BackendAdvCheck.
const (
	BackendAdvCheckHttpchk     BackendAdvCheck = "httpchk"
	BackendAdvCheckLdapCheck   BackendAdvCheck = "ldap-check"
	BackendAdvCheckMysqlCheck  BackendAdvCheck = "mysql-check"
	BackendAdvCheckPgsqlCheck  BackendAdvCheck = "pgsql-check"
	BackendAdvCheckRedisCheck  BackendAdvCheck = "redis-check"
	BackendAdvCheckSmtpchk     BackendAdvCheck = "smtpchk"
	BackendAdvCheckSslHelloChk BackendAdvCheck = "ssl-hello-chk"
	BackendAdvCheckTcpCheck    BackendAdvCheck = "tcp-check"
)

// Defines values for BackendAllbackups.
const (
	BackendAllbackupsDisabled BackendAllbackups = "disabled"
	BackendAllbackupsEnabled  BackendAllbackups = "enabled"
)

// Defines values for BackendCheckcache.
const (
	BackendCheckcacheDisabled BackendCheckcache = "disabled"
	BackendCheckcacheEnabled  BackendCheckcache = "enabled"
)

// Defines values for BackendExternalCheck.
const (
	BackendExternalCheckDisabled BackendExternalCheck = "disabled"
	BackendExternalCheckEnabled  BackendExternalCheck = "enabled"
)

// Defines values for BackendForcePersistCond.
const (
	BackendForcePersistCondIf     BackendForcePersistCond = "if"
	BackendForcePersistCondUnless BackendForcePersistCond = "unless"
)

// Defines values for BackendForcePersistListCond.
const (
	BackendForcePersistListCondIf     BackendForcePersistListCond = "if"
	BackendForcePersistListCondUnless BackendForcePersistListCond = "unless"
)

// Defines values for BackendH1CaseAdjustBogusServer.
const (
	BackendH1CaseAdjustBogusServerDisabled BackendH1CaseAdjustBogusServer = "disabled"
	BackendH1CaseAdjustBogusServerEnabled  BackendH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendHttpBufferRequest.
const (
	BackendHttpBufferRequestDisabled BackendHttpBufferRequest = "disabled"
	BackendHttpBufferRequestEnabled  BackendHttpBufferRequest = "enabled"
)

// Defines values for BackendHttpNoDelay.
const (
	BackendHttpNoDelayDisabled BackendHttpNoDelay = "disabled"
	BackendHttpNoDelayEnabled  BackendHttpNoDelay = "enabled"
)

// Defines values for BackendHttpUseHtx.
const (
	BackendHttpUseHtxDisabled BackendHttpUseHtx = "disabled"
	BackendHttpUseHtxEnabled  BackendHttpUseHtx = "enabled"
)

// Defines values for BackendHttpConnectionMode.
const (
	BackendHttpConnectionModeHttpKeepAlive   BackendHttpConnectionMode = "http-keep-alive"
	BackendHttpConnectionModeHttpServerClose BackendHttpConnectionMode = "http-server-close"
	BackendHttpConnectionModeHttpclose       BackendHttpConnectionMode = "httpclose"
)

// Defines values for BackendHttpPretendKeepalive.
const (
	BackendHttpPretendKeepaliveDisabled BackendHttpPretendKeepalive = "disabled"
	BackendHttpPretendKeepaliveEnabled  BackendHttpPretendKeepalive = "enabled"
)

// Defines values for BackendHttpProxy.
const (
	BackendHttpProxyDisabled BackendHttpProxy = "disabled"
	BackendHttpProxyEnabled  BackendHttpProxy = "enabled"
)

// Defines values for BackendHttpRestrictReqHdrNames.
const (
	BackendHttpRestrictReqHdrNamesDelete   BackendHttpRestrictReqHdrNames = "delete"
	BackendHttpRestrictReqHdrNamesPreserve BackendHttpRestrictReqHdrNames = "preserve"
	BackendHttpRestrictReqHdrNamesReject   BackendHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendHttpReuse.
const (
	BackendHttpReuseAggressive BackendHttpReuse = "aggressive"
	BackendHttpReuseAlways     BackendHttpReuse = "always"
	BackendHttpReuseNever      BackendHttpReuse = "never"
	BackendHttpReuseSafe       BackendHttpReuse = "safe"
)

// Defines values for BackendIgnorePersistCond.
const (
	BackendIgnorePersistCondIf     BackendIgnorePersistCond = "if"
	BackendIgnorePersistCondUnless BackendIgnorePersistCond = "unless"
)

// Defines values for BackendIgnorePersistListCond.
const (
	BackendIgnorePersistListCondIf     BackendIgnorePersistListCond = "if"
	BackendIgnorePersistListCondUnless BackendIgnorePersistListCond = "unless"
)

// Defines values for BackendIndependentStreams.
const (
	BackendIndependentStreamsDisabled BackendIndependentStreams = "disabled"
	BackendIndependentStreamsEnabled  BackendIndependentStreams = "enabled"
)

// Defines values for BackendLoadServerStateFromFile.
const (
	BackendLoadServerStateFromFileGlobal BackendLoadServerStateFromFile = "global"
	BackendLoadServerStateFromFileLocal  BackendLoadServerStateFromFile = "local"
	BackendLoadServerStateFromFileNone   BackendLoadServerStateFromFile = "none"
)

// Defines values for BackendLogHealthChecks.
const (
	BackendLogHealthChecksDisabled BackendLogHealthChecks = "disabled"
	BackendLogHealthChecksEnabled  BackendLogHealthChecks = "enabled"
)

// Defines values for BackendMode.
const (
	BackendModeHttp BackendMode = "http"
	BackendModeLog  BackendMode = "log"
	BackendModeTcp  BackendMode = "tcp"
)

// Defines values for BackendNolinger.
const (
	BackendNolingerDisabled BackendNolinger = "disabled"
	BackendNolingerEnabled  BackendNolinger = "enabled"
)

// Defines values for BackendPersist.
const (
	BackendPersistDisabled BackendPersist = "disabled"
	BackendPersistEnabled  BackendPersist = "enabled"
)

// Defines values for BackendPreferLastServer.
const (
	BackendPreferLastServerDisabled BackendPreferLastServer = "disabled"
	BackendPreferLastServerEnabled  BackendPreferLastServer = "enabled"
)

// Defines values for BackendSpliceAuto.
const (
	BackendSpliceAutoDisabled BackendSpliceAuto = "disabled"
	BackendSpliceAutoEnabled  BackendSpliceAuto = "enabled"
)

// Defines values for BackendSpliceRequest.
const (
	BackendSpliceRequestDisabled BackendSpliceRequest = "disabled"
	BackendSpliceRequestEnabled  BackendSpliceRequest = "enabled"
)

// Defines values for BackendSpliceResponse.
const (
	BackendSpliceResponseDisabled BackendSpliceResponse = "disabled"
	BackendSpliceResponseEnabled  BackendSpliceResponse = "enabled"
)

// Defines values for BackendSpopCheck.
const (
	BackendSpopCheckDisabled BackendSpopCheck = "disabled"
	BackendSpopCheckEnabled  BackendSpopCheck = "enabled"
)

// Defines values for BackendSrvtcpka.
const (
	BackendSrvtcpkaDisabled BackendSrvtcpka = "disabled"
	BackendSrvtcpkaEnabled  BackendSrvtcpka = "enabled"
)

// Defines values for BackendTcpSmartConnect.
const (
	BackendTcpSmartConnectDisabled BackendTcpSmartConnect = "disabled"
	BackendTcpSmartConnectEnabled  BackendTcpSmartConnect = "enabled"
)

// Defines values for BackendTcpka.
const (
	BackendTcpkaDisabled BackendTcpka = "disabled"
	BackendTcpkaEnabled  BackendTcpka = "enabled"
)

// Defines values for BackendTransparent.
const (
	BackendTransparentDisabled BackendTransparent = "disabled"
	BackendTransparentEnabled  BackendTransparent = "enabled"
)

// Defines values for BackendBaseAbortonclose.
const (
	BackendBaseAbortoncloseDisabled BackendBaseAbortonclose = "disabled"
	BackendBaseAbortoncloseEnabled  BackendBaseAbortonclose = "enabled"
)

// Defines values for BackendBaseAcceptInvalidHttpResponse.
const (
	BackendBaseAcceptInvalidHttpResponseDisabled BackendBaseAcceptInvalidHttpResponse = "disabled"
	BackendBaseAcceptInvalidHttpResponseEnabled  BackendBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendBaseAcceptUnsafeViolationsInHttpResponse.
const (
	BackendBaseAcceptUnsafeViolationsInHttpResponseDisabled BackendBaseAcceptUnsafeViolationsInHttpResponse = "disabled"
	BackendBaseAcceptUnsafeViolationsInHttpResponseEnabled  BackendBaseAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for BackendBaseAdvCheck.
const (
	BackendBaseAdvCheckHttpchk     BackendBaseAdvCheck = "httpchk"
	BackendBaseAdvCheckLdapCheck   BackendBaseAdvCheck = "ldap-check"
	BackendBaseAdvCheckMysqlCheck  BackendBaseAdvCheck = "mysql-check"
	BackendBaseAdvCheckPgsqlCheck  BackendBaseAdvCheck = "pgsql-check"
	BackendBaseAdvCheckRedisCheck  BackendBaseAdvCheck = "redis-check"
	BackendBaseAdvCheckSmtpchk     BackendBaseAdvCheck = "smtpchk"
	BackendBaseAdvCheckSslHelloChk BackendBaseAdvCheck = "ssl-hello-chk"
	BackendBaseAdvCheckTcpCheck    BackendBaseAdvCheck = "tcp-check"
)

// Defines values for BackendBaseAllbackups.
const (
	BackendBaseAllbackupsDisabled BackendBaseAllbackups = "disabled"
	BackendBaseAllbackupsEnabled  BackendBaseAllbackups = "enabled"
)

// Defines values for BackendBaseCheckcache.
const (
	BackendBaseCheckcacheDisabled BackendBaseCheckcache = "disabled"
	BackendBaseCheckcacheEnabled  BackendBaseCheckcache = "enabled"
)

// Defines values for BackendBaseExternalCheck.
const (
	BackendBaseExternalCheckDisabled BackendBaseExternalCheck = "disabled"
	BackendBaseExternalCheckEnabled  BackendBaseExternalCheck = "enabled"
)

// Defines values for BackendBaseForcePersistCond.
const (
	BackendBaseForcePersistCondIf     BackendBaseForcePersistCond = "if"
	BackendBaseForcePersistCondUnless BackendBaseForcePersistCond = "unless"
)

// Defines values for BackendBaseForcePersistListCond.
const (
	BackendBaseForcePersistListCondIf     BackendBaseForcePersistListCond = "if"
	BackendBaseForcePersistListCondUnless BackendBaseForcePersistListCond = "unless"
)

// Defines values for BackendBaseH1CaseAdjustBogusServer.
const (
	BackendBaseH1CaseAdjustBogusServerDisabled BackendBaseH1CaseAdjustBogusServer = "disabled"
	BackendBaseH1CaseAdjustBogusServerEnabled  BackendBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendBaseHttpBufferRequest.
const (
	BackendBaseHttpBufferRequestDisabled BackendBaseHttpBufferRequest = "disabled"
	BackendBaseHttpBufferRequestEnabled  BackendBaseHttpBufferRequest = "enabled"
)

// Defines values for BackendBaseHttpNoDelay.
const (
	BackendBaseHttpNoDelayDisabled BackendBaseHttpNoDelay = "disabled"
	BackendBaseHttpNoDelayEnabled  BackendBaseHttpNoDelay = "enabled"
)

// Defines values for BackendBaseHttpUseHtx.
const (
	BackendBaseHttpUseHtxDisabled BackendBaseHttpUseHtx = "disabled"
	BackendBaseHttpUseHtxEnabled  BackendBaseHttpUseHtx = "enabled"
)

// Defines values for BackendBaseHttpConnectionMode.
const (
	BackendBaseHttpConnectionModeHttpKeepAlive   BackendBaseHttpConnectionMode = "http-keep-alive"
	BackendBaseHttpConnectionModeHttpServerClose BackendBaseHttpConnectionMode = "http-server-close"
	BackendBaseHttpConnectionModeHttpclose       BackendBaseHttpConnectionMode = "httpclose"
)

// Defines values for BackendBaseHttpPretendKeepalive.
const (
	BackendBaseHttpPretendKeepaliveDisabled BackendBaseHttpPretendKeepalive = "disabled"
	BackendBaseHttpPretendKeepaliveEnabled  BackendBaseHttpPretendKeepalive = "enabled"
)

// Defines values for BackendBaseHttpProxy.
const (
	BackendBaseHttpProxyDisabled BackendBaseHttpProxy = "disabled"
	BackendBaseHttpProxyEnabled  BackendBaseHttpProxy = "enabled"
)

// Defines values for BackendBaseHttpRestrictReqHdrNames.
const (
	BackendBaseHttpRestrictReqHdrNamesDelete   BackendBaseHttpRestrictReqHdrNames = "delete"
	BackendBaseHttpRestrictReqHdrNamesPreserve BackendBaseHttpRestrictReqHdrNames = "preserve"
	BackendBaseHttpRestrictReqHdrNamesReject   BackendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendBaseHttpReuse.
const (
	BackendBaseHttpReuseAggressive BackendBaseHttpReuse = "aggressive"
	BackendBaseHttpReuseAlways     BackendBaseHttpReuse = "always"
	BackendBaseHttpReuseNever      BackendBaseHttpReuse = "never"
	BackendBaseHttpReuseSafe       BackendBaseHttpReuse = "safe"
)

// Defines values for BackendBaseIgnorePersistCond.
const (
	BackendBaseIgnorePersistCondIf     BackendBaseIgnorePersistCond = "if"
	BackendBaseIgnorePersistCondUnless BackendBaseIgnorePersistCond = "unless"
)

// Defines values for BackendBaseIgnorePersistListCond.
const (
	BackendBaseIgnorePersistListCondIf     BackendBaseIgnorePersistListCond = "if"
	BackendBaseIgnorePersistListCondUnless BackendBaseIgnorePersistListCond = "unless"
)

// Defines values for BackendBaseIndependentStreams.
const (
	BackendBaseIndependentStreamsDisabled BackendBaseIndependentStreams = "disabled"
	BackendBaseIndependentStreamsEnabled  BackendBaseIndependentStreams = "enabled"
)

// Defines values for BackendBaseLoadServerStateFromFile.
const (
	BackendBaseLoadServerStateFromFileGlobal BackendBaseLoadServerStateFromFile = "global"
	BackendBaseLoadServerStateFromFileLocal  BackendBaseLoadServerStateFromFile = "local"
	BackendBaseLoadServerStateFromFileNone   BackendBaseLoadServerStateFromFile = "none"
)

// Defines values for BackendBaseLogHealthChecks.
const (
	BackendBaseLogHealthChecksDisabled BackendBaseLogHealthChecks = "disabled"
	BackendBaseLogHealthChecksEnabled  BackendBaseLogHealthChecks = "enabled"
)

// Defines values for BackendBaseMode.
const (
	BackendBaseModeHttp BackendBaseMode = "http"
	BackendBaseModeLog  BackendBaseMode = "log"
	BackendBaseModeTcp  BackendBaseMode = "tcp"
)

// Defines values for BackendBaseNolinger.
const (
	BackendBaseNolingerDisabled BackendBaseNolinger = "disabled"
	BackendBaseNolingerEnabled  BackendBaseNolinger = "enabled"
)

// Defines values for BackendBasePersist.
const (
	BackendBasePersistDisabled BackendBasePersist = "disabled"
	BackendBasePersistEnabled  BackendBasePersist = "enabled"
)

// Defines values for BackendBasePreferLastServer.
const (
	BackendBasePreferLastServerDisabled BackendBasePreferLastServer = "disabled"
	BackendBasePreferLastServerEnabled  BackendBasePreferLastServer = "enabled"
)

// Defines values for BackendBaseSpliceAuto.
const (
	BackendBaseSpliceAutoDisabled BackendBaseSpliceAuto = "disabled"
	BackendBaseSpliceAutoEnabled  BackendBaseSpliceAuto = "enabled"
)

// Defines values for BackendBaseSpliceRequest.
const (
	BackendBaseSpliceRequestDisabled BackendBaseSpliceRequest = "disabled"
	BackendBaseSpliceRequestEnabled  BackendBaseSpliceRequest = "enabled"
)

// Defines values for BackendBaseSpliceResponse.
const (
	BackendBaseSpliceResponseDisabled BackendBaseSpliceResponse = "disabled"
	BackendBaseSpliceResponseEnabled  BackendBaseSpliceResponse = "enabled"
)

// Defines values for BackendBaseSpopCheck.
const (
	BackendBaseSpopCheckDisabled BackendBaseSpopCheck = "disabled"
	BackendBaseSpopCheckEnabled  BackendBaseSpopCheck = "enabled"
)

// Defines values for BackendBaseSrvtcpka.
const (
	BackendBaseSrvtcpkaDisabled BackendBaseSrvtcpka = "disabled"
	BackendBaseSrvtcpkaEnabled  BackendBaseSrvtcpka = "enabled"
)

// Defines values for BackendBaseTcpSmartConnect.
const (
	BackendBaseTcpSmartConnectDisabled BackendBaseTcpSmartConnect = "disabled"
	BackendBaseTcpSmartConnectEnabled  BackendBaseTcpSmartConnect = "enabled"
)

// Defines values for BackendBaseTcpka.
const (
	BackendBaseTcpkaDisabled BackendBaseTcpka = "disabled"
	BackendBaseTcpkaEnabled  BackendBaseTcpka = "enabled"
)

// Defines values for BackendBaseTransparent.
const (
	BackendBaseTransparentDisabled BackendBaseTransparent = "disabled"
	BackendBaseTransparentEnabled  BackendBaseTransparent = "enabled"
)

// Defines values for BackendSwitchingRuleCond.
const (
	BackendSwitchingRuleCondIf     BackendSwitchingRuleCond = "if"
	BackendSwitchingRuleCondUnless BackendSwitchingRuleCond = "unless"
)

// Defines values for BalanceAlgorithm.
const (
	BalanceAlgorithmFirst      BalanceAlgorithm = "first"
	BalanceAlgorithmHash       BalanceAlgorithm = "hash"
	BalanceAlgorithmHdr        BalanceAlgorithm = "hdr"
	BalanceAlgorithmLeastconn  BalanceAlgorithm = "leastconn"
	BalanceAlgorithmRandom     BalanceAlgorithm = "random"
	BalanceAlgorithmRdpCookie  BalanceAlgorithm = "rdp-cookie"
	BalanceAlgorithmRoundrobin BalanceAlgorithm = "roundrobin"
	BalanceAlgorithmSource     BalanceAlgorithm = "source"
	BalanceAlgorithmStaticRr   BalanceAlgorithm = "static-rr"
	BalanceAlgorithmUri        BalanceAlgorithm = "uri"
	BalanceAlgorithmUrlParam   BalanceAlgorithm = "url_param"
)

// Defines values for BindLevel.
const (
	BindLevelAdmin    BindLevel = "admin"
	BindLevelOperator BindLevel = "operator"
	BindLevelUser     BindLevel = "user"
)

// Defines values for BindQuicCcAlgo.
const (
	BindQuicCcAlgoBbr     BindQuicCcAlgo = "bbr"
	BindQuicCcAlgoCubic   BindQuicCcAlgo = "cubic"
	BindQuicCcAlgoNewreno BindQuicCcAlgo = "newreno"
	BindQuicCcAlgoNocc    BindQuicCcAlgo = "nocc"
)

// Defines values for BindQuicSocket.
const (
	BindQuicSocketConnection BindQuicSocket = "connection"
	BindQuicSocketListener   BindQuicSocket = "listener"
)

// Defines values for BindSeverityOutput.
const (
	BindSeverityOutputNone   BindSeverityOutput = "none"
	BindSeverityOutputNumber BindSeverityOutput = "number"
	BindSeverityOutputString BindSeverityOutput = "string"
)

// Defines values for BindSslMaxVer.
const (
	BindSslMaxVerSSLv3  BindSslMaxVer = "SSLv3"
	BindSslMaxVerTLSv10 BindSslMaxVer = "TLSv1.0"
	BindSslMaxVerTLSv11 BindSslMaxVer = "TLSv1.1"
	BindSslMaxVerTLSv12 BindSslMaxVer = "TLSv1.2"
	BindSslMaxVerTLSv13 BindSslMaxVer = "TLSv1.3"
)

// Defines values for BindSslMinVer.
const (
	BindSslMinVerSSLv3  BindSslMinVer = "SSLv3"
	BindSslMinVerTLSv10 BindSslMinVer = "TLSv1.0"
	BindSslMinVerTLSv11 BindSslMinVer = "TLSv1.1"
	BindSslMinVerTLSv12 BindSslMinVer = "TLSv1.2"
	BindSslMinVerTLSv13 BindSslMinVer = "TLSv1.3"
)

// Defines values for BindSslv3.
const (
	BindSslv3Disabled BindSslv3 = "disabled"
	BindSslv3Enabled  BindSslv3 = "enabled"
)

// Defines values for BindTlsv10.
const (
	BindTlsv10Disabled BindTlsv10 = "disabled"
	BindTlsv10Enabled  BindTlsv10 = "enabled"
)

// Defines values for BindTlsv11.
const (
	BindTlsv11Disabled BindTlsv11 = "disabled"
	BindTlsv11Enabled  BindTlsv11 = "enabled"
)

// Defines values for BindTlsv12.
const (
	BindTlsv12Disabled BindTlsv12 = "disabled"
	BindTlsv12Enabled  BindTlsv12 = "enabled"
)

// Defines values for BindTlsv13.
const (
	BindTlsv13Disabled BindTlsv13 = "disabled"
	BindTlsv13Enabled  BindTlsv13 = "enabled"
)

// Defines values for BindVerify.
const (
	BindVerifyNone     BindVerify = "none"
	BindVerifyOptional BindVerify = "optional"
	BindVerifyRequired BindVerify = "required"
)

// Defines values for BindParamsLevel.
const (
	BindParamsLevelAdmin    BindParamsLevel = "admin"
	BindParamsLevelOperator BindParamsLevel = "operator"
	BindParamsLevelUser     BindParamsLevel = "user"
)

// Defines values for BindParamsQuicCcAlgo.
const (
	BindParamsQuicCcAlgoBbr     BindParamsQuicCcAlgo = "bbr"
	BindParamsQuicCcAlgoCubic   BindParamsQuicCcAlgo = "cubic"
	BindParamsQuicCcAlgoNewreno BindParamsQuicCcAlgo = "newreno"
	BindParamsQuicCcAlgoNocc    BindParamsQuicCcAlgo = "nocc"
)

// Defines values for BindParamsQuicSocket.
const (
	BindParamsQuicSocketConnection BindParamsQuicSocket = "connection"
	BindParamsQuicSocketListener   BindParamsQuicSocket = "listener"
)

// Defines values for BindParamsSeverityOutput.
const (
	BindParamsSeverityOutputNone   BindParamsSeverityOutput = "none"
	BindParamsSeverityOutputNumber BindParamsSeverityOutput = "number"
	BindParamsSeverityOutputString BindParamsSeverityOutput = "string"
)

// Defines values for BindParamsSslMaxVer.
const (
	BindParamsSslMaxVerSSLv3  BindParamsSslMaxVer = "SSLv3"
	BindParamsSslMaxVerTLSv10 BindParamsSslMaxVer = "TLSv1.0"
	BindParamsSslMaxVerTLSv11 BindParamsSslMaxVer = "TLSv1.1"
	BindParamsSslMaxVerTLSv12 BindParamsSslMaxVer = "TLSv1.2"
	BindParamsSslMaxVerTLSv13 BindParamsSslMaxVer = "TLSv1.3"
)

// Defines values for BindParamsSslMinVer.
const (
	BindParamsSslMinVerSSLv3  BindParamsSslMinVer = "SSLv3"
	BindParamsSslMinVerTLSv10 BindParamsSslMinVer = "TLSv1.0"
	BindParamsSslMinVerTLSv11 BindParamsSslMinVer = "TLSv1.1"
	BindParamsSslMinVerTLSv12 BindParamsSslMinVer = "TLSv1.2"
	BindParamsSslMinVerTLSv13 BindParamsSslMinVer = "TLSv1.3"
)

// Defines values for BindParamsSslv3.
const (
	BindParamsSslv3Disabled BindParamsSslv3 = "disabled"
	BindParamsSslv3Enabled  BindParamsSslv3 = "enabled"
)

// Defines values for BindParamsTlsv10.
const (
	BindParamsTlsv10Disabled BindParamsTlsv10 = "disabled"
	BindParamsTlsv10Enabled  BindParamsTlsv10 = "enabled"
)

// Defines values for BindParamsTlsv11.
const (
	BindParamsTlsv11Disabled BindParamsTlsv11 = "disabled"
	BindParamsTlsv11Enabled  BindParamsTlsv11 = "enabled"
)

// Defines values for BindParamsTlsv12.
const (
	BindParamsTlsv12Disabled BindParamsTlsv12 = "disabled"
	BindParamsTlsv12Enabled  BindParamsTlsv12 = "enabled"
)

// Defines values for BindParamsTlsv13.
const (
	BindParamsTlsv13Disabled BindParamsTlsv13 = "disabled"
	BindParamsTlsv13Enabled  BindParamsTlsv13 = "enabled"
)

// Defines values for BindParamsVerify.
const (
	BindParamsVerifyNone     BindParamsVerify = "none"
	BindParamsVerifyOptional BindParamsVerify = "optional"
	BindParamsVerifyRequired BindParamsVerify = "required"
)

// Defines values for CaptureType.
const (
	CaptureTypeRequest  CaptureType = "request"
	CaptureTypeResponse CaptureType = "response"
)

// Defines values for ClusterSettingsClusterLogTargetsProtocol.
const (
	ClusterSettingsClusterLogTargetsProtocolTcp ClusterSettingsClusterLogTargetsProtocol = "tcp"
	ClusterSettingsClusterLogTargetsProtocolUdp ClusterSettingsClusterLogTargetsProtocol = "udp"
)

// Defines values for ClusterSettingsMode.
const (
	ClusterSettingsModeCluster ClusterSettingsMode = "cluster"
	ClusterSettingsModeSingle  ClusterSettingsMode = "single"
)

// Defines values for ClusterSettingsStatus.
const (
	ClusterSettingsStatusActive          ClusterSettingsStatus = "active"
	ClusterSettingsStatusUnreachable     ClusterSettingsStatus = "unreachable"
	ClusterSettingsStatusWaitingApproval ClusterSettingsStatus = "waiting_approval"
)

// Defines values for CompressionAlgoReq.
const (
	CompressionAlgoReqDeflate    CompressionAlgoReq = "deflate"
	CompressionAlgoReqGzip       CompressionAlgoReq = "gzip"
	CompressionAlgoReqIdentity   CompressionAlgoReq = "identity"
	CompressionAlgoReqRawDeflate CompressionAlgoReq = "raw-deflate"
)

// Defines values for CompressionAlgorithms.
const (
	CompressionAlgorithmsDeflate    CompressionAlgorithms = "deflate"
	CompressionAlgorithmsGzip       CompressionAlgorithms = "gzip"
	CompressionAlgorithmsIdentity   CompressionAlgorithms = "identity"
	CompressionAlgorithmsRawDeflate CompressionAlgorithms = "raw-deflate"
)

// Defines values for CompressionAlgosRes.
const (
	CompressionAlgosResDeflate    CompressionAlgosRes = "deflate"
	CompressionAlgosResGzip       CompressionAlgosRes = "gzip"
	CompressionAlgosResIdentity   CompressionAlgosRes = "identity"
	CompressionAlgosResRawDeflate CompressionAlgosRes = "raw-deflate"
)

// Defines values for CompressionDirection.
const (
	CompressionDirectionBoth     CompressionDirection = "both"
	CompressionDirectionRequest  CompressionDirection = "request"
	CompressionDirectionResponse CompressionDirection = "response"
)

// Defines values for ConfigStickTableSrvkey.
const (
	ConfigStickTableSrvkeyAddr ConfigStickTableSrvkey = "addr"
	ConfigStickTableSrvkeyName ConfigStickTableSrvkey = "name"
)

// Defines values for ConfigStickTableType.
const (
	ConfigStickTableTypeBinary  ConfigStickTableType = "binary"
	ConfigStickTableTypeInteger ConfigStickTableType = "integer"
	ConfigStickTableTypeIp      ConfigStickTableType = "ip"
	ConfigStickTableTypeIpv6    ConfigStickTableType = "ipv6"
	ConfigStickTableTypeString  ConfigStickTableType = "string"
)

// Defines values for ConsulHealthCheckPolicy.
const (
	ConsulHealthCheckPolicyAll  ConsulHealthCheckPolicy = "all"
	ConsulHealthCheckPolicyAny  ConsulHealthCheckPolicy = "any"
	ConsulHealthCheckPolicyMin  ConsulHealthCheckPolicy = "min"
	ConsulHealthCheckPolicyNone ConsulHealthCheckPolicy = "none"
)

// Defines values for ConsulMode.
const (
	ConsulModeHttp  ConsulMode = "http"
	ConsulModeHttps ConsulMode = "https"
)

// Defines values for ConsulServerSlotsGrowthType.
const (
	ConsulServerSlotsGrowthTypeExponential ConsulServerSlotsGrowthType = "exponential"
	ConsulServerSlotsGrowthTypeLinear      ConsulServerSlotsGrowthType = "linear"
)

// Defines values for CookieType.
const (
	CookieTypeInsert  CookieType = "insert"
	CookieTypePrefix  CookieType = "prefix"
	CookieTypeRewrite CookieType = "rewrite"
)

// Defines values for CrtLoadOcspUpdate.
const (
	CrtLoadOcspUpdateDisabled CrtLoadOcspUpdate = "disabled"
	CrtLoadOcspUpdateEnabled  CrtLoadOcspUpdate = "enabled"
)

// Defines values for DefaultsAbortonclose.
const (
	DefaultsAbortoncloseDisabled DefaultsAbortonclose = "disabled"
	DefaultsAbortoncloseEnabled  DefaultsAbortonclose = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpRequest.
const (
	DefaultsAcceptInvalidHttpRequestDisabled DefaultsAcceptInvalidHttpRequest = "disabled"
	DefaultsAcceptInvalidHttpRequestEnabled  DefaultsAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpResponse.
const (
	DefaultsAcceptInvalidHttpResponseDisabled DefaultsAcceptInvalidHttpResponse = "disabled"
	DefaultsAcceptInvalidHttpResponseEnabled  DefaultsAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsAcceptUnsafeViolationsInHttpRequest.
const (
	DefaultsAcceptUnsafeViolationsInHttpRequestDisabled DefaultsAcceptUnsafeViolationsInHttpRequest = "disabled"
	DefaultsAcceptUnsafeViolationsInHttpRequestEnabled  DefaultsAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for DefaultsAcceptUnsafeViolationsInHttpResponse.
const (
	DefaultsAcceptUnsafeViolationsInHttpResponseDisabled DefaultsAcceptUnsafeViolationsInHttpResponse = "disabled"
	DefaultsAcceptUnsafeViolationsInHttpResponseEnabled  DefaultsAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for DefaultsAdvCheck.
const (
	DefaultsAdvCheckHttpchk     DefaultsAdvCheck = "httpchk"
	DefaultsAdvCheckLdapCheck   DefaultsAdvCheck = "ldap-check"
	DefaultsAdvCheckMysqlCheck  DefaultsAdvCheck = "mysql-check"
	DefaultsAdvCheckPgsqlCheck  DefaultsAdvCheck = "pgsql-check"
	DefaultsAdvCheckRedisCheck  DefaultsAdvCheck = "redis-check"
	DefaultsAdvCheckSmtpchk     DefaultsAdvCheck = "smtpchk"
	DefaultsAdvCheckSslHelloChk DefaultsAdvCheck = "ssl-hello-chk"
	DefaultsAdvCheckTcpCheck    DefaultsAdvCheck = "tcp-check"
)

// Defines values for DefaultsAllbackups.
const (
	DefaultsAllbackupsDisabled DefaultsAllbackups = "disabled"
	DefaultsAllbackupsEnabled  DefaultsAllbackups = "enabled"
)

// Defines values for DefaultsCheckcache.
const (
	DefaultsCheckcacheDisabled DefaultsCheckcache = "disabled"
	DefaultsCheckcacheEnabled  DefaultsCheckcache = "enabled"
)

// Defines values for DefaultsClitcpka.
const (
	DefaultsClitcpkaDisabled DefaultsClitcpka = "disabled"
	DefaultsClitcpkaEnabled  DefaultsClitcpka = "enabled"
)

// Defines values for DefaultsContstats.
const (
	DefaultsContstatsEnabled DefaultsContstats = "enabled"
)

// Defines values for DefaultsDisableH2Upgrade.
const (
	DefaultsDisableH2UpgradeDisabled DefaultsDisableH2Upgrade = "disabled"
	DefaultsDisableH2UpgradeEnabled  DefaultsDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsDontlogNormal.
const (
	DefaultsDontlogNormalDisabled DefaultsDontlogNormal = "disabled"
	DefaultsDontlogNormalEnabled  DefaultsDontlogNormal = "enabled"
)

// Defines values for DefaultsDontlognull.
const (
	DefaultsDontlognullDisabled DefaultsDontlognull = "disabled"
	DefaultsDontlognullEnabled  DefaultsDontlognull = "enabled"
)

// Defines values for DefaultsExternalCheck.
const (
	DefaultsExternalCheckDisabled DefaultsExternalCheck = "disabled"
	DefaultsExternalCheckEnabled  DefaultsExternalCheck = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusClient.
const (
	DefaultsH1CaseAdjustBogusClientDisabled DefaultsH1CaseAdjustBogusClient = "disabled"
	DefaultsH1CaseAdjustBogusClientEnabled  DefaultsH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusServer.
const (
	DefaultsH1CaseAdjustBogusServerDisabled DefaultsH1CaseAdjustBogusServer = "disabled"
	DefaultsH1CaseAdjustBogusServerEnabled  DefaultsH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsHttpBufferRequest.
const (
	DefaultsHttpBufferRequestDisabled DefaultsHttpBufferRequest = "disabled"
	DefaultsHttpBufferRequestEnabled  DefaultsHttpBufferRequest = "enabled"
)

// Defines values for DefaultsHttpUseHtx.
const (
	DefaultsHttpUseHtxDisabled DefaultsHttpUseHtx = "disabled"
	DefaultsHttpUseHtxEnabled  DefaultsHttpUseHtx = "enabled"
)

// Defines values for DefaultsHttpConnectionMode.
const (
	DefaultsHttpConnectionModeHttpKeepAlive   DefaultsHttpConnectionMode = "http-keep-alive"
	DefaultsHttpConnectionModeHttpServerClose DefaultsHttpConnectionMode = "http-server-close"
	DefaultsHttpConnectionModeHttpclose       DefaultsHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsHttpIgnoreProbes.
const (
	DefaultsHttpIgnoreProbesDisabled DefaultsHttpIgnoreProbes = "disabled"
	DefaultsHttpIgnoreProbesEnabled  DefaultsHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsHttpNoDelay.
const (
	DefaultsHttpNoDelayDisabled DefaultsHttpNoDelay = "disabled"
	DefaultsHttpNoDelayEnabled  DefaultsHttpNoDelay = "enabled"
)

// Defines values for DefaultsHttpPretendKeepalive.
const (
	DefaultsHttpPretendKeepaliveDisabled DefaultsHttpPretendKeepalive = "disabled"
	DefaultsHttpPretendKeepaliveEnabled  DefaultsHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsHttpRestrictReqHdrNames.
const (
	DefaultsHttpRestrictReqHdrNamesDelete   DefaultsHttpRestrictReqHdrNames = "delete"
	DefaultsHttpRestrictReqHdrNamesPreserve DefaultsHttpRestrictReqHdrNames = "preserve"
	DefaultsHttpRestrictReqHdrNamesReject   DefaultsHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsHttpReuse.
const (
	DefaultsHttpReuseAggressive DefaultsHttpReuse = "aggressive"
	DefaultsHttpReuseAlways     DefaultsHttpReuse = "always"
	DefaultsHttpReuseNever      DefaultsHttpReuse = "never"
	DefaultsHttpReuseSafe       DefaultsHttpReuse = "safe"
)

// Defines values for DefaultsHttpUseProxyHeader.
const (
	DefaultsHttpUseProxyHeaderDisabled DefaultsHttpUseProxyHeader = "disabled"
	DefaultsHttpUseProxyHeaderEnabled  DefaultsHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsHttpslog.
const (
	DefaultsHttpslogDisabled DefaultsHttpslog = "disabled"
	DefaultsHttpslogEnabled  DefaultsHttpslog = "enabled"
)

// Defines values for DefaultsIdleCloseOnResponse.
const (
	DefaultsIdleCloseOnResponseDisabled DefaultsIdleCloseOnResponse = "disabled"
	DefaultsIdleCloseOnResponseEnabled  DefaultsIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsIndependentStreams.
const (
	DefaultsIndependentStreamsDisabled DefaultsIndependentStreams = "disabled"
	DefaultsIndependentStreamsEnabled  DefaultsIndependentStreams = "enabled"
)

// Defines values for DefaultsLoadServerStateFromFile.
const (
	DefaultsLoadServerStateFromFileGlobal DefaultsLoadServerStateFromFile = "global"
	DefaultsLoadServerStateFromFileLocal  DefaultsLoadServerStateFromFile = "local"
	DefaultsLoadServerStateFromFileNone   DefaultsLoadServerStateFromFile = "none"
)

// Defines values for DefaultsLogHealthChecks.
const (
	DefaultsLogHealthChecksDisabled DefaultsLogHealthChecks = "disabled"
	DefaultsLogHealthChecksEnabled  DefaultsLogHealthChecks = "enabled"
)

// Defines values for DefaultsLogSeparateErrors.
const (
	DefaultsLogSeparateErrorsDisabled DefaultsLogSeparateErrors = "disabled"
	DefaultsLogSeparateErrorsEnabled  DefaultsLogSeparateErrors = "enabled"
)

// Defines values for DefaultsLogSteps.
const (
	DefaultsLogStepsAccept   DefaultsLogSteps = "accept"
	DefaultsLogStepsAny      DefaultsLogSteps = "any"
	DefaultsLogStepsClose    DefaultsLogSteps = "close"
	DefaultsLogStepsConnect  DefaultsLogSteps = "connect"
	DefaultsLogStepsError    DefaultsLogSteps = "error"
	DefaultsLogStepsRequest  DefaultsLogSteps = "request"
	DefaultsLogStepsResponse DefaultsLogSteps = "response"
)

// Defines values for DefaultsLogasap.
const (
	DefaultsLogasapDisabled DefaultsLogasap = "disabled"
	DefaultsLogasapEnabled  DefaultsLogasap = "enabled"
)

// Defines values for DefaultsMode.
const (
	DefaultsModeHttp DefaultsMode = "http"
	DefaultsModeLog  DefaultsMode = "log"
	DefaultsModeTcp  DefaultsMode = "tcp"
)

// Defines values for DefaultsNolinger.
const (
	DefaultsNolingerDisabled DefaultsNolinger = "disabled"
	DefaultsNolingerEnabled  DefaultsNolinger = "enabled"
)

// Defines values for DefaultsPersist.
const (
	DefaultsPersistDisabled DefaultsPersist = "disabled"
	DefaultsPersistEnabled  DefaultsPersist = "enabled"
)

// Defines values for DefaultsPreferLastServer.
const (
	DefaultsPreferLastServerDisabled DefaultsPreferLastServer = "disabled"
	DefaultsPreferLastServerEnabled  DefaultsPreferLastServer = "enabled"
)

// Defines values for DefaultsSocketStats.
const (
	DefaultsSocketStatsDisabled DefaultsSocketStats = "disabled"
	DefaultsSocketStatsEnabled  DefaultsSocketStats = "enabled"
)

// Defines values for DefaultsSpliceAuto.
const (
	DefaultsSpliceAutoDisabled DefaultsSpliceAuto = "disabled"
	DefaultsSpliceAutoEnabled  DefaultsSpliceAuto = "enabled"
)

// Defines values for DefaultsSpliceRequest.
const (
	DefaultsSpliceRequestDisabled DefaultsSpliceRequest = "disabled"
	DefaultsSpliceRequestEnabled  DefaultsSpliceRequest = "enabled"
)

// Defines values for DefaultsSpliceResponse.
const (
	DefaultsSpliceResponseDisabled DefaultsSpliceResponse = "disabled"
	DefaultsSpliceResponseEnabled  DefaultsSpliceResponse = "enabled"
)

// Defines values for DefaultsSrvtcpka.
const (
	DefaultsSrvtcpkaDisabled DefaultsSrvtcpka = "disabled"
	DefaultsSrvtcpkaEnabled  DefaultsSrvtcpka = "enabled"
)

// Defines values for DefaultsTcpSmartAccept.
const (
	DefaultsTcpSmartAcceptDisabled DefaultsTcpSmartAccept = "disabled"
	DefaultsTcpSmartAcceptEnabled  DefaultsTcpSmartAccept = "enabled"
)

// Defines values for DefaultsTcpSmartConnect.
const (
	DefaultsTcpSmartConnectDisabled DefaultsTcpSmartConnect = "disabled"
	DefaultsTcpSmartConnectEnabled  DefaultsTcpSmartConnect = "enabled"
)

// Defines values for DefaultsTcpka.
const (
	DefaultsTcpkaDisabled DefaultsTcpka = "disabled"
	DefaultsTcpkaEnabled  DefaultsTcpka = "enabled"
)

// Defines values for DefaultsTransparent.
const (
	DefaultsTransparentDisabled DefaultsTransparent = "disabled"
	DefaultsTransparentEnabled  DefaultsTransparent = "enabled"
)

// Defines values for DefaultsBaseAbortonclose.
const (
	DefaultsBaseAbortoncloseDisabled DefaultsBaseAbortonclose = "disabled"
	DefaultsBaseAbortoncloseEnabled  DefaultsBaseAbortonclose = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpRequest.
const (
	DefaultsBaseAcceptInvalidHttpRequestDisabled DefaultsBaseAcceptInvalidHttpRequest = "disabled"
	DefaultsBaseAcceptInvalidHttpRequestEnabled  DefaultsBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpResponse.
const (
	DefaultsBaseAcceptInvalidHttpResponseDisabled DefaultsBaseAcceptInvalidHttpResponse = "disabled"
	DefaultsBaseAcceptInvalidHttpResponseEnabled  DefaultsBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsBaseAcceptUnsafeViolationsInHttpRequest.
const (
	DefaultsBaseAcceptUnsafeViolationsInHttpRequestDisabled DefaultsBaseAcceptUnsafeViolationsInHttpRequest = "disabled"
	DefaultsBaseAcceptUnsafeViolationsInHttpRequestEnabled  DefaultsBaseAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for DefaultsBaseAcceptUnsafeViolationsInHttpResponse.
const (
	DefaultsBaseAcceptUnsafeViolationsInHttpResponseDisabled DefaultsBaseAcceptUnsafeViolationsInHttpResponse = "disabled"
	DefaultsBaseAcceptUnsafeViolationsInHttpResponseEnabled  DefaultsBaseAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for DefaultsBaseAdvCheck.
const (
	DefaultsBaseAdvCheckHttpchk     DefaultsBaseAdvCheck = "httpchk"
	DefaultsBaseAdvCheckLdapCheck   DefaultsBaseAdvCheck = "ldap-check"
	DefaultsBaseAdvCheckMysqlCheck  DefaultsBaseAdvCheck = "mysql-check"
	DefaultsBaseAdvCheckPgsqlCheck  DefaultsBaseAdvCheck = "pgsql-check"
	DefaultsBaseAdvCheckRedisCheck  DefaultsBaseAdvCheck = "redis-check"
	DefaultsBaseAdvCheckSmtpchk     DefaultsBaseAdvCheck = "smtpchk"
	DefaultsBaseAdvCheckSslHelloChk DefaultsBaseAdvCheck = "ssl-hello-chk"
	DefaultsBaseAdvCheckTcpCheck    DefaultsBaseAdvCheck = "tcp-check"
)

// Defines values for DefaultsBaseAllbackups.
const (
	DefaultsBaseAllbackupsDisabled DefaultsBaseAllbackups = "disabled"
	DefaultsBaseAllbackupsEnabled  DefaultsBaseAllbackups = "enabled"
)

// Defines values for DefaultsBaseCheckcache.
const (
	DefaultsBaseCheckcacheDisabled DefaultsBaseCheckcache = "disabled"
	DefaultsBaseCheckcacheEnabled  DefaultsBaseCheckcache = "enabled"
)

// Defines values for DefaultsBaseClitcpka.
const (
	DefaultsBaseClitcpkaDisabled DefaultsBaseClitcpka = "disabled"
	DefaultsBaseClitcpkaEnabled  DefaultsBaseClitcpka = "enabled"
)

// Defines values for DefaultsBaseContstats.
const (
	DefaultsBaseContstatsEnabled DefaultsBaseContstats = "enabled"
)

// Defines values for DefaultsBaseDisableH2Upgrade.
const (
	DefaultsBaseDisableH2UpgradeDisabled DefaultsBaseDisableH2Upgrade = "disabled"
	DefaultsBaseDisableH2UpgradeEnabled  DefaultsBaseDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsBaseDontlogNormal.
const (
	DefaultsBaseDontlogNormalDisabled DefaultsBaseDontlogNormal = "disabled"
	DefaultsBaseDontlogNormalEnabled  DefaultsBaseDontlogNormal = "enabled"
)

// Defines values for DefaultsBaseDontlognull.
const (
	DefaultsBaseDontlognullDisabled DefaultsBaseDontlognull = "disabled"
	DefaultsBaseDontlognullEnabled  DefaultsBaseDontlognull = "enabled"
)

// Defines values for DefaultsBaseExternalCheck.
const (
	DefaultsBaseExternalCheckDisabled DefaultsBaseExternalCheck = "disabled"
	DefaultsBaseExternalCheckEnabled  DefaultsBaseExternalCheck = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusClient.
const (
	DefaultsBaseH1CaseAdjustBogusClientDisabled DefaultsBaseH1CaseAdjustBogusClient = "disabled"
	DefaultsBaseH1CaseAdjustBogusClientEnabled  DefaultsBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusServer.
const (
	DefaultsBaseH1CaseAdjustBogusServerDisabled DefaultsBaseH1CaseAdjustBogusServer = "disabled"
	DefaultsBaseH1CaseAdjustBogusServerEnabled  DefaultsBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsBaseHttpBufferRequest.
const (
	DefaultsBaseHttpBufferRequestDisabled DefaultsBaseHttpBufferRequest = "disabled"
	DefaultsBaseHttpBufferRequestEnabled  DefaultsBaseHttpBufferRequest = "enabled"
)

// Defines values for DefaultsBaseHttpUseHtx.
const (
	DefaultsBaseHttpUseHtxDisabled DefaultsBaseHttpUseHtx = "disabled"
	DefaultsBaseHttpUseHtxEnabled  DefaultsBaseHttpUseHtx = "enabled"
)

// Defines values for DefaultsBaseHttpConnectionMode.
const (
	DefaultsBaseHttpConnectionModeHttpKeepAlive   DefaultsBaseHttpConnectionMode = "http-keep-alive"
	DefaultsBaseHttpConnectionModeHttpServerClose DefaultsBaseHttpConnectionMode = "http-server-close"
	DefaultsBaseHttpConnectionModeHttpclose       DefaultsBaseHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsBaseHttpIgnoreProbes.
const (
	DefaultsBaseHttpIgnoreProbesDisabled DefaultsBaseHttpIgnoreProbes = "disabled"
	DefaultsBaseHttpIgnoreProbesEnabled  DefaultsBaseHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsBaseHttpNoDelay.
const (
	DefaultsBaseHttpNoDelayDisabled DefaultsBaseHttpNoDelay = "disabled"
	DefaultsBaseHttpNoDelayEnabled  DefaultsBaseHttpNoDelay = "enabled"
)

// Defines values for DefaultsBaseHttpPretendKeepalive.
const (
	DefaultsBaseHttpPretendKeepaliveDisabled DefaultsBaseHttpPretendKeepalive = "disabled"
	DefaultsBaseHttpPretendKeepaliveEnabled  DefaultsBaseHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsBaseHttpRestrictReqHdrNames.
const (
	DefaultsBaseHttpRestrictReqHdrNamesDelete   DefaultsBaseHttpRestrictReqHdrNames = "delete"
	DefaultsBaseHttpRestrictReqHdrNamesPreserve DefaultsBaseHttpRestrictReqHdrNames = "preserve"
	DefaultsBaseHttpRestrictReqHdrNamesReject   DefaultsBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsBaseHttpReuse.
const (
	DefaultsBaseHttpReuseAggressive DefaultsBaseHttpReuse = "aggressive"
	DefaultsBaseHttpReuseAlways     DefaultsBaseHttpReuse = "always"
	DefaultsBaseHttpReuseNever      DefaultsBaseHttpReuse = "never"
	DefaultsBaseHttpReuseSafe       DefaultsBaseHttpReuse = "safe"
)

// Defines values for DefaultsBaseHttpUseProxyHeader.
const (
	DefaultsBaseHttpUseProxyHeaderDisabled DefaultsBaseHttpUseProxyHeader = "disabled"
	DefaultsBaseHttpUseProxyHeaderEnabled  DefaultsBaseHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsBaseHttpslog.
const (
	DefaultsBaseHttpslogDisabled DefaultsBaseHttpslog = "disabled"
	DefaultsBaseHttpslogEnabled  DefaultsBaseHttpslog = "enabled"
)

// Defines values for DefaultsBaseIdleCloseOnResponse.
const (
	DefaultsBaseIdleCloseOnResponseDisabled DefaultsBaseIdleCloseOnResponse = "disabled"
	DefaultsBaseIdleCloseOnResponseEnabled  DefaultsBaseIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsBaseIndependentStreams.
const (
	DefaultsBaseIndependentStreamsDisabled DefaultsBaseIndependentStreams = "disabled"
	DefaultsBaseIndependentStreamsEnabled  DefaultsBaseIndependentStreams = "enabled"
)

// Defines values for DefaultsBaseLoadServerStateFromFile.
const (
	DefaultsBaseLoadServerStateFromFileGlobal DefaultsBaseLoadServerStateFromFile = "global"
	DefaultsBaseLoadServerStateFromFileLocal  DefaultsBaseLoadServerStateFromFile = "local"
	DefaultsBaseLoadServerStateFromFileNone   DefaultsBaseLoadServerStateFromFile = "none"
)

// Defines values for DefaultsBaseLogHealthChecks.
const (
	DefaultsBaseLogHealthChecksDisabled DefaultsBaseLogHealthChecks = "disabled"
	DefaultsBaseLogHealthChecksEnabled  DefaultsBaseLogHealthChecks = "enabled"
)

// Defines values for DefaultsBaseLogSeparateErrors.
const (
	DefaultsBaseLogSeparateErrorsDisabled DefaultsBaseLogSeparateErrors = "disabled"
	DefaultsBaseLogSeparateErrorsEnabled  DefaultsBaseLogSeparateErrors = "enabled"
)

// Defines values for DefaultsBaseLogSteps.
const (
	DefaultsBaseLogStepsAccept   DefaultsBaseLogSteps = "accept"
	DefaultsBaseLogStepsAny      DefaultsBaseLogSteps = "any"
	DefaultsBaseLogStepsClose    DefaultsBaseLogSteps = "close"
	DefaultsBaseLogStepsConnect  DefaultsBaseLogSteps = "connect"
	DefaultsBaseLogStepsError    DefaultsBaseLogSteps = "error"
	DefaultsBaseLogStepsRequest  DefaultsBaseLogSteps = "request"
	DefaultsBaseLogStepsResponse DefaultsBaseLogSteps = "response"
)

// Defines values for DefaultsBaseLogasap.
const (
	DefaultsBaseLogasapDisabled DefaultsBaseLogasap = "disabled"
	DefaultsBaseLogasapEnabled  DefaultsBaseLogasap = "enabled"
)

// Defines values for DefaultsBaseMode.
const (
	DefaultsBaseModeHttp DefaultsBaseMode = "http"
	DefaultsBaseModeLog  DefaultsBaseMode = "log"
	DefaultsBaseModeTcp  DefaultsBaseMode = "tcp"
)

// Defines values for DefaultsBaseNolinger.
const (
	DefaultsBaseNolingerDisabled DefaultsBaseNolinger = "disabled"
	DefaultsBaseNolingerEnabled  DefaultsBaseNolinger = "enabled"
)

// Defines values for DefaultsBasePersist.
const (
	DefaultsBasePersistDisabled DefaultsBasePersist = "disabled"
	DefaultsBasePersistEnabled  DefaultsBasePersist = "enabled"
)

// Defines values for DefaultsBasePreferLastServer.
const (
	DefaultsBasePreferLastServerDisabled DefaultsBasePreferLastServer = "disabled"
	DefaultsBasePreferLastServerEnabled  DefaultsBasePreferLastServer = "enabled"
)

// Defines values for DefaultsBaseSocketStats.
const (
	DefaultsBaseSocketStatsDisabled DefaultsBaseSocketStats = "disabled"
	DefaultsBaseSocketStatsEnabled  DefaultsBaseSocketStats = "enabled"
)

// Defines values for DefaultsBaseSpliceAuto.
const (
	DefaultsBaseSpliceAutoDisabled DefaultsBaseSpliceAuto = "disabled"
	DefaultsBaseSpliceAutoEnabled  DefaultsBaseSpliceAuto = "enabled"
)

// Defines values for DefaultsBaseSpliceRequest.
const (
	DefaultsBaseSpliceRequestDisabled DefaultsBaseSpliceRequest = "disabled"
	DefaultsBaseSpliceRequestEnabled  DefaultsBaseSpliceRequest = "enabled"
)

// Defines values for DefaultsBaseSpliceResponse.
const (
	DefaultsBaseSpliceResponseDisabled DefaultsBaseSpliceResponse = "disabled"
	DefaultsBaseSpliceResponseEnabled  DefaultsBaseSpliceResponse = "enabled"
)

// Defines values for DefaultsBaseSrvtcpka.
const (
	DefaultsBaseSrvtcpkaDisabled DefaultsBaseSrvtcpka = "disabled"
	DefaultsBaseSrvtcpkaEnabled  DefaultsBaseSrvtcpka = "enabled"
)

// Defines values for DefaultsBaseTcpSmartAccept.
const (
	DefaultsBaseTcpSmartAcceptDisabled DefaultsBaseTcpSmartAccept = "disabled"
	DefaultsBaseTcpSmartAcceptEnabled  DefaultsBaseTcpSmartAccept = "enabled"
)

// Defines values for DefaultsBaseTcpSmartConnect.
const (
	DefaultsBaseTcpSmartConnectDisabled DefaultsBaseTcpSmartConnect = "disabled"
	DefaultsBaseTcpSmartConnectEnabled  DefaultsBaseTcpSmartConnect = "enabled"
)

// Defines values for DefaultsBaseTcpka.
const (
	DefaultsBaseTcpkaDisabled DefaultsBaseTcpka = "disabled"
	DefaultsBaseTcpkaEnabled  DefaultsBaseTcpka = "enabled"
)

// Defines values for DefaultsBaseTransparent.
const (
	DefaultsBaseTransparentDisabled DefaultsBaseTransparent = "disabled"
	DefaultsBaseTransparentEnabled  DefaultsBaseTransparent = "enabled"
)

// Defines values for EmailAlertLevel.
const (
	EmailAlertLevelAlert   EmailAlertLevel = "alert"
	EmailAlertLevelCrit    EmailAlertLevel = "crit"
	EmailAlertLevelDebug   EmailAlertLevel = "debug"
	EmailAlertLevelEmerg   EmailAlertLevel = "emerg"
	EmailAlertLevelErr     EmailAlertLevel = "err"
	EmailAlertLevelInfo    EmailAlertLevel = "info"
	EmailAlertLevelNotice  EmailAlertLevel = "notice"
	EmailAlertLevelWarning EmailAlertLevel = "warning"
)

// Defines values for ErrorfileCode.
const (
	ErrorfileCodeN200 ErrorfileCode = 200
	ErrorfileCodeN400 ErrorfileCode = 400
	ErrorfileCodeN401 ErrorfileCode = 401
	ErrorfileCodeN403 ErrorfileCode = 403
	ErrorfileCodeN404 ErrorfileCode = 404
	ErrorfileCodeN405 ErrorfileCode = 405
	ErrorfileCodeN407 ErrorfileCode = 407
	ErrorfileCodeN408 ErrorfileCode = 408
	ErrorfileCodeN410 ErrorfileCode = 410
	ErrorfileCodeN413 ErrorfileCode = 413
	ErrorfileCodeN425 ErrorfileCode = 425
	ErrorfileCodeN429 ErrorfileCode = 429
	ErrorfileCodeN500 ErrorfileCode = 500
	ErrorfileCodeN501 ErrorfileCode = 501
	ErrorfileCodeN502 ErrorfileCode = 502
	ErrorfileCodeN503 ErrorfileCode = 503
	ErrorfileCodeN504 ErrorfileCode = 504
)

// Defines values for ErrorfilesCodes.
const (
	ErrorfilesCodesN200 ErrorfilesCodes = 200
	ErrorfilesCodesN400 ErrorfilesCodes = 400
	ErrorfilesCodesN401 ErrorfilesCodes = 401
	ErrorfilesCodesN403 ErrorfilesCodes = 403
	ErrorfilesCodesN404 ErrorfilesCodes = 404
	ErrorfilesCodesN405 ErrorfilesCodes = 405
	ErrorfilesCodesN407 ErrorfilesCodes = 407
	ErrorfilesCodesN408 ErrorfilesCodes = 408
	ErrorfilesCodesN410 ErrorfilesCodes = 410
	ErrorfilesCodesN413 ErrorfilesCodes = 413
	ErrorfilesCodesN425 ErrorfilesCodes = 425
	ErrorfilesCodesN429 ErrorfilesCodes = 429
	ErrorfilesCodesN500 ErrorfilesCodes = 500
	ErrorfilesCodesN501 ErrorfilesCodes = 501
	ErrorfilesCodesN502 ErrorfilesCodes = 502
	ErrorfilesCodesN503 ErrorfilesCodes = 503
	ErrorfilesCodesN504 ErrorfilesCodes = 504
)

// Defines values for ErrorlocCode.
const (
	ErrorlocCodeN200 ErrorlocCode = 200
	ErrorlocCodeN400 ErrorlocCode = 400
	ErrorlocCodeN401 ErrorlocCode = 401
	ErrorlocCodeN403 ErrorlocCode = 403
	ErrorlocCodeN404 ErrorlocCode = 404
	ErrorlocCodeN405 ErrorlocCode = 405
	ErrorlocCodeN407 ErrorlocCode = 407
	ErrorlocCodeN408 ErrorlocCode = 408
	ErrorlocCodeN410 ErrorlocCode = 410
	ErrorlocCodeN413 ErrorlocCode = 413
	ErrorlocCodeN425 ErrorlocCode = 425
	ErrorlocCodeN429 ErrorlocCode = 429
	ErrorlocCodeN500 ErrorlocCode = 500
	ErrorlocCodeN501 ErrorlocCode = 501
	ErrorlocCodeN502 ErrorlocCode = 502
	ErrorlocCodeN503 ErrorlocCode = 503
	ErrorlocCodeN504 ErrorlocCode = 504
)

// Defines values for FcgiAppGetValues.
const (
	FcgiAppGetValuesDisabled FcgiAppGetValues = "disabled"
	FcgiAppGetValuesEnabled  FcgiAppGetValues = "enabled"
)

// Defines values for FcgiAppKeepConn.
const (
	FcgiAppKeepConnDisabled FcgiAppKeepConn = "disabled"
	FcgiAppKeepConnEnabled  FcgiAppKeepConn = "enabled"
)

// Defines values for FcgiAppMpxsConns.
const (
	FcgiAppMpxsConnsDisabled FcgiAppMpxsConns = "disabled"
	FcgiAppMpxsConnsEnabled  FcgiAppMpxsConns = "enabled"
)

// Defines values for FcgiAppBaseGetValues.
const (
	FcgiAppBaseGetValuesDisabled FcgiAppBaseGetValues = "disabled"
	FcgiAppBaseGetValuesEnabled  FcgiAppBaseGetValues = "enabled"
)

// Defines values for FcgiAppBaseKeepConn.
const (
	FcgiAppBaseKeepConnDisabled FcgiAppBaseKeepConn = "disabled"
	FcgiAppBaseKeepConnEnabled  FcgiAppBaseKeepConn = "enabled"
)

// Defines values for FcgiAppBaseMpxsConns.
const (
	FcgiAppBaseMpxsConnsDisabled FcgiAppBaseMpxsConns = "disabled"
	FcgiAppBaseMpxsConnsEnabled  FcgiAppBaseMpxsConns = "enabled"
)

// Defines values for FcgiPassHeaderCond.
const (
	FcgiPassHeaderCondIf     FcgiPassHeaderCond = "if"
	FcgiPassHeaderCondUnless FcgiPassHeaderCond = "unless"
)

// Defines values for FcgiSetParamCond.
const (
	FcgiSetParamCondIf     FcgiSetParamCond = "if"
	FcgiSetParamCondUnless FcgiSetParamCond = "unless"
)

// Defines values for FilterType.
const (
	FilterTypeBwlimIn     FilterType = "bwlim-in"
	FilterTypeBwlimOut    FilterType = "bwlim-out"
	FilterTypeCache       FilterType = "cache"
	FilterTypeCompression FilterType = "compression"
	FilterTypeFcgiApp     FilterType = "fcgi-app"
	FilterTypeSpoe        FilterType = "spoe"
	FilterTypeTrace       FilterType = "trace"
)

// Defines values for ForwardforEnabled.
const (
	ForwardforEnabledEnabled ForwardforEnabled = "enabled"
)

// Defines values for FrontendAcceptInvalidHttpRequest.
const (
	FrontendAcceptInvalidHttpRequestDisabled FrontendAcceptInvalidHttpRequest = "disabled"
	FrontendAcceptInvalidHttpRequestEnabled  FrontendAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendAcceptUnsafeViolationsInHttpRequest.
const (
	FrontendAcceptUnsafeViolationsInHttpRequestDisabled FrontendAcceptUnsafeViolationsInHttpRequest = "disabled"
	FrontendAcceptUnsafeViolationsInHttpRequestEnabled  FrontendAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for FrontendClitcpka.
const (
	FrontendClitcpkaDisabled FrontendClitcpka = "disabled"
	FrontendClitcpkaEnabled  FrontendClitcpka = "enabled"
)

// Defines values for FrontendContstats.
const (
	FrontendContstatsEnabled FrontendContstats = "enabled"
)

// Defines values for FrontendDisableH2Upgrade.
const (
	FrontendDisableH2UpgradeDisabled FrontendDisableH2Upgrade = "disabled"
	FrontendDisableH2UpgradeEnabled  FrontendDisableH2Upgrade = "enabled"
)

// Defines values for FrontendDontlogNormal.
const (
	FrontendDontlogNormalDisabled FrontendDontlogNormal = "disabled"
	FrontendDontlogNormalEnabled  FrontendDontlogNormal = "enabled"
)

// Defines values for FrontendDontlognull.
const (
	FrontendDontlognullDisabled FrontendDontlognull = "disabled"
	FrontendDontlognullEnabled  FrontendDontlognull = "enabled"
)

// Defines values for FrontendH1CaseAdjustBogusClient.
const (
	FrontendH1CaseAdjustBogusClientDisabled FrontendH1CaseAdjustBogusClient = "disabled"
	FrontendH1CaseAdjustBogusClientEnabled  FrontendH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendHttpBufferRequest.
const (
	FrontendHttpBufferRequestDisabled FrontendHttpBufferRequest = "disabled"
	FrontendHttpBufferRequestEnabled  FrontendHttpBufferRequest = "enabled"
)

// Defines values for FrontendHttpUseHtx.
const (
	FrontendHttpUseHtxDisabled FrontendHttpUseHtx = "disabled"
	FrontendHttpUseHtxEnabled  FrontendHttpUseHtx = "enabled"
)

// Defines values for FrontendHttpConnectionMode.
const (
	FrontendHttpConnectionModeHttpKeepAlive   FrontendHttpConnectionMode = "http-keep-alive"
	FrontendHttpConnectionModeHttpServerClose FrontendHttpConnectionMode = "http-server-close"
	FrontendHttpConnectionModeHttpclose       FrontendHttpConnectionMode = "httpclose"
)

// Defines values for FrontendHttpIgnoreProbes.
const (
	FrontendHttpIgnoreProbesDisabled FrontendHttpIgnoreProbes = "disabled"
	FrontendHttpIgnoreProbesEnabled  FrontendHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendHttpNoDelay.
const (
	FrontendHttpNoDelayDisabled FrontendHttpNoDelay = "disabled"
	FrontendHttpNoDelayEnabled  FrontendHttpNoDelay = "enabled"
)

// Defines values for FrontendHttpRestrictReqHdrNames.
const (
	FrontendHttpRestrictReqHdrNamesDelete   FrontendHttpRestrictReqHdrNames = "delete"
	FrontendHttpRestrictReqHdrNamesPreserve FrontendHttpRestrictReqHdrNames = "preserve"
	FrontendHttpRestrictReqHdrNamesReject   FrontendHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendHttpUseProxyHeader.
const (
	FrontendHttpUseProxyHeaderDisabled FrontendHttpUseProxyHeader = "disabled"
	FrontendHttpUseProxyHeaderEnabled  FrontendHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendHttpslog.
const (
	FrontendHttpslogDisabled FrontendHttpslog = "disabled"
	FrontendHttpslogEnabled  FrontendHttpslog = "enabled"
)

// Defines values for FrontendIdleCloseOnResponse.
const (
	FrontendIdleCloseOnResponseDisabled FrontendIdleCloseOnResponse = "disabled"
	FrontendIdleCloseOnResponseEnabled  FrontendIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendIndependentStreams.
const (
	FrontendIndependentStreamsDisabled FrontendIndependentStreams = "disabled"
	FrontendIndependentStreamsEnabled  FrontendIndependentStreams = "enabled"
)

// Defines values for FrontendLogSeparateErrors.
const (
	FrontendLogSeparateErrorsDisabled FrontendLogSeparateErrors = "disabled"
	FrontendLogSeparateErrorsEnabled  FrontendLogSeparateErrors = "enabled"
)

// Defines values for FrontendLogSteps.
const (
	FrontendLogStepsAccept   FrontendLogSteps = "accept"
	FrontendLogStepsAny      FrontendLogSteps = "any"
	FrontendLogStepsClose    FrontendLogSteps = "close"
	FrontendLogStepsConnect  FrontendLogSteps = "connect"
	FrontendLogStepsError    FrontendLogSteps = "error"
	FrontendLogStepsRequest  FrontendLogSteps = "request"
	FrontendLogStepsResponse FrontendLogSteps = "response"
)

// Defines values for FrontendLogasap.
const (
	FrontendLogasapDisabled FrontendLogasap = "disabled"
	FrontendLogasapEnabled  FrontendLogasap = "enabled"
)

// Defines values for FrontendMode.
const (
	FrontendModeHttp FrontendMode = "http"
	FrontendModeTcp  FrontendMode = "tcp"
)

// Defines values for FrontendNolinger.
const (
	FrontendNolingerDisabled FrontendNolinger = "disabled"
	FrontendNolingerEnabled  FrontendNolinger = "enabled"
)

// Defines values for FrontendSocketStats.
const (
	FrontendSocketStatsDisabled FrontendSocketStats = "disabled"
	FrontendSocketStatsEnabled  FrontendSocketStats = "enabled"
)

// Defines values for FrontendSpliceAuto.
const (
	FrontendSpliceAutoDisabled FrontendSpliceAuto = "disabled"
	FrontendSpliceAutoEnabled  FrontendSpliceAuto = "enabled"
)

// Defines values for FrontendSpliceRequest.
const (
	FrontendSpliceRequestDisabled FrontendSpliceRequest = "disabled"
	FrontendSpliceRequestEnabled  FrontendSpliceRequest = "enabled"
)

// Defines values for FrontendSpliceResponse.
const (
	FrontendSpliceResponseDisabled FrontendSpliceResponse = "disabled"
	FrontendSpliceResponseEnabled  FrontendSpliceResponse = "enabled"
)

// Defines values for FrontendTcpSmartAccept.
const (
	FrontendTcpSmartAcceptDisabled FrontendTcpSmartAccept = "disabled"
	FrontendTcpSmartAcceptEnabled  FrontendTcpSmartAccept = "enabled"
)

// Defines values for FrontendTcpka.
const (
	FrontendTcpkaDisabled FrontendTcpka = "disabled"
	FrontendTcpkaEnabled  FrontendTcpka = "enabled"
)

// Defines values for FrontendBaseAcceptInvalidHttpRequest.
const (
	FrontendBaseAcceptInvalidHttpRequestDisabled FrontendBaseAcceptInvalidHttpRequest = "disabled"
	FrontendBaseAcceptInvalidHttpRequestEnabled  FrontendBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendBaseAcceptUnsafeViolationsInHttpRequest.
const (
	FrontendBaseAcceptUnsafeViolationsInHttpRequestDisabled FrontendBaseAcceptUnsafeViolationsInHttpRequest = "disabled"
	FrontendBaseAcceptUnsafeViolationsInHttpRequestEnabled  FrontendBaseAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for FrontendBaseClitcpka.
const (
	FrontendBaseClitcpkaDisabled FrontendBaseClitcpka = "disabled"
	FrontendBaseClitcpkaEnabled  FrontendBaseClitcpka = "enabled"
)

// Defines values for FrontendBaseContstats.
const (
	FrontendBaseContstatsEnabled FrontendBaseContstats = "enabled"
)

// Defines values for FrontendBaseDisableH2Upgrade.
const (
	FrontendBaseDisableH2UpgradeDisabled FrontendBaseDisableH2Upgrade = "disabled"
	FrontendBaseDisableH2UpgradeEnabled  FrontendBaseDisableH2Upgrade = "enabled"
)

// Defines values for FrontendBaseDontlogNormal.
const (
	FrontendBaseDontlogNormalDisabled FrontendBaseDontlogNormal = "disabled"
	FrontendBaseDontlogNormalEnabled  FrontendBaseDontlogNormal = "enabled"
)

// Defines values for FrontendBaseDontlognull.
const (
	FrontendBaseDontlognullDisabled FrontendBaseDontlognull = "disabled"
	FrontendBaseDontlognullEnabled  FrontendBaseDontlognull = "enabled"
)

// Defines values for FrontendBaseH1CaseAdjustBogusClient.
const (
	FrontendBaseH1CaseAdjustBogusClientDisabled FrontendBaseH1CaseAdjustBogusClient = "disabled"
	FrontendBaseH1CaseAdjustBogusClientEnabled  FrontendBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendBaseHttpBufferRequest.
const (
	FrontendBaseHttpBufferRequestDisabled FrontendBaseHttpBufferRequest = "disabled"
	FrontendBaseHttpBufferRequestEnabled  FrontendBaseHttpBufferRequest = "enabled"
)

// Defines values for FrontendBaseHttpUseHtx.
const (
	FrontendBaseHttpUseHtxDisabled FrontendBaseHttpUseHtx = "disabled"
	FrontendBaseHttpUseHtxEnabled  FrontendBaseHttpUseHtx = "enabled"
)

// Defines values for FrontendBaseHttpConnectionMode.
const (
	FrontendBaseHttpConnectionModeHttpKeepAlive   FrontendBaseHttpConnectionMode = "http-keep-alive"
	FrontendBaseHttpConnectionModeHttpServerClose FrontendBaseHttpConnectionMode = "http-server-close"
	FrontendBaseHttpConnectionModeHttpclose       FrontendBaseHttpConnectionMode = "httpclose"
)

// Defines values for FrontendBaseHttpIgnoreProbes.
const (
	FrontendBaseHttpIgnoreProbesDisabled FrontendBaseHttpIgnoreProbes = "disabled"
	FrontendBaseHttpIgnoreProbesEnabled  FrontendBaseHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendBaseHttpNoDelay.
const (
	FrontendBaseHttpNoDelayDisabled FrontendBaseHttpNoDelay = "disabled"
	FrontendBaseHttpNoDelayEnabled  FrontendBaseHttpNoDelay = "enabled"
)

// Defines values for FrontendBaseHttpRestrictReqHdrNames.
const (
	FrontendBaseHttpRestrictReqHdrNamesDelete   FrontendBaseHttpRestrictReqHdrNames = "delete"
	FrontendBaseHttpRestrictReqHdrNamesPreserve FrontendBaseHttpRestrictReqHdrNames = "preserve"
	FrontendBaseHttpRestrictReqHdrNamesReject   FrontendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendBaseHttpUseProxyHeader.
const (
	FrontendBaseHttpUseProxyHeaderDisabled FrontendBaseHttpUseProxyHeader = "disabled"
	FrontendBaseHttpUseProxyHeaderEnabled  FrontendBaseHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendBaseHttpslog.
const (
	FrontendBaseHttpslogDisabled FrontendBaseHttpslog = "disabled"
	FrontendBaseHttpslogEnabled  FrontendBaseHttpslog = "enabled"
)

// Defines values for FrontendBaseIdleCloseOnResponse.
const (
	FrontendBaseIdleCloseOnResponseDisabled FrontendBaseIdleCloseOnResponse = "disabled"
	FrontendBaseIdleCloseOnResponseEnabled  FrontendBaseIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendBaseIndependentStreams.
const (
	FrontendBaseIndependentStreamsDisabled FrontendBaseIndependentStreams = "disabled"
	FrontendBaseIndependentStreamsEnabled  FrontendBaseIndependentStreams = "enabled"
)

// Defines values for FrontendBaseLogSeparateErrors.
const (
	FrontendBaseLogSeparateErrorsDisabled FrontendBaseLogSeparateErrors = "disabled"
	FrontendBaseLogSeparateErrorsEnabled  FrontendBaseLogSeparateErrors = "enabled"
)

// Defines values for FrontendBaseLogSteps.
const (
	FrontendBaseLogStepsAccept   FrontendBaseLogSteps = "accept"
	FrontendBaseLogStepsAny      FrontendBaseLogSteps = "any"
	FrontendBaseLogStepsClose    FrontendBaseLogSteps = "close"
	FrontendBaseLogStepsConnect  FrontendBaseLogSteps = "connect"
	FrontendBaseLogStepsError    FrontendBaseLogSteps = "error"
	FrontendBaseLogStepsRequest  FrontendBaseLogSteps = "request"
	FrontendBaseLogStepsResponse FrontendBaseLogSteps = "response"
)

// Defines values for FrontendBaseLogasap.
const (
	FrontendBaseLogasapDisabled FrontendBaseLogasap = "disabled"
	FrontendBaseLogasapEnabled  FrontendBaseLogasap = "enabled"
)

// Defines values for FrontendBaseMode.
const (
	FrontendBaseModeHttp FrontendBaseMode = "http"
	FrontendBaseModeTcp  FrontendBaseMode = "tcp"
)

// Defines values for FrontendBaseNolinger.
const (
	FrontendBaseNolingerDisabled FrontendBaseNolinger = "disabled"
	FrontendBaseNolingerEnabled  FrontendBaseNolinger = "enabled"
)

// Defines values for FrontendBaseSocketStats.
const (
	FrontendBaseSocketStatsDisabled FrontendBaseSocketStats = "disabled"
	FrontendBaseSocketStatsEnabled  FrontendBaseSocketStats = "enabled"
)

// Defines values for FrontendBaseSpliceAuto.
const (
	FrontendBaseSpliceAutoDisabled FrontendBaseSpliceAuto = "disabled"
	FrontendBaseSpliceAutoEnabled  FrontendBaseSpliceAuto = "enabled"
)

// Defines values for FrontendBaseSpliceRequest.
const (
	FrontendBaseSpliceRequestDisabled FrontendBaseSpliceRequest = "disabled"
	FrontendBaseSpliceRequestEnabled  FrontendBaseSpliceRequest = "enabled"
)

// Defines values for FrontendBaseSpliceResponse.
const (
	FrontendBaseSpliceResponseDisabled FrontendBaseSpliceResponse = "disabled"
	FrontendBaseSpliceResponseEnabled  FrontendBaseSpliceResponse = "enabled"
)

// Defines values for FrontendBaseTcpSmartAccept.
const (
	FrontendBaseTcpSmartAcceptDisabled FrontendBaseTcpSmartAccept = "disabled"
	FrontendBaseTcpSmartAcceptEnabled  FrontendBaseTcpSmartAccept = "enabled"
)

// Defines values for FrontendBaseTcpka.
const (
	FrontendBaseTcpkaDisabled FrontendBaseTcpka = "disabled"
	FrontendBaseTcpkaEnabled  FrontendBaseTcpka = "enabled"
)

// Defines values for GlobalDefaultPathType.
const (
	GlobalDefaultPathTypeConfig  GlobalDefaultPathType = "config"
	GlobalDefaultPathTypeCurrent GlobalDefaultPathType = "current"
	GlobalDefaultPathTypeOrigin  GlobalDefaultPathType = "origin"
	GlobalDefaultPathTypeParent  GlobalDefaultPathType = "parent"
)

// Defines values for GlobalHardenRejectPrivilegedPortsQuic.
const (
	GlobalHardenRejectPrivilegedPortsQuicDisabled GlobalHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalHardenRejectPrivilegedPortsQuicEnabled  GlobalHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalHardenRejectPrivilegedPortsTcp.
const (
	GlobalHardenRejectPrivilegedPortsTcpDisabled GlobalHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalHardenRejectPrivilegedPortsTcpEnabled  GlobalHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalLogSendHostnameEnabled.
const (
	GlobalLogSendHostnameEnabledDisabled GlobalLogSendHostnameEnabled = "disabled"
	GlobalLogSendHostnameEnabledEnabled  GlobalLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalNumaCpuMapping.
const (
	GlobalNumaCpuMappingDisabled GlobalNumaCpuMapping = "disabled"
	GlobalNumaCpuMappingEnabled  GlobalNumaCpuMapping = "enabled"
)

// Defines values for GlobalRuntimeApisLevel.
const (
	GlobalRuntimeApisLevelAdmin    GlobalRuntimeApisLevel = "admin"
	GlobalRuntimeApisLevelOperator GlobalRuntimeApisLevel = "operator"
	GlobalRuntimeApisLevelUser     GlobalRuntimeApisLevel = "user"
)

// Defines values for GlobalRuntimeApisQuicCcAlgo.
const (
	GlobalRuntimeApisQuicCcAlgoBbr     GlobalRuntimeApisQuicCcAlgo = "bbr"
	GlobalRuntimeApisQuicCcAlgoCubic   GlobalRuntimeApisQuicCcAlgo = "cubic"
	GlobalRuntimeApisQuicCcAlgoNewreno GlobalRuntimeApisQuicCcAlgo = "newreno"
	GlobalRuntimeApisQuicCcAlgoNocc    GlobalRuntimeApisQuicCcAlgo = "nocc"
)

// Defines values for GlobalRuntimeApisQuicSocket.
const (
	GlobalRuntimeApisQuicSocketConnection GlobalRuntimeApisQuicSocket = "connection"
	GlobalRuntimeApisQuicSocketListener   GlobalRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalRuntimeApisSeverityOutput.
const (
	GlobalRuntimeApisSeverityOutputNone   GlobalRuntimeApisSeverityOutput = "none"
	GlobalRuntimeApisSeverityOutputNumber GlobalRuntimeApisSeverityOutput = "number"
	GlobalRuntimeApisSeverityOutputString GlobalRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalRuntimeApisSslMaxVer.
const (
	GlobalRuntimeApisSslMaxVerSSLv3  GlobalRuntimeApisSslMaxVer = "SSLv3"
	GlobalRuntimeApisSslMaxVerTLSv10 GlobalRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalRuntimeApisSslMaxVerTLSv11 GlobalRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalRuntimeApisSslMaxVerTLSv12 GlobalRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalRuntimeApisSslMaxVerTLSv13 GlobalRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisSslMinVer.
const (
	GlobalRuntimeApisSslMinVerSSLv3  GlobalRuntimeApisSslMinVer = "SSLv3"
	GlobalRuntimeApisSslMinVerTLSv10 GlobalRuntimeApisSslMinVer = "TLSv1.0"
	GlobalRuntimeApisSslMinVerTLSv11 GlobalRuntimeApisSslMinVer = "TLSv1.1"
	GlobalRuntimeApisSslMinVerTLSv12 GlobalRuntimeApisSslMinVer = "TLSv1.2"
	GlobalRuntimeApisSslMinVerTLSv13 GlobalRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisSslv3.
const (
	GlobalRuntimeApisSslv3Disabled GlobalRuntimeApisSslv3 = "disabled"
	GlobalRuntimeApisSslv3Enabled  GlobalRuntimeApisSslv3 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv10.
const (
	GlobalRuntimeApisTlsv10Disabled GlobalRuntimeApisTlsv10 = "disabled"
	GlobalRuntimeApisTlsv10Enabled  GlobalRuntimeApisTlsv10 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv11.
const (
	GlobalRuntimeApisTlsv11Disabled GlobalRuntimeApisTlsv11 = "disabled"
	GlobalRuntimeApisTlsv11Enabled  GlobalRuntimeApisTlsv11 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv12.
const (
	GlobalRuntimeApisTlsv12Disabled GlobalRuntimeApisTlsv12 = "disabled"
	GlobalRuntimeApisTlsv12Enabled  GlobalRuntimeApisTlsv12 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv13.
const (
	GlobalRuntimeApisTlsv13Disabled GlobalRuntimeApisTlsv13 = "disabled"
	GlobalRuntimeApisTlsv13Enabled  GlobalRuntimeApisTlsv13 = "enabled"
)

// Defines values for GlobalRuntimeApisVerify.
const (
	GlobalRuntimeApisVerifyNone     GlobalRuntimeApisVerify = "none"
	GlobalRuntimeApisVerifyOptional GlobalRuntimeApisVerify = "optional"
	GlobalRuntimeApisVerifyRequired GlobalRuntimeApisVerify = "required"
)

// Defines values for GlobalBaseDefaultPathType.
const (
	GlobalBaseDefaultPathTypeConfig  GlobalBaseDefaultPathType = "config"
	GlobalBaseDefaultPathTypeCurrent GlobalBaseDefaultPathType = "current"
	GlobalBaseDefaultPathTypeOrigin  GlobalBaseDefaultPathType = "origin"
	GlobalBaseDefaultPathTypeParent  GlobalBaseDefaultPathType = "parent"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsQuic.
const (
	GlobalBaseHardenRejectPrivilegedPortsQuicDisabled GlobalBaseHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsQuicEnabled  GlobalBaseHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsTcp.
const (
	GlobalBaseHardenRejectPrivilegedPortsTcpDisabled GlobalBaseHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsTcpEnabled  GlobalBaseHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalBaseLogSendHostnameEnabled.
const (
	GlobalBaseLogSendHostnameEnabledDisabled GlobalBaseLogSendHostnameEnabled = "disabled"
	GlobalBaseLogSendHostnameEnabledEnabled  GlobalBaseLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalBaseNumaCpuMapping.
const (
	GlobalBaseNumaCpuMappingDisabled GlobalBaseNumaCpuMapping = "disabled"
	GlobalBaseNumaCpuMappingEnabled  GlobalBaseNumaCpuMapping = "enabled"
)

// Defines values for GlobalBaseRuntimeApisLevel.
const (
	GlobalBaseRuntimeApisLevelAdmin    GlobalBaseRuntimeApisLevel = "admin"
	GlobalBaseRuntimeApisLevelOperator GlobalBaseRuntimeApisLevel = "operator"
	GlobalBaseRuntimeApisLevelUser     GlobalBaseRuntimeApisLevel = "user"
)

// Defines values for GlobalBaseRuntimeApisQuicCcAlgo.
const (
	GlobalBaseRuntimeApisQuicCcAlgoBbr     GlobalBaseRuntimeApisQuicCcAlgo = "bbr"
	GlobalBaseRuntimeApisQuicCcAlgoCubic   GlobalBaseRuntimeApisQuicCcAlgo = "cubic"
	GlobalBaseRuntimeApisQuicCcAlgoNewreno GlobalBaseRuntimeApisQuicCcAlgo = "newreno"
	GlobalBaseRuntimeApisQuicCcAlgoNocc    GlobalBaseRuntimeApisQuicCcAlgo = "nocc"
)

// Defines values for GlobalBaseRuntimeApisQuicSocket.
const (
	GlobalBaseRuntimeApisQuicSocketConnection GlobalBaseRuntimeApisQuicSocket = "connection"
	GlobalBaseRuntimeApisQuicSocketListener   GlobalBaseRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalBaseRuntimeApisSeverityOutput.
const (
	GlobalBaseRuntimeApisSeverityOutputNone   GlobalBaseRuntimeApisSeverityOutput = "none"
	GlobalBaseRuntimeApisSeverityOutputNumber GlobalBaseRuntimeApisSeverityOutput = "number"
	GlobalBaseRuntimeApisSeverityOutputString GlobalBaseRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalBaseRuntimeApisSslMaxVer.
const (
	GlobalBaseRuntimeApisSslMaxVerSSLv3  GlobalBaseRuntimeApisSslMaxVer = "SSLv3"
	GlobalBaseRuntimeApisSslMaxVerTLSv10 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMaxVerTLSv11 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMaxVerTLSv12 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMaxVerTLSv13 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisSslMinVer.
const (
	GlobalBaseRuntimeApisSslMinVerSSLv3  GlobalBaseRuntimeApisSslMinVer = "SSLv3"
	GlobalBaseRuntimeApisSslMinVerTLSv10 GlobalBaseRuntimeApisSslMinVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMinVerTLSv11 GlobalBaseRuntimeApisSslMinVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMinVerTLSv12 GlobalBaseRuntimeApisSslMinVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMinVerTLSv13 GlobalBaseRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisSslv3.
const (
	GlobalBaseRuntimeApisSslv3Disabled GlobalBaseRuntimeApisSslv3 = "disabled"
	GlobalBaseRuntimeApisSslv3Enabled  GlobalBaseRuntimeApisSslv3 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv10.
const (
	GlobalBaseRuntimeApisTlsv10Disabled GlobalBaseRuntimeApisTlsv10 = "disabled"
	GlobalBaseRuntimeApisTlsv10Enabled  GlobalBaseRuntimeApisTlsv10 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv11.
const (
	GlobalBaseRuntimeApisTlsv11Disabled GlobalBaseRuntimeApisTlsv11 = "disabled"
	GlobalBaseRuntimeApisTlsv11Enabled  GlobalBaseRuntimeApisTlsv11 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv12.
const (
	GlobalBaseRuntimeApisTlsv12Disabled GlobalBaseRuntimeApisTlsv12 = "disabled"
	GlobalBaseRuntimeApisTlsv12Enabled  GlobalBaseRuntimeApisTlsv12 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv13.
const (
	GlobalBaseRuntimeApisTlsv13Disabled GlobalBaseRuntimeApisTlsv13 = "disabled"
	GlobalBaseRuntimeApisTlsv13Enabled  GlobalBaseRuntimeApisTlsv13 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisVerify.
const (
	GlobalBaseRuntimeApisVerifyNone     GlobalBaseRuntimeApisVerify = "none"
	GlobalBaseRuntimeApisVerifyOptional GlobalBaseRuntimeApisVerify = "optional"
	GlobalBaseRuntimeApisVerifyRequired GlobalBaseRuntimeApisVerify = "required"
)

// Defines values for HashTypeFunction.
const (
	HashTypeFunctionCrc32 HashTypeFunction = "crc32"
	HashTypeFunctionDjb2  HashTypeFunction = "djb2"
	HashTypeFunctionNone  HashTypeFunction = "none"
	HashTypeFunctionSdbm  HashTypeFunction = "sdbm"
	HashTypeFunctionWt6   HashTypeFunction = "wt6"
)

// Defines values for HashTypeMethod.
const (
	HashTypeMethodConsistent HashTypeMethod = "consistent"
	HashTypeMethodMapBased   HashTypeMethod = "map-based"
)

// Defines values for HashTypeModifier.
const (
	HashTypeModifierAvalanche HashTypeModifier = "avalanche"
)

// Defines values for HealthHaproxy.
const (
	HealthHaproxyDown    HealthHaproxy = "down"
	HealthHaproxyUnknown HealthHaproxy = "unknown"
	HealthHaproxyUp      HealthHaproxy = "up"
)

// Defines values for HttpAfterResponseRuleCond.
const (
	HttpAfterResponseRuleCondIf     HttpAfterResponseRuleCond = "if"
	HttpAfterResponseRuleCondUnless HttpAfterResponseRuleCond = "unless"
)

// Defines values for HttpAfterResponseRuleLogLevel.
const (
	HttpAfterResponseRuleLogLevelAlert   HttpAfterResponseRuleLogLevel = "alert"
	HttpAfterResponseRuleLogLevelCrit    HttpAfterResponseRuleLogLevel = "crit"
	HttpAfterResponseRuleLogLevelDebug   HttpAfterResponseRuleLogLevel = "debug"
	HttpAfterResponseRuleLogLevelEmerg   HttpAfterResponseRuleLogLevel = "emerg"
	HttpAfterResponseRuleLogLevelErr     HttpAfterResponseRuleLogLevel = "err"
	HttpAfterResponseRuleLogLevelInfo    HttpAfterResponseRuleLogLevel = "info"
	HttpAfterResponseRuleLogLevelNotice  HttpAfterResponseRuleLogLevel = "notice"
	HttpAfterResponseRuleLogLevelSilent  HttpAfterResponseRuleLogLevel = "silent"
	HttpAfterResponseRuleLogLevelWarning HttpAfterResponseRuleLogLevel = "warning"
)

// Defines values for HttpAfterResponseRuleStrictMode.
const (
	HttpAfterResponseRuleStrictModeOff HttpAfterResponseRuleStrictMode = "off"
	HttpAfterResponseRuleStrictModeOn  HttpAfterResponseRuleStrictMode = "on"
)

// Defines values for HttpAfterResponseRuleType.
const (
	HttpAfterResponseRuleTypeAddHeader     HttpAfterResponseRuleType = "add-header"
	HttpAfterResponseRuleTypeAllow         HttpAfterResponseRuleType = "allow"
	HttpAfterResponseRuleTypeCapture       HttpAfterResponseRuleType = "capture"
	HttpAfterResponseRuleTypeDelAcl        HttpAfterResponseRuleType = "del-acl"
	HttpAfterResponseRuleTypeDelHeader     HttpAfterResponseRuleType = "del-header"
	HttpAfterResponseRuleTypeDelMap        HttpAfterResponseRuleType = "del-map"
	HttpAfterResponseRuleTypeDoLog         HttpAfterResponseRuleType = "do-log"
	HttpAfterResponseRuleTypeReplaceHeader HttpAfterResponseRuleType = "replace-header"
	HttpAfterResponseRuleTypeReplaceValue  HttpAfterResponseRuleType = "replace-value"
	HttpAfterResponseRuleTypeScAddGpc      HttpAfterResponseRuleType = "sc-add-gpc"
	HttpAfterResponseRuleTypeScIncGpc      HttpAfterResponseRuleType = "sc-inc-gpc"
	HttpAfterResponseRuleTypeScIncGpc0     HttpAfterResponseRuleType = "sc-inc-gpc0"
	HttpAfterResponseRuleTypeScIncGpc1     HttpAfterResponseRuleType = "sc-inc-gpc1"
	HttpAfterResponseRuleTypeScSetGpt      HttpAfterResponseRuleType = "sc-set-gpt"
	HttpAfterResponseRuleTypeScSetGpt0     HttpAfterResponseRuleType = "sc-set-gpt0"
	HttpAfterResponseRuleTypeSetHeader     HttpAfterResponseRuleType = "set-header"
	HttpAfterResponseRuleTypeSetLogLevel   HttpAfterResponseRuleType = "set-log-level"
	HttpAfterResponseRuleTypeSetMap        HttpAfterResponseRuleType = "set-map"
	HttpAfterResponseRuleTypeSetStatus     HttpAfterResponseRuleType = "set-status"
	HttpAfterResponseRuleTypeSetVar        HttpAfterResponseRuleType = "set-var"
	HttpAfterResponseRuleTypeSetVarFmt     HttpAfterResponseRuleType = "set-var-fmt"
	HttpAfterResponseRuleTypeStrictMode    HttpAfterResponseRuleType = "strict-mode"
	HttpAfterResponseRuleTypeUnsetVar      HttpAfterResponseRuleType = "unset-var"
)

// Defines values for HttpCheckErrorStatus.
const (
	HttpCheckErrorStatusL4CON HttpCheckErrorStatus = "L4CON"
	HttpCheckErrorStatusL6RSP HttpCheckErrorStatus = "L6RSP"
	HttpCheckErrorStatusL7OKC HttpCheckErrorStatus = "L7OKC"
	HttpCheckErrorStatusL7RSP HttpCheckErrorStatus = "L7RSP"
	HttpCheckErrorStatusL7STS HttpCheckErrorStatus = "L7STS"
)

// Defines values for HttpCheckMatch.
const (
	HttpCheckMatchFhdr    HttpCheckMatch = "fhdr"
	HttpCheckMatchHdr     HttpCheckMatch = "hdr"
	HttpCheckMatchRstatus HttpCheckMatch = "rstatus"
	HttpCheckMatchRstring HttpCheckMatch = "rstring"
	HttpCheckMatchStatus  HttpCheckMatch = "status"
	HttpCheckMatchString  HttpCheckMatch = "string"
)

// Defines values for HttpCheckMethod.
const (
	HttpCheckMethodCONNECT HttpCheckMethod = "CONNECT"
	HttpCheckMethodDELETE  HttpCheckMethod = "DELETE"
	HttpCheckMethodGET     HttpCheckMethod = "GET"
	HttpCheckMethodHEAD    HttpCheckMethod = "HEAD"
	HttpCheckMethodOPTIONS HttpCheckMethod = "OPTIONS"
	HttpCheckMethodPATCH   HttpCheckMethod = "PATCH"
	HttpCheckMethodPOST    HttpCheckMethod = "POST"
	HttpCheckMethodPUT     HttpCheckMethod = "PUT"
	HttpCheckMethodTRACE   HttpCheckMethod = "TRACE"
)

// Defines values for HttpCheckOkStatus.
const (
	HttpCheckOkStatusL4OK  HttpCheckOkStatus = "L4OK"
	HttpCheckOkStatusL6OK  HttpCheckOkStatus = "L6OK"
	HttpCheckOkStatusL7OK  HttpCheckOkStatus = "L7OK"
	HttpCheckOkStatusL7OKC HttpCheckOkStatus = "L7OKC"
)

// Defines values for HttpCheckToutStatus.
const (
	HttpCheckToutStatusL4TOUT HttpCheckToutStatus = "L4TOUT"
	HttpCheckToutStatusL6TOUT HttpCheckToutStatus = "L6TOUT"
	HttpCheckToutStatusL7TOUT HttpCheckToutStatus = "L7TOUT"
)

// Defines values for HttpCheckType.
const (
	HttpCheckTypeComment      HttpCheckType = "comment"
	HttpCheckTypeConnect      HttpCheckType = "connect"
	HttpCheckTypeDisableOn404 HttpCheckType = "disable-on-404"
	HttpCheckTypeExpect       HttpCheckType = "expect"
	HttpCheckTypeSend         HttpCheckType = "send"
	HttpCheckTypeSendState    HttpCheckType = "send-state"
	HttpCheckTypeSetVar       HttpCheckType = "set-var"
	HttpCheckTypeSetVarFmt    HttpCheckType = "set-var-fmt"
	HttpCheckTypeUnsetVar     HttpCheckType = "unset-var"
)

// Defines values for HttpClientOptionsResolversDisabled.
const (
	HttpClientOptionsResolversDisabledDisabled HttpClientOptionsResolversDisabled = "disabled"
	HttpClientOptionsResolversDisabledEnabled  HttpClientOptionsResolversDisabled = "enabled"
)

// Defines values for HttpClientOptionsResolversPrefer.
const (
	HttpClientOptionsResolversPreferIpv4 HttpClientOptionsResolversPrefer = "ipv4"
	HttpClientOptionsResolversPreferIpv6 HttpClientOptionsResolversPrefer = "ipv6"
)

// Defines values for HttpClientOptionsSslVerify.
const (
	HttpClientOptionsSslVerifyEmpty    HttpClientOptionsSslVerify = ""
	HttpClientOptionsSslVerifyNone     HttpClientOptionsSslVerify = "none"
	HttpClientOptionsSslVerifyRequired HttpClientOptionsSslVerify = "required"
)

// Defines values for HttpErrorRuleReturnContentFormat.
const (
	HttpErrorRuleReturnContentFormatDefaultErrorfiles HttpErrorRuleReturnContentFormat = "default-errorfiles"
	HttpErrorRuleReturnContentFormatErrorfile         HttpErrorRuleReturnContentFormat = "errorfile"
	HttpErrorRuleReturnContentFormatErrorfiles        HttpErrorRuleReturnContentFormat = "errorfiles"
	HttpErrorRuleReturnContentFormatFile              HttpErrorRuleReturnContentFormat = "file"
	HttpErrorRuleReturnContentFormatLfFile            HttpErrorRuleReturnContentFormat = "lf-file"
	HttpErrorRuleReturnContentFormatLfString          HttpErrorRuleReturnContentFormat = "lf-string"
	HttpErrorRuleReturnContentFormatString            HttpErrorRuleReturnContentFormat = "string"
)

// Defines values for HttpErrorRuleStatus.
const (
	HttpErrorRuleStatusN200 HttpErrorRuleStatus = 200
	HttpErrorRuleStatusN400 HttpErrorRuleStatus = 400
	HttpErrorRuleStatusN401 HttpErrorRuleStatus = 401
	HttpErrorRuleStatusN403 HttpErrorRuleStatus = 403
	HttpErrorRuleStatusN404 HttpErrorRuleStatus = 404
	HttpErrorRuleStatusN405 HttpErrorRuleStatus = 405
	HttpErrorRuleStatusN407 HttpErrorRuleStatus = 407
	HttpErrorRuleStatusN408 HttpErrorRuleStatus = 408
	HttpErrorRuleStatusN410 HttpErrorRuleStatus = 410
	HttpErrorRuleStatusN413 HttpErrorRuleStatus = 413
	HttpErrorRuleStatusN425 HttpErrorRuleStatus = 425
	HttpErrorRuleStatusN429 HttpErrorRuleStatus = 429
	HttpErrorRuleStatusN500 HttpErrorRuleStatus = 500
	HttpErrorRuleStatusN501 HttpErrorRuleStatus = 501
	HttpErrorRuleStatusN502 HttpErrorRuleStatus = 502
	HttpErrorRuleStatusN503 HttpErrorRuleStatus = 503
	HttpErrorRuleStatusN504 HttpErrorRuleStatus = 504
)

// Defines values for HttpErrorRuleType.
const (
	HttpErrorRuleTypeStatus HttpErrorRuleType = "status"
)

// Defines values for HttpRequestRuleCond.
const (
	HttpRequestRuleCondIf     HttpRequestRuleCond = "if"
	HttpRequestRuleCondUnless HttpRequestRuleCond = "unless"
)

// Defines values for HttpRequestRuleLogLevel.
const (
	HttpRequestRuleLogLevelAlert   HttpRequestRuleLogLevel = "alert"
	HttpRequestRuleLogLevelCrit    HttpRequestRuleLogLevel = "crit"
	HttpRequestRuleLogLevelDebug   HttpRequestRuleLogLevel = "debug"
	HttpRequestRuleLogLevelEmerg   HttpRequestRuleLogLevel = "emerg"
	HttpRequestRuleLogLevelErr     HttpRequestRuleLogLevel = "err"
	HttpRequestRuleLogLevelInfo    HttpRequestRuleLogLevel = "info"
	HttpRequestRuleLogLevelNotice  HttpRequestRuleLogLevel = "notice"
	HttpRequestRuleLogLevelSilent  HttpRequestRuleLogLevel = "silent"
	HttpRequestRuleLogLevelWarning HttpRequestRuleLogLevel = "warning"
)

// Defines values for HttpRequestRuleNormalizer.
const (
	HttpRequestRuleNormalizerFragmentEncode          HttpRequestRuleNormalizer = "fragment-encode"
	HttpRequestRuleNormalizerFragmentStrip           HttpRequestRuleNormalizer = "fragment-strip"
	HttpRequestRuleNormalizerPathMergeSlashes        HttpRequestRuleNormalizer = "path-merge-slashes"
	HttpRequestRuleNormalizerPathStripDot            HttpRequestRuleNormalizer = "path-strip-dot"
	HttpRequestRuleNormalizerPathStripDotdot         HttpRequestRuleNormalizer = "path-strip-dotdot"
	HttpRequestRuleNormalizerPercentDecodeUnreserved HttpRequestRuleNormalizer = "percent-decode-unreserved"
	HttpRequestRuleNormalizerPercentToUppercase      HttpRequestRuleNormalizer = "percent-to-uppercase"
	HttpRequestRuleNormalizerQuerySortByName         HttpRequestRuleNormalizer = "query-sort-by-name"
)

// Defines values for HttpRequestRuleProtocol.
const (
	HttpRequestRuleProtocolIpv4 HttpRequestRuleProtocol = "ipv4"
	HttpRequestRuleProtocolIpv6 HttpRequestRuleProtocol = "ipv6"
)

// Defines values for HttpRequestRuleRedirCode.
const (
	HttpRequestRuleRedirCodeN301 HttpRequestRuleRedirCode = 301
	HttpRequestRuleRedirCodeN302 HttpRequestRuleRedirCode = 302
	HttpRequestRuleRedirCodeN303 HttpRequestRuleRedirCode = 303
	HttpRequestRuleRedirCodeN307 HttpRequestRuleRedirCode = 307
	HttpRequestRuleRedirCodeN308 HttpRequestRuleRedirCode = 308
)

// Defines values for HttpRequestRuleRedirType.
const (
	HttpRequestRuleRedirTypeLocation HttpRequestRuleRedirType = "location"
	HttpRequestRuleRedirTypePrefix   HttpRequestRuleRedirType = "prefix"
	HttpRequestRuleRedirTypeScheme   HttpRequestRuleRedirType = "scheme"
)

// Defines values for HttpRequestRuleReturnContentFormat.
const (
	HttpRequestRuleReturnContentFormatDefaultErrorfiles HttpRequestRuleReturnContentFormat = "default-errorfiles"
	HttpRequestRuleReturnContentFormatErrorfile         HttpRequestRuleReturnContentFormat = "errorfile"
	HttpRequestRuleReturnContentFormatErrorfiles        HttpRequestRuleReturnContentFormat = "errorfiles"
	HttpRequestRuleReturnContentFormatFile              HttpRequestRuleReturnContentFormat = "file"
	HttpRequestRuleReturnContentFormatLfFile            HttpRequestRuleReturnContentFormat = "lf-file"
	HttpRequestRuleReturnContentFormatLfString          HttpRequestRuleReturnContentFormat = "lf-string"
	HttpRequestRuleReturnContentFormatString            HttpRequestRuleReturnContentFormat = "string"
)

// Defines values for HttpRequestRuleStrictMode.
const (
	HttpRequestRuleStrictModeOff HttpRequestRuleStrictMode = "off"
	HttpRequestRuleStrictModeOn  HttpRequestRuleStrictMode = "on"
)

// Defines values for HttpRequestRuleTimeoutType.
const (
	HttpRequestRuleTimeoutTypeClient HttpRequestRuleTimeoutType = "client"
	HttpRequestRuleTimeoutTypeServer HttpRequestRuleTimeoutType = "server"
	HttpRequestRuleTimeoutTypeTunnel HttpRequestRuleTimeoutType = "tunnel"
)

// Defines values for HttpRequestRuleType.
const (
	HttpRequestRuleTypeAddAcl            HttpRequestRuleType = "add-acl"
	HttpRequestRuleTypeAddHeader         HttpRequestRuleType = "add-header"
	HttpRequestRuleTypeAllow             HttpRequestRuleType = "allow"
	HttpRequestRuleTypeAuth              HttpRequestRuleType = "auth"
	HttpRequestRuleTypeCacheUse          HttpRequestRuleType = "cache-use"
	HttpRequestRuleTypeCapture           HttpRequestRuleType = "capture"
	HttpRequestRuleTypeDelAcl            HttpRequestRuleType = "del-acl"
	HttpRequestRuleTypeDelHeader         HttpRequestRuleType = "del-header"
	HttpRequestRuleTypeDelMap            HttpRequestRuleType = "del-map"
	HttpRequestRuleTypeDeny              HttpRequestRuleType = "deny"
	HttpRequestRuleTypeDisableL7Retry    HttpRequestRuleType = "disable-l7-retry"
	HttpRequestRuleTypeDoLog             HttpRequestRuleType = "do-log"
	HttpRequestRuleTypeDoResolve         HttpRequestRuleType = "do-resolve"
	HttpRequestRuleTypeEarlyHint         HttpRequestRuleType = "early-hint"
	HttpRequestRuleTypeLua               HttpRequestRuleType = "lua"
	HttpRequestRuleTypeNormalizeUri      HttpRequestRuleType = "normalize-uri"
	HttpRequestRuleTypeRedirect          HttpRequestRuleType = "redirect"
	HttpRequestRuleTypeReject            HttpRequestRuleType = "reject"
	HttpRequestRuleTypeReplaceHeader     HttpRequestRuleType = "replace-header"
	HttpRequestRuleTypeReplacePath       HttpRequestRuleType = "replace-path"
	HttpRequestRuleTypeReplacePathq      HttpRequestRuleType = "replace-pathq"
	HttpRequestRuleTypeReplaceUri        HttpRequestRuleType = "replace-uri"
	HttpRequestRuleTypeReplaceValue      HttpRequestRuleType = "replace-value"
	HttpRequestRuleTypeReturn            HttpRequestRuleType = "return"
	HttpRequestRuleTypeScAddGpc          HttpRequestRuleType = "sc-add-gpc"
	HttpRequestRuleTypeScIncGpc          HttpRequestRuleType = "sc-inc-gpc"
	HttpRequestRuleTypeScIncGpc0         HttpRequestRuleType = "sc-inc-gpc0"
	HttpRequestRuleTypeScIncGpc1         HttpRequestRuleType = "sc-inc-gpc1"
	HttpRequestRuleTypeScSetGpt          HttpRequestRuleType = "sc-set-gpt"
	HttpRequestRuleTypeScSetGpt0         HttpRequestRuleType = "sc-set-gpt0"
	HttpRequestRuleTypeSendSpoeGroup     HttpRequestRuleType = "send-spoe-group"
	HttpRequestRuleTypeSetBandwidthLimit HttpRequestRuleType = "set-bandwidth-limit"
	HttpRequestRuleTypeSetBcMark         HttpRequestRuleType = "set-bc-mark"
	HttpRequestRuleTypeSetBcTos          HttpRequestRuleType = "set-bc-tos"
	HttpRequestRuleTypeSetDst            HttpRequestRuleType = "set-dst"
	HttpRequestRuleTypeSetDstPort        HttpRequestRuleType = "set-dst-port"
	HttpRequestRuleTypeSetFcMark         HttpRequestRuleType = "set-fc-mark"
	HttpRequestRuleTypeSetFcTos          HttpRequestRuleType = "set-fc-tos"
	HttpRequestRuleTypeSetHeader         HttpRequestRuleType = "set-header"
	HttpRequestRuleTypeSetLogLevel       HttpRequestRuleType = "set-log-level"
	HttpRequestRuleTypeSetMap            HttpRequestRuleType = "set-map"
	HttpRequestRuleTypeSetMark           HttpRequestRuleType = "set-mark"
	HttpRequestRuleTypeSetMethod         HttpRequestRuleType = "set-method"
	HttpRequestRuleTypeSetNice           HttpRequestRuleType = "set-nice"
	HttpRequestRuleTypeSetPath           HttpRequestRuleType = "set-path"
	HttpRequestRuleTypeSetPathq          HttpRequestRuleType = "set-pathq"
	HttpRequestRuleTypeSetPriorityClass  HttpRequestRuleType = "set-priority-class"
	HttpRequestRuleTypeSetPriorityOffset HttpRequestRuleType = "set-priority-offset"
	HttpRequestRuleTypeSetQuery          HttpRequestRuleType = "set-query"
	HttpRequestRuleTypeSetRetries        HttpRequestRuleType = "set-retries"
	HttpRequestRuleTypeSetSrc            HttpRequestRuleType = "set-src"
	HttpRequestRuleTypeSetSrcPort        HttpRequestRuleType = "set-src-port"
	HttpRequestRuleTypeSetTimeout        HttpRequestRuleType = "set-timeout"
	HttpRequestRuleTypeSetTos            HttpRequestRuleType = "set-tos"
	HttpRequestRuleTypeSetUri            HttpRequestRuleType = "set-uri"
	HttpRequestRuleTypeSetVar            HttpRequestRuleType = "set-var"
	HttpRequestRuleTypeSetVarFmt         HttpRequestRuleType = "set-var-fmt"
	HttpRequestRuleTypeSilentDrop        HttpRequestRuleType = "silent-drop"
	HttpRequestRuleTypeStrictMode        HttpRequestRuleType = "strict-mode"
	HttpRequestRuleTypeTarpit            HttpRequestRuleType = "tarpit"
	HttpRequestRuleTypeTrackSc           HttpRequestRuleType = "track-sc"
	HttpRequestRuleTypeUnsetVar          HttpRequestRuleType = "unset-var"
	HttpRequestRuleTypeUseService        HttpRequestRuleType = "use-service"
	HttpRequestRuleTypeWaitForBody       HttpRequestRuleType = "wait-for-body"
	HttpRequestRuleTypeWaitForHandshake  HttpRequestRuleType = "wait-for-handshake"
)

// Defines values for HttpResponseRuleCond.
const (
	HttpResponseRuleCondIf     HttpResponseRuleCond = "if"
	HttpResponseRuleCondUnless HttpResponseRuleCond = "unless"
)

// Defines values for HttpResponseRuleLogLevel.
const (
	HttpResponseRuleLogLevelAlert   HttpResponseRuleLogLevel = "alert"
	HttpResponseRuleLogLevelCrit    HttpResponseRuleLogLevel = "crit"
	HttpResponseRuleLogLevelDebug   HttpResponseRuleLogLevel = "debug"
	HttpResponseRuleLogLevelEmerg   HttpResponseRuleLogLevel = "emerg"
	HttpResponseRuleLogLevelErr     HttpResponseRuleLogLevel = "err"
	HttpResponseRuleLogLevelInfo    HttpResponseRuleLogLevel = "info"
	HttpResponseRuleLogLevelNotice  HttpResponseRuleLogLevel = "notice"
	HttpResponseRuleLogLevelSilent  HttpResponseRuleLogLevel = "silent"
	HttpResponseRuleLogLevelWarning HttpResponseRuleLogLevel = "warning"
)

// Defines values for HttpResponseRuleRedirCode.
const (
	HttpResponseRuleRedirCodeN301 HttpResponseRuleRedirCode = 301
	HttpResponseRuleRedirCodeN302 HttpResponseRuleRedirCode = 302
	HttpResponseRuleRedirCodeN303 HttpResponseRuleRedirCode = 303
	HttpResponseRuleRedirCodeN307 HttpResponseRuleRedirCode = 307
	HttpResponseRuleRedirCodeN308 HttpResponseRuleRedirCode = 308
)

// Defines values for HttpResponseRuleRedirType.
const (
	HttpResponseRuleRedirTypeLocation HttpResponseRuleRedirType = "location"
	HttpResponseRuleRedirTypePrefix   HttpResponseRuleRedirType = "prefix"
	HttpResponseRuleRedirTypeScheme   HttpResponseRuleRedirType = "scheme"
)

// Defines values for HttpResponseRuleReturnContentFormat.
const (
	HttpResponseRuleReturnContentFormatDefaultErrorfiles HttpResponseRuleReturnContentFormat = "default-errorfiles"
	HttpResponseRuleReturnContentFormatErrorfile         HttpResponseRuleReturnContentFormat = "errorfile"
	HttpResponseRuleReturnContentFormatErrorfiles        HttpResponseRuleReturnContentFormat = "errorfiles"
	HttpResponseRuleReturnContentFormatFile              HttpResponseRuleReturnContentFormat = "file"
	HttpResponseRuleReturnContentFormatLfFile            HttpResponseRuleReturnContentFormat = "lf-file"
	HttpResponseRuleReturnContentFormatLfString          HttpResponseRuleReturnContentFormat = "lf-string"
	HttpResponseRuleReturnContentFormatString            HttpResponseRuleReturnContentFormat = "string"
)

// Defines values for HttpResponseRuleStrictMode.
const (
	HttpResponseRuleStrictModeOff HttpResponseRuleStrictMode = "off"
	HttpResponseRuleStrictModeOn  HttpResponseRuleStrictMode = "on"
)

// Defines values for HttpResponseRuleTimeoutType.
const (
	HttpResponseRuleTimeoutTypeClient HttpResponseRuleTimeoutType = "client"
	HttpResponseRuleTimeoutTypeServer HttpResponseRuleTimeoutType = "server"
	HttpResponseRuleTimeoutTypeTunnel HttpResponseRuleTimeoutType = "tunnel"
)

// Defines values for HttpResponseRuleType.
const (
	HttpResponseRuleTypeAddAcl            HttpResponseRuleType = "add-acl"
	HttpResponseRuleTypeAddHeader         HttpResponseRuleType = "add-header"
	HttpResponseRuleTypeAllow             HttpResponseRuleType = "allow"
	HttpResponseRuleTypeCacheStore        HttpResponseRuleType = "cache-store"
	HttpResponseRuleTypeCapture           HttpResponseRuleType = "capture"
	HttpResponseRuleTypeDelAcl            HttpResponseRuleType = "del-acl"
	HttpResponseRuleTypeDelHeader         HttpResponseRuleType = "del-header"
	HttpResponseRuleTypeDelMap            HttpResponseRuleType = "del-map"
	HttpResponseRuleTypeDeny              HttpResponseRuleType = "deny"
	HttpResponseRuleTypeDoLog             HttpResponseRuleType = "do-log"
	HttpResponseRuleTypeLua               HttpResponseRuleType = "lua"
	HttpResponseRuleTypeRedirect          HttpResponseRuleType = "redirect"
	HttpResponseRuleTypeReplaceHeader     HttpResponseRuleType = "replace-header"
	HttpResponseRuleTypeReplaceValue      HttpResponseRuleType = "replace-value"
	HttpResponseRuleTypeReturn            HttpResponseRuleType = "return"
	HttpResponseRuleTypeScAddGpc          HttpResponseRuleType = "sc-add-gpc"
	HttpResponseRuleTypeScIncGpc          HttpResponseRuleType = "sc-inc-gpc"
	HttpResponseRuleTypeScIncGpc0         HttpResponseRuleType = "sc-inc-gpc0"
	HttpResponseRuleTypeScIncGpc1         HttpResponseRuleType = "sc-inc-gpc1"
	HttpResponseRuleTypeScSetGpt          HttpResponseRuleType = "sc-set-gpt"
	HttpResponseRuleTypeScSetGpt0         HttpResponseRuleType = "sc-set-gpt0"
	HttpResponseRuleTypeSendSpoeGroup     HttpResponseRuleType = "send-spoe-group"
	HttpResponseRuleTypeSetBandwidthLimit HttpResponseRuleType = "set-bandwidth-limit"
	HttpResponseRuleTypeSetFcMark         HttpResponseRuleType = "set-fc-mark"
	HttpResponseRuleTypeSetFcTos          HttpResponseRuleType = "set-fc-tos"
	HttpResponseRuleTypeSetHeader         HttpResponseRuleType = "set-header"
	HttpResponseRuleTypeSetLogLevel       HttpResponseRuleType = "set-log-level"
	HttpResponseRuleTypeSetMap            HttpResponseRuleType = "set-map"
	HttpResponseRuleTypeSetMark           HttpResponseRuleType = "set-mark"
	HttpResponseRuleTypeSetNice           HttpResponseRuleType = "set-nice"
	HttpResponseRuleTypeSetStatus         HttpResponseRuleType = "set-status"
	HttpResponseRuleTypeSetTimeout        HttpResponseRuleType = "set-timeout"
	HttpResponseRuleTypeSetTos            HttpResponseRuleType = "set-tos"
	HttpResponseRuleTypeSetVar            HttpResponseRuleType = "set-var"
	HttpResponseRuleTypeSetVarFmt         HttpResponseRuleType = "set-var-fmt"
	HttpResponseRuleTypeSilentDrop        HttpResponseRuleType = "silent-drop"
	HttpResponseRuleTypeStrictMode        HttpResponseRuleType = "strict-mode"
	HttpResponseRuleTypeTrackSc           HttpResponseRuleType = "track-sc"
	HttpResponseRuleTypeUnsetVar          HttpResponseRuleType = "unset-var"
	HttpResponseRuleTypeWaitForBody       HttpResponseRuleType = "wait-for-body"
)

// Defines values for HttpchkParamsMethod.
const (
	HttpchkParamsMethodCONNECT HttpchkParamsMethod = "CONNECT"
	HttpchkParamsMethodDELETE  HttpchkParamsMethod = "DELETE"
	HttpchkParamsMethodGET     HttpchkParamsMethod = "GET"
	HttpchkParamsMethodHEAD    HttpchkParamsMethod = "HEAD"
	HttpchkParamsMethodOPTIONS HttpchkParamsMethod = "OPTIONS"
	HttpchkParamsMethodPATCH   HttpchkParamsMethod = "PATCH"
	HttpchkParamsMethodPOST    HttpchkParamsMethod = "POST"
	HttpchkParamsMethodPUT     HttpchkParamsMethod = "PUT"
	HttpchkParamsMethodTRACE   HttpchkParamsMethod = "TRACE"
)

// Defines values for LogProfileStepDrop.
const (
	LogProfileStepDropDisabled LogProfileStepDrop = "disabled"
	LogProfileStepDropEnabled  LogProfileStepDrop = "enabled"
)

// Defines values for LogProfileStepStep.
const (
	LogProfileStepStepAccept       LogProfileStepStep = "accept"
	LogProfileStepStepAny          LogProfileStepStep = "any"
	LogProfileStepStepClose        LogProfileStepStep = "close"
	LogProfileStepStepConnect      LogProfileStepStep = "connect"
	LogProfileStepStepError        LogProfileStepStep = "error"
	LogProfileStepStepHttpAfterRes LogProfileStepStep = "http-after-res"
	LogProfileStepStepHttpReq      LogProfileStepStep = "http-req"
	LogProfileStepStepHttpRes      LogProfileStepStep = "http-res"
	LogProfileStepStepQuicInit     LogProfileStepStep = "quic-init"
	LogProfileStepStepRequest      LogProfileStepStep = "request"
	LogProfileStepStepResponse     LogProfileStepStep = "response"
	LogProfileStepStepTcpReqConn   LogProfileStepStep = "tcp-req-conn"
	LogProfileStepStepTcpReqCont   LogProfileStepStep = "tcp-req-cont"
	LogProfileStepStepTcpReqSess   LogProfileStepStep = "tcp-req-sess"
)

// Defines values for LogTargetFacility.
const (
	LogTargetFacilityAlert  LogTargetFacility = "alert"
	LogTargetFacilityAudit  LogTargetFacility = "audit"
	LogTargetFacilityAuth   LogTargetFacility = "auth"
	LogTargetFacilityAuth2  LogTargetFacility = "auth2"
	LogTargetFacilityCron   LogTargetFacility = "cron"
	LogTargetFacilityCron2  LogTargetFacility = "cron2"
	LogTargetFacilityDaemon LogTargetFacility = "daemon"
	LogTargetFacilityFtp    LogTargetFacility = "ftp"
	LogTargetFacilityKern   LogTargetFacility = "kern"
	LogTargetFacilityLocal0 LogTargetFacility = "local0"
	LogTargetFacilityLocal1 LogTargetFacility = "local1"
	LogTargetFacilityLocal2 LogTargetFacility = "local2"
	LogTargetFacilityLocal3 LogTargetFacility = "local3"
	LogTargetFacilityLocal4 LogTargetFacility = "local4"
	LogTargetFacilityLocal5 LogTargetFacility = "local5"
	LogTargetFacilityLocal6 LogTargetFacility = "local6"
	LogTargetFacilityLocal7 LogTargetFacility = "local7"
	LogTargetFacilityLpr    LogTargetFacility = "lpr"
	LogTargetFacilityMail   LogTargetFacility = "mail"
	LogTargetFacilityNews   LogTargetFacility = "news"
	LogTargetFacilityNtp    LogTargetFacility = "ntp"
	LogTargetFacilitySyslog LogTargetFacility = "syslog"
	LogTargetFacilityUser   LogTargetFacility = "user"
	LogTargetFacilityUucp   LogTargetFacility = "uucp"
)

// Defines values for LogTargetFormat.
const (
	LogTargetFormatIso      LogTargetFormat = "iso"
	LogTargetFormatLocal    LogTargetFormat = "local"
	LogTargetFormatPriority LogTargetFormat = "priority"
	LogTargetFormatRaw      LogTargetFormat = "raw"
	LogTargetFormatRfc3164  LogTargetFormat = "rfc3164"
	LogTargetFormatRfc5424  LogTargetFormat = "rfc5424"
	LogTargetFormatShort    LogTargetFormat = "short"
	LogTargetFormatTimed    LogTargetFormat = "timed"
)

// Defines values for LogTargetLevel.
const (
	LogTargetLevelAlert   LogTargetLevel = "alert"
	LogTargetLevelCrit    LogTargetLevel = "crit"
	LogTargetLevelDebug   LogTargetLevel = "debug"
	LogTargetLevelEmerg   LogTargetLevel = "emerg"
	LogTargetLevelErr     LogTargetLevel = "err"
	LogTargetLevelInfo    LogTargetLevel = "info"
	LogTargetLevelNotice  LogTargetLevel = "notice"
	LogTargetLevelWarning LogTargetLevel = "warning"
)

// Defines values for LogTargetMinlevel.
const (
	LogTargetMinlevelAlert   LogTargetMinlevel = "alert"
	LogTargetMinlevelCrit    LogTargetMinlevel = "crit"
	LogTargetMinlevelDebug   LogTargetMinlevel = "debug"
	LogTargetMinlevelEmerg   LogTargetMinlevel = "emerg"
	LogTargetMinlevelErr     LogTargetMinlevel = "err"
	LogTargetMinlevelInfo    LogTargetMinlevel = "info"
	LogTargetMinlevelNotice  LogTargetMinlevel = "notice"
	LogTargetMinlevelWarning LogTargetMinlevel = "warning"
)

// Defines values for LuaOptionsPrependPathType.
const (
	LuaOptionsPrependPathTypeCpath LuaOptionsPrependPathType = "cpath"
	LuaOptionsPrependPathTypePath  LuaOptionsPrependPathType = "path"
)

// Defines values for MonitorFailCond.
const (
	MonitorFailCondIf     MonitorFailCond = "if"
	MonitorFailCondUnless MonitorFailCond = "unless"
)

// Defines values for MysqlCheckParamsClientVersion.
const (
	MysqlCheckParamsClientVersionPost41 MysqlCheckParamsClientVersion = "post-41"
	MysqlCheckParamsClientVersionPre41  MysqlCheckParamsClientVersion = "pre-41"
)

// Defines values for NativeStatType.
const (
	NativeStatTypeBackend  NativeStatType = "backend"
	NativeStatTypeFrontend NativeStatType = "frontend"
	NativeStatTypeServer   NativeStatType = "server"
)

// Defines values for NativeStatStatsAgentStatus.
const (
	NativeStatStatsAgentStatusINI     NativeStatStatsAgentStatus = "INI"
	NativeStatStatsAgentStatusL4CON   NativeStatStatsAgentStatus = "L4CON"
	NativeStatStatsAgentStatusL4OK    NativeStatStatsAgentStatus = "L4OK"
	NativeStatStatsAgentStatusL4TOUT  NativeStatStatsAgentStatus = "L4TOUT"
	NativeStatStatsAgentStatusL7OK    NativeStatStatsAgentStatus = "L7OK"
	NativeStatStatsAgentStatusL7STS   NativeStatStatsAgentStatus = "L7STS"
	NativeStatStatsAgentStatusSOCKERR NativeStatStatsAgentStatus = "SOCKERR"
	NativeStatStatsAgentStatusUNK     NativeStatStatsAgentStatus = "UNK"
)

// Defines values for NativeStatStatsCheckStatus.
const (
	NativeStatStatsCheckStatusINI     NativeStatStatsCheckStatus = "INI"
	NativeStatStatsCheckStatusL4CON   NativeStatStatsCheckStatus = "L4CON"
	NativeStatStatsCheckStatusL4OK    NativeStatStatsCheckStatus = "L4OK"
	NativeStatStatsCheckStatusL4TOUT  NativeStatStatsCheckStatus = "L4TOUT"
	NativeStatStatsCheckStatusL6OK    NativeStatStatsCheckStatus = "L6OK"
	NativeStatStatsCheckStatusL6RSP   NativeStatStatsCheckStatus = "L6RSP"
	NativeStatStatsCheckStatusL6TOUT  NativeStatStatsCheckStatus = "L6TOUT"
	NativeStatStatsCheckStatusL7OK    NativeStatStatsCheckStatus = "L7OK"
	NativeStatStatsCheckStatusL7OKC   NativeStatStatsCheckStatus = "L7OKC"
	NativeStatStatsCheckStatusL7RSP   NativeStatStatsCheckStatus = "L7RSP"
	NativeStatStatsCheckStatusL7STS   NativeStatStatsCheckStatus = "L7STS"
	NativeStatStatsCheckStatusL7TOUT  NativeStatStatsCheckStatus = "L7TOUT"
	NativeStatStatsCheckStatusSOCKERR NativeStatStatsCheckStatus = "SOCKERR"
	NativeStatStatsCheckStatusUNK     NativeStatStatsCheckStatus = "UNK"
)

// Defines values for NativeStatStatsMode.
const (
	NativeStatStatsModeHealth  NativeStatStatsMode = "health"
	NativeStatStatsModeHttp    NativeStatStatsMode = "http"
	NativeStatStatsModeTcp     NativeStatStatsMode = "tcp"
	NativeStatStatsModeUnknown NativeStatStatsMode = "unknown"
)

// Defines values for NativeStatStatsStatus.
const (
	NativeStatStatsStatusDOWN    NativeStatStatsStatus = "DOWN"
	NativeStatStatsStatusMAINT   NativeStatStatsStatus = "MAINT"
	NativeStatStatsStatusNOLB    NativeStatStatsStatus = "NOLB"
	NativeStatStatsStatusNoCheck NativeStatStatsStatus = "no check"
	NativeStatStatsStatusUP      NativeStatStatsStatus = "UP"
)

// Defines values for OcspUpdateOptionsMode.
const (
	OcspUpdateOptionsModeDisabled OcspUpdateOptionsMode = "disabled"
	OcspUpdateOptionsModeEnabled  OcspUpdateOptionsMode = "enabled"
)

// Defines values for OriginaltoEnabled.
const (
	OriginaltoEnabledEnabled OriginaltoEnabled = "enabled"
)

// Defines values for PerformanceOptionsProfilingMemory.
const (
	PerformanceOptionsProfilingMemoryDisabled PerformanceOptionsProfilingMemory = "disabled"
	PerformanceOptionsProfilingMemoryEnabled  PerformanceOptionsProfilingMemory = "enabled"
)

// Defines values for PerformanceOptionsProfilingTasks.
const (
	PerformanceOptionsProfilingTasksAuto     PerformanceOptionsProfilingTasks = "auto"
	PerformanceOptionsProfilingTasksDisabled PerformanceOptionsProfilingTasks = "disabled"
	PerformanceOptionsProfilingTasksEnabled  PerformanceOptionsProfilingTasks = "enabled"
)

// Defines values for PersistRuleType.
const (
	PersistRuleTypeRdpCookie PersistRuleType = "rdp-cookie"
)

// Defines values for ProgramStartOnReload.
const (
	ProgramStartOnReloadDisabled ProgramStartOnReload = "disabled"
	ProgramStartOnReloadEnabled  ProgramStartOnReload = "enabled"
)

// Defines values for QuicInitialRuleCond.
const (
	QuicInitialRuleCondIf     QuicInitialRuleCond = "if"
	QuicInitialRuleCondUnless QuicInitialRuleCond = "unless"
)

// Defines values for QuicInitialRuleType.
const (
	QuicInitialRuleTypeAccept    QuicInitialRuleType = "accept"
	QuicInitialRuleTypeDgramDrop QuicInitialRuleType = "dgram-drop"
	QuicInitialRuleTypeReject    QuicInitialRuleType = "reject"
	QuicInitialRuleTypeSendRetry QuicInitialRuleType = "send-retry"
)

// Defines values for RedispatchEnabled.
const (
	RedispatchEnabledDisabled RedispatchEnabled = "disabled"
	RedispatchEnabledEnabled  RedispatchEnabled = "enabled"
)

// Defines values for ReloadStatus.
const (
	ReloadStatusFailed     ReloadStatus = "failed"
	ReloadStatusInProgress ReloadStatus = "in_progress"
	ReloadStatusSucceeded  ReloadStatus = "succeeded"
)

// Defines values for RingFormat.
const (
	RingFormatIso      RingFormat = "iso"
	RingFormatLocal    RingFormat = "local"
	RingFormatPriority RingFormat = "priority"
	RingFormatRaw      RingFormat = "raw"
	RingFormatRfc3164  RingFormat = "rfc3164"
	RingFormatRfc5424  RingFormat = "rfc5424"
	RingFormatShort    RingFormat = "short"
	RingFormatTimed    RingFormat = "timed"
)

// Defines values for RingBaseFormat.
const (
	RingBaseFormatIso      RingBaseFormat = "iso"
	RingBaseFormatLocal    RingBaseFormat = "local"
	RingBaseFormatPriority RingBaseFormat = "priority"
	RingBaseFormatRaw      RingBaseFormat = "raw"
	RingBaseFormatRfc3164  RingBaseFormat = "rfc3164"
	RingBaseFormatRfc5424  RingBaseFormat = "rfc5424"
	RingBaseFormatShort    RingBaseFormat = "short"
	RingBaseFormatTimed    RingBaseFormat = "timed"
)

// Defines values for RuntimeAddServerAgentCheck.
const (
	RuntimeAddServerAgentCheckDisabled RuntimeAddServerAgentCheck = "disabled"
	RuntimeAddServerAgentCheckEnabled  RuntimeAddServerAgentCheck = "enabled"
)

// Defines values for RuntimeAddServerBackup.
const (
	RuntimeAddServerBackupDisabled RuntimeAddServerBackup = "disabled"
	RuntimeAddServerBackupEnabled  RuntimeAddServerBackup = "enabled"
)

// Defines values for RuntimeAddServerCheck.
const (
	RuntimeAddServerCheckDisabled RuntimeAddServerCheck = "disabled"
	RuntimeAddServerCheckEnabled  RuntimeAddServerCheck = "enabled"
)

// Defines values for RuntimeAddServerCheckSendProxy.
const (
	RuntimeAddServerCheckSendProxyDisabled RuntimeAddServerCheckSendProxy = "disabled"
	RuntimeAddServerCheckSendProxyEnabled  RuntimeAddServerCheckSendProxy = "enabled"
)

// Defines values for RuntimeAddServerCheckSsl.
const (
	RuntimeAddServerCheckSslDisabled RuntimeAddServerCheckSsl = "disabled"
	RuntimeAddServerCheckSslEnabled  RuntimeAddServerCheckSsl = "enabled"
)

// Defines values for RuntimeAddServerCheckViaSocks4.
const (
	RuntimeAddServerCheckViaSocks4Disabled RuntimeAddServerCheckViaSocks4 = "disabled"
	RuntimeAddServerCheckViaSocks4Enabled  RuntimeAddServerCheckViaSocks4 = "enabled"
)

// Defines values for RuntimeAddServerForceSslv3.
const (
	RuntimeAddServerForceSslv3Disabled RuntimeAddServerForceSslv3 = "disabled"
	RuntimeAddServerForceSslv3Enabled  RuntimeAddServerForceSslv3 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv10.
const (
	RuntimeAddServerForceTlsv10Disabled RuntimeAddServerForceTlsv10 = "disabled"
	RuntimeAddServerForceTlsv10Enabled  RuntimeAddServerForceTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv11.
const (
	RuntimeAddServerForceTlsv11Disabled RuntimeAddServerForceTlsv11 = "disabled"
	RuntimeAddServerForceTlsv11Enabled  RuntimeAddServerForceTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv12.
const (
	RuntimeAddServerForceTlsv12Disabled RuntimeAddServerForceTlsv12 = "disabled"
	RuntimeAddServerForceTlsv12Enabled  RuntimeAddServerForceTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv13.
const (
	RuntimeAddServerForceTlsv13Disabled RuntimeAddServerForceTlsv13 = "disabled"
	RuntimeAddServerForceTlsv13Enabled  RuntimeAddServerForceTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerMaintenance.
const (
	RuntimeAddServerMaintenanceDisabled RuntimeAddServerMaintenance = "disabled"
	RuntimeAddServerMaintenanceEnabled  RuntimeAddServerMaintenance = "enabled"
)

// Defines values for RuntimeAddServerNoSslv3.
const (
	RuntimeAddServerNoSslv3Disabled RuntimeAddServerNoSslv3 = "disabled"
	RuntimeAddServerNoSslv3Enabled  RuntimeAddServerNoSslv3 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv10.
const (
	RuntimeAddServerNoTlsv10Disabled RuntimeAddServerNoTlsv10 = "disabled"
	RuntimeAddServerNoTlsv10Enabled  RuntimeAddServerNoTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv11.
const (
	RuntimeAddServerNoTlsv11Disabled RuntimeAddServerNoTlsv11 = "disabled"
	RuntimeAddServerNoTlsv11Enabled  RuntimeAddServerNoTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv12.
const (
	RuntimeAddServerNoTlsv12Disabled RuntimeAddServerNoTlsv12 = "disabled"
	RuntimeAddServerNoTlsv12Enabled  RuntimeAddServerNoTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv13.
const (
	RuntimeAddServerNoTlsv13Disabled RuntimeAddServerNoTlsv13 = "disabled"
	RuntimeAddServerNoTlsv13Enabled  RuntimeAddServerNoTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerObserve.
const (
	RuntimeAddServerObserveLayer4 RuntimeAddServerObserve = "layer4"
	RuntimeAddServerObserveLayer7 RuntimeAddServerObserve = "layer7"
)

// Defines values for RuntimeAddServerOnError.
const (
	RuntimeAddServerOnErrorFailCheck   RuntimeAddServerOnError = "fail-check"
	RuntimeAddServerOnErrorFastinter   RuntimeAddServerOnError = "fastinter"
	RuntimeAddServerOnErrorMarkDown    RuntimeAddServerOnError = "mark-down"
	RuntimeAddServerOnErrorSuddenDeath RuntimeAddServerOnError = "sudden-death"
)

// Defines values for RuntimeAddServerOnMarkedDown.
const (
	RuntimeAddServerOnMarkedDownShutdownSessions RuntimeAddServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for RuntimeAddServerOnMarkedUp.
const (
	RuntimeAddServerOnMarkedUpShutdownBackupSessions RuntimeAddServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for RuntimeAddServerProxyV2Options.
const (
	RuntimeAddServerProxyV2OptionsAuthority RuntimeAddServerProxyV2Options = "authority"
	RuntimeAddServerProxyV2OptionsCertCn    RuntimeAddServerProxyV2Options = "cert-cn"
	RuntimeAddServerProxyV2OptionsCertKey   RuntimeAddServerProxyV2Options = "cert-key"
	RuntimeAddServerProxyV2OptionsCertSig   RuntimeAddServerProxyV2Options = "cert-sig"
	RuntimeAddServerProxyV2OptionsCrc32c    RuntimeAddServerProxyV2Options = "crc32c"
	RuntimeAddServerProxyV2OptionsSsl       RuntimeAddServerProxyV2Options = "ssl"
	RuntimeAddServerProxyV2OptionsSslCipher RuntimeAddServerProxyV2Options = "ssl-cipher"
	RuntimeAddServerProxyV2OptionsUniqueId  RuntimeAddServerProxyV2Options = "unique-id"
)

// Defines values for RuntimeAddServerSendProxy.
const (
	RuntimeAddServerSendProxyDisabled RuntimeAddServerSendProxy = "disabled"
	RuntimeAddServerSendProxyEnabled  RuntimeAddServerSendProxy = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2.
const (
	RuntimeAddServerSendProxyV2Disabled RuntimeAddServerSendProxyV2 = "disabled"
	RuntimeAddServerSendProxyV2Enabled  RuntimeAddServerSendProxyV2 = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2Ssl.
const (
	RuntimeAddServerSendProxyV2SslDisabled RuntimeAddServerSendProxyV2Ssl = "disabled"
	RuntimeAddServerSendProxyV2SslEnabled  RuntimeAddServerSendProxyV2Ssl = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2SslCn.
const (
	RuntimeAddServerSendProxyV2SslCnDisabled RuntimeAddServerSendProxyV2SslCn = "disabled"
	RuntimeAddServerSendProxyV2SslCnEnabled  RuntimeAddServerSendProxyV2SslCn = "enabled"
)

// Defines values for RuntimeAddServerSsl.
const (
	RuntimeAddServerSslDisabled RuntimeAddServerSsl = "disabled"
	RuntimeAddServerSslEnabled  RuntimeAddServerSsl = "enabled"
)

// Defines values for RuntimeAddServerSslMaxVer.
const (
	RuntimeAddServerSslMaxVerSSLv3  RuntimeAddServerSslMaxVer = "SSLv3"
	RuntimeAddServerSslMaxVerTLSv10 RuntimeAddServerSslMaxVer = "TLSv1.0"
	RuntimeAddServerSslMaxVerTLSv11 RuntimeAddServerSslMaxVer = "TLSv1.1"
	RuntimeAddServerSslMaxVerTLSv12 RuntimeAddServerSslMaxVer = "TLSv1.2"
	RuntimeAddServerSslMaxVerTLSv13 RuntimeAddServerSslMaxVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslMinVer.
const (
	RuntimeAddServerSslMinVerSSLv3  RuntimeAddServerSslMinVer = "SSLv3"
	RuntimeAddServerSslMinVerTLSv10 RuntimeAddServerSslMinVer = "TLSv1.0"
	RuntimeAddServerSslMinVerTLSv11 RuntimeAddServerSslMinVer = "TLSv1.1"
	RuntimeAddServerSslMinVerTLSv12 RuntimeAddServerSslMinVer = "TLSv1.2"
	RuntimeAddServerSslMinVerTLSv13 RuntimeAddServerSslMinVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslReuse.
const (
	RuntimeAddServerSslReuseDisabled RuntimeAddServerSslReuse = "disabled"
	RuntimeAddServerSslReuseEnabled  RuntimeAddServerSslReuse = "enabled"
)

// Defines values for RuntimeAddServerTfo.
const (
	RuntimeAddServerTfoDisabled RuntimeAddServerTfo = "disabled"
	RuntimeAddServerTfoEnabled  RuntimeAddServerTfo = "enabled"
)

// Defines values for RuntimeAddServerTlsTickets.
const (
	RuntimeAddServerTlsTicketsDisabled RuntimeAddServerTlsTickets = "disabled"
	RuntimeAddServerTlsTicketsEnabled  RuntimeAddServerTlsTickets = "enabled"
)

// Defines values for RuntimeAddServerVerify.
const (
	RuntimeAddServerVerifyNone     RuntimeAddServerVerify = "none"
	RuntimeAddServerVerifyRequired RuntimeAddServerVerify = "required"
)

// Defines values for RuntimeAddServerWs.
const (
	RuntimeAddServerWsAuto RuntimeAddServerWs = "auto"
	RuntimeAddServerWsH1   RuntimeAddServerWs = "h1"
	RuntimeAddServerWsH2   RuntimeAddServerWs = "h2"
)

// Defines values for RuntimeServerAdminState.
const (
	RuntimeServerAdminStateDrain RuntimeServerAdminState = "drain"
	RuntimeServerAdminStateMaint RuntimeServerAdminState = "maint"
	RuntimeServerAdminStateReady RuntimeServerAdminState = "ready"
)

// Defines values for RuntimeServerOperationalState.
const (
	RuntimeServerOperationalStateDown     RuntimeServerOperationalState = "down"
	RuntimeServerOperationalStateStopping RuntimeServerOperationalState = "stopping"
	RuntimeServerOperationalStateUp       RuntimeServerOperationalState = "up"
)

// Defines values for ServerAgentCheck.
const (
	ServerAgentCheckDisabled ServerAgentCheck = "disabled"
	ServerAgentCheckEnabled  ServerAgentCheck = "enabled"
)

// Defines values for ServerBackup.
const (
	ServerBackupDisabled ServerBackup = "disabled"
	ServerBackupEnabled  ServerBackup = "enabled"
)

// Defines values for ServerCheck.
const (
	ServerCheckDisabled ServerCheck = "disabled"
	ServerCheckEnabled  ServerCheck = "enabled"
)

// Defines values for ServerCheckSendProxy.
const (
	ServerCheckSendProxyDisabled ServerCheckSendProxy = "disabled"
	ServerCheckSendProxyEnabled  ServerCheckSendProxy = "enabled"
)

// Defines values for ServerCheckSsl.
const (
	ServerCheckSslDisabled ServerCheckSsl = "disabled"
	ServerCheckSslEnabled  ServerCheckSsl = "enabled"
)

// Defines values for ServerCheckViaSocks4.
const (
	ServerCheckViaSocks4Disabled ServerCheckViaSocks4 = "disabled"
	ServerCheckViaSocks4Enabled  ServerCheckViaSocks4 = "enabled"
)

// Defines values for ServerForceSslv3.
const (
	ServerForceSslv3Disabled ServerForceSslv3 = "disabled"
	ServerForceSslv3Enabled  ServerForceSslv3 = "enabled"
)

// Defines values for ServerForceTlsv10.
const (
	ServerForceTlsv10Disabled ServerForceTlsv10 = "disabled"
	ServerForceTlsv10Enabled  ServerForceTlsv10 = "enabled"
)

// Defines values for ServerForceTlsv11.
const (
	ServerForceTlsv11Disabled ServerForceTlsv11 = "disabled"
	ServerForceTlsv11Enabled  ServerForceTlsv11 = "enabled"
)

// Defines values for ServerForceTlsv12.
const (
	ServerForceTlsv12Disabled ServerForceTlsv12 = "disabled"
	ServerForceTlsv12Enabled  ServerForceTlsv12 = "enabled"
)

// Defines values for ServerForceTlsv13.
const (
	ServerForceTlsv13Disabled ServerForceTlsv13 = "disabled"
	ServerForceTlsv13Enabled  ServerForceTlsv13 = "enabled"
)

// Defines values for ServerInitState.
const (
	ServerInitStateDown      ServerInitState = "down"
	ServerInitStateFullyDown ServerInitState = "fully-down"
	ServerInitStateFullyUp   ServerInitState = "fully-up"
	ServerInitStateUp        ServerInitState = "up"
)

// Defines values for ServerLogProto.
const (
	ServerLogProtoLegacy     ServerLogProto = "legacy"
	ServerLogProtoOctetCount ServerLogProto = "octet-count"
)

// Defines values for ServerMaintenance.
const (
	ServerMaintenanceDisabled ServerMaintenance = "disabled"
	ServerMaintenanceEnabled  ServerMaintenance = "enabled"
)

// Defines values for ServerNoSslv3.
const (
	ServerNoSslv3Disabled ServerNoSslv3 = "disabled"
	ServerNoSslv3Enabled  ServerNoSslv3 = "enabled"
)

// Defines values for ServerNoTlsv10.
const (
	ServerNoTlsv10Disabled ServerNoTlsv10 = "disabled"
	ServerNoTlsv10Enabled  ServerNoTlsv10 = "enabled"
)

// Defines values for ServerNoTlsv11.
const (
	ServerNoTlsv11Disabled ServerNoTlsv11 = "disabled"
	ServerNoTlsv11Enabled  ServerNoTlsv11 = "enabled"
)

// Defines values for ServerNoTlsv12.
const (
	ServerNoTlsv12Disabled ServerNoTlsv12 = "disabled"
	ServerNoTlsv12Enabled  ServerNoTlsv12 = "enabled"
)

// Defines values for ServerNoTlsv13.
const (
	ServerNoTlsv13Disabled ServerNoTlsv13 = "disabled"
	ServerNoTlsv13Enabled  ServerNoTlsv13 = "enabled"
)

// Defines values for ServerNoVerifyhost.
const (
	ServerNoVerifyhostDisabled ServerNoVerifyhost = "disabled"
	ServerNoVerifyhostEnabled  ServerNoVerifyhost = "enabled"
)

// Defines values for ServerObserve.
const (
	ServerObserveLayer4 ServerObserve = "layer4"
	ServerObserveLayer7 ServerObserve = "layer7"
)

// Defines values for ServerOnError.
const (
	ServerOnErrorFailCheck   ServerOnError = "fail-check"
	ServerOnErrorFastinter   ServerOnError = "fastinter"
	ServerOnErrorMarkDown    ServerOnError = "mark-down"
	ServerOnErrorSuddenDeath ServerOnError = "sudden-death"
)

// Defines values for ServerOnMarkedDown.
const (
	ServerOnMarkedDownShutdownSessions ServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerOnMarkedUp.
const (
	ServerOnMarkedUpShutdownBackupSessions ServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerProxyV2Options.
const (
	ServerProxyV2OptionsAuthority ServerProxyV2Options = "authority"
	ServerProxyV2OptionsCertCn    ServerProxyV2Options = "cert-cn"
	ServerProxyV2OptionsCertKey   ServerProxyV2Options = "cert-key"
	ServerProxyV2OptionsCertSig   ServerProxyV2Options = "cert-sig"
	ServerProxyV2OptionsCrc32c    ServerProxyV2Options = "crc32c"
	ServerProxyV2OptionsSsl       ServerProxyV2Options = "ssl"
	ServerProxyV2OptionsSslCipher ServerProxyV2Options = "ssl-cipher"
	ServerProxyV2OptionsUniqueId  ServerProxyV2Options = "unique-id"
)

// Defines values for ServerResolvePrefer.
const (
	ServerResolvePreferIpv4 ServerResolvePrefer = "ipv4"
	ServerResolvePreferIpv6 ServerResolvePrefer = "ipv6"
)

// Defines values for ServerSendProxy.
const (
	ServerSendProxyDisabled ServerSendProxy = "disabled"
	ServerSendProxyEnabled  ServerSendProxy = "enabled"
)

// Defines values for ServerSendProxyV2.
const (
	ServerSendProxyV2Disabled ServerSendProxyV2 = "disabled"
	ServerSendProxyV2Enabled  ServerSendProxyV2 = "enabled"
)

// Defines values for ServerSendProxyV2Ssl.
const (
	ServerSendProxyV2SslDisabled ServerSendProxyV2Ssl = "disabled"
	ServerSendProxyV2SslEnabled  ServerSendProxyV2Ssl = "enabled"
)

// Defines values for ServerSendProxyV2SslCn.
const (
	ServerSendProxyV2SslCnDisabled ServerSendProxyV2SslCn = "disabled"
	ServerSendProxyV2SslCnEnabled  ServerSendProxyV2SslCn = "enabled"
)

// Defines values for ServerSsl.
const (
	ServerSslDisabled ServerSsl = "disabled"
	ServerSslEnabled  ServerSsl = "enabled"
)

// Defines values for ServerSslMaxVer.
const (
	ServerSslMaxVerSSLv3  ServerSslMaxVer = "SSLv3"
	ServerSslMaxVerTLSv10 ServerSslMaxVer = "TLSv1.0"
	ServerSslMaxVerTLSv11 ServerSslMaxVer = "TLSv1.1"
	ServerSslMaxVerTLSv12 ServerSslMaxVer = "TLSv1.2"
	ServerSslMaxVerTLSv13 ServerSslMaxVer = "TLSv1.3"
)

// Defines values for ServerSslMinVer.
const (
	ServerSslMinVerSSLv3  ServerSslMinVer = "SSLv3"
	ServerSslMinVerTLSv10 ServerSslMinVer = "TLSv1.0"
	ServerSslMinVerTLSv11 ServerSslMinVer = "TLSv1.1"
	ServerSslMinVerTLSv12 ServerSslMinVer = "TLSv1.2"
	ServerSslMinVerTLSv13 ServerSslMinVer = "TLSv1.3"
)

// Defines values for ServerSslReuse.
const (
	ServerSslReuseDisabled ServerSslReuse = "disabled"
	ServerSslReuseEnabled  ServerSslReuse = "enabled"
)

// Defines values for ServerSslv3.
const (
	ServerSslv3Disabled ServerSslv3 = "disabled"
	ServerSslv3Enabled  ServerSslv3 = "enabled"
)

// Defines values for ServerStick.
const (
	ServerStickDisabled ServerStick = "disabled"
	ServerStickEnabled  ServerStick = "enabled"
)

// Defines values for ServerTfo.
const (
	ServerTfoDisabled ServerTfo = "disabled"
	ServerTfoEnabled  ServerTfo = "enabled"
)

// Defines values for ServerTlsTickets.
const (
	ServerTlsTicketsDisabled ServerTlsTickets = "disabled"
	ServerTlsTicketsEnabled  ServerTlsTickets = "enabled"
)

// Defines values for ServerTlsv10.
const (
	ServerTlsv10Disabled ServerTlsv10 = "disabled"
	ServerTlsv10Enabled  ServerTlsv10 = "enabled"
)

// Defines values for ServerTlsv11.
const (
	ServerTlsv11Disabled ServerTlsv11 = "disabled"
	ServerTlsv11Enabled  ServerTlsv11 = "enabled"
)

// Defines values for ServerTlsv12.
const (
	ServerTlsv12Disabled ServerTlsv12 = "disabled"
	ServerTlsv12Enabled  ServerTlsv12 = "enabled"
)

// Defines values for ServerTlsv13.
const (
	ServerTlsv13Disabled ServerTlsv13 = "disabled"
	ServerTlsv13Enabled  ServerTlsv13 = "enabled"
)

// Defines values for ServerVerify.
const (
	ServerVerifyNone     ServerVerify = "none"
	ServerVerifyRequired ServerVerify = "required"
)

// Defines values for ServerWs.
const (
	ServerWsAuto ServerWs = "auto"
	ServerWsH1   ServerWs = "h1"
	ServerWsH2   ServerWs = "h2"
)

// Defines values for ServerParamsAgentCheck.
const (
	ServerParamsAgentCheckDisabled ServerParamsAgentCheck = "disabled"
	ServerParamsAgentCheckEnabled  ServerParamsAgentCheck = "enabled"
)

// Defines values for ServerParamsBackup.
const (
	ServerParamsBackupDisabled ServerParamsBackup = "disabled"
	ServerParamsBackupEnabled  ServerParamsBackup = "enabled"
)

// Defines values for ServerParamsCheck.
const (
	ServerParamsCheckDisabled ServerParamsCheck = "disabled"
	ServerParamsCheckEnabled  ServerParamsCheck = "enabled"
)

// Defines values for ServerParamsCheckSendProxy.
const (
	ServerParamsCheckSendProxyDisabled ServerParamsCheckSendProxy = "disabled"
	ServerParamsCheckSendProxyEnabled  ServerParamsCheckSendProxy = "enabled"
)

// Defines values for ServerParamsCheckSsl.
const (
	ServerParamsCheckSslDisabled ServerParamsCheckSsl = "disabled"
	ServerParamsCheckSslEnabled  ServerParamsCheckSsl = "enabled"
)

// Defines values for ServerParamsCheckViaSocks4.
const (
	ServerParamsCheckViaSocks4Disabled ServerParamsCheckViaSocks4 = "disabled"
	ServerParamsCheckViaSocks4Enabled  ServerParamsCheckViaSocks4 = "enabled"
)

// Defines values for ServerParamsForceSslv3.
const (
	ServerParamsForceSslv3Disabled ServerParamsForceSslv3 = "disabled"
	ServerParamsForceSslv3Enabled  ServerParamsForceSslv3 = "enabled"
)

// Defines values for ServerParamsForceTlsv10.
const (
	ServerParamsForceTlsv10Disabled ServerParamsForceTlsv10 = "disabled"
	ServerParamsForceTlsv10Enabled  ServerParamsForceTlsv10 = "enabled"
)

// Defines values for ServerParamsForceTlsv11.
const (
	ServerParamsForceTlsv11Disabled ServerParamsForceTlsv11 = "disabled"
	ServerParamsForceTlsv11Enabled  ServerParamsForceTlsv11 = "enabled"
)

// Defines values for ServerParamsForceTlsv12.
const (
	ServerParamsForceTlsv12Disabled ServerParamsForceTlsv12 = "disabled"
	ServerParamsForceTlsv12Enabled  ServerParamsForceTlsv12 = "enabled"
)

// Defines values for ServerParamsForceTlsv13.
const (
	ServerParamsForceTlsv13Disabled ServerParamsForceTlsv13 = "disabled"
	ServerParamsForceTlsv13Enabled  ServerParamsForceTlsv13 = "enabled"
)

// Defines values for ServerParamsInitState.
const (
	ServerParamsInitStateDown      ServerParamsInitState = "down"
	ServerParamsInitStateFullyDown ServerParamsInitState = "fully-down"
	ServerParamsInitStateFullyUp   ServerParamsInitState = "fully-up"
	ServerParamsInitStateUp        ServerParamsInitState = "up"
)

// Defines values for ServerParamsLogProto.
const (
	ServerParamsLogProtoLegacy     ServerParamsLogProto = "legacy"
	ServerParamsLogProtoOctetCount ServerParamsLogProto = "octet-count"
)

// Defines values for ServerParamsMaintenance.
const (
	ServerParamsMaintenanceDisabled ServerParamsMaintenance = "disabled"
	ServerParamsMaintenanceEnabled  ServerParamsMaintenance = "enabled"
)

// Defines values for ServerParamsNoSslv3.
const (
	ServerParamsNoSslv3Disabled ServerParamsNoSslv3 = "disabled"
	ServerParamsNoSslv3Enabled  ServerParamsNoSslv3 = "enabled"
)

// Defines values for ServerParamsNoTlsv10.
const (
	ServerParamsNoTlsv10Disabled ServerParamsNoTlsv10 = "disabled"
	ServerParamsNoTlsv10Enabled  ServerParamsNoTlsv10 = "enabled"
)

// Defines values for ServerParamsNoTlsv11.
const (
	ServerParamsNoTlsv11Disabled ServerParamsNoTlsv11 = "disabled"
	ServerParamsNoTlsv11Enabled  ServerParamsNoTlsv11 = "enabled"
)

// Defines values for ServerParamsNoTlsv12.
const (
	ServerParamsNoTlsv12Disabled ServerParamsNoTlsv12 = "disabled"
	ServerParamsNoTlsv12Enabled  ServerParamsNoTlsv12 = "enabled"
)

// Defines values for ServerParamsNoTlsv13.
const (
	ServerParamsNoTlsv13Disabled ServerParamsNoTlsv13 = "disabled"
	ServerParamsNoTlsv13Enabled  ServerParamsNoTlsv13 = "enabled"
)

// Defines values for ServerParamsNoVerifyhost.
const (
	ServerParamsNoVerifyhostDisabled ServerParamsNoVerifyhost = "disabled"
	ServerParamsNoVerifyhostEnabled  ServerParamsNoVerifyhost = "enabled"
)

// Defines values for ServerParamsObserve.
const (
	ServerParamsObserveLayer4 ServerParamsObserve = "layer4"
	ServerParamsObserveLayer7 ServerParamsObserve = "layer7"
)

// Defines values for ServerParamsOnError.
const (
	ServerParamsOnErrorFailCheck   ServerParamsOnError = "fail-check"
	ServerParamsOnErrorFastinter   ServerParamsOnError = "fastinter"
	ServerParamsOnErrorMarkDown    ServerParamsOnError = "mark-down"
	ServerParamsOnErrorSuddenDeath ServerParamsOnError = "sudden-death"
)

// Defines values for ServerParamsOnMarkedDown.
const (
	ServerParamsOnMarkedDownShutdownSessions ServerParamsOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerParamsOnMarkedUp.
const (
	ServerParamsOnMarkedUpShutdownBackupSessions ServerParamsOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerParamsProxyV2Options.
const (
	ServerParamsProxyV2OptionsAuthority ServerParamsProxyV2Options = "authority"
	ServerParamsProxyV2OptionsCertCn    ServerParamsProxyV2Options = "cert-cn"
	ServerParamsProxyV2OptionsCertKey   ServerParamsProxyV2Options = "cert-key"
	ServerParamsProxyV2OptionsCertSig   ServerParamsProxyV2Options = "cert-sig"
	ServerParamsProxyV2OptionsCrc32c    ServerParamsProxyV2Options = "crc32c"
	ServerParamsProxyV2OptionsSsl       ServerParamsProxyV2Options = "ssl"
	ServerParamsProxyV2OptionsSslCipher ServerParamsProxyV2Options = "ssl-cipher"
	ServerParamsProxyV2OptionsUniqueId  ServerParamsProxyV2Options = "unique-id"
)

// Defines values for ServerParamsResolvePrefer.
const (
	ServerParamsResolvePreferIpv4 ServerParamsResolvePrefer = "ipv4"
	ServerParamsResolvePreferIpv6 ServerParamsResolvePrefer = "ipv6"
)

// Defines values for ServerParamsSendProxy.
const (
	ServerParamsSendProxyDisabled ServerParamsSendProxy = "disabled"
	ServerParamsSendProxyEnabled  ServerParamsSendProxy = "enabled"
)

// Defines values for ServerParamsSendProxyV2.
const (
	ServerParamsSendProxyV2Disabled ServerParamsSendProxyV2 = "disabled"
	ServerParamsSendProxyV2Enabled  ServerParamsSendProxyV2 = "enabled"
)

// Defines values for ServerParamsSendProxyV2Ssl.
const (
	ServerParamsSendProxyV2SslDisabled ServerParamsSendProxyV2Ssl = "disabled"
	ServerParamsSendProxyV2SslEnabled  ServerParamsSendProxyV2Ssl = "enabled"
)

// Defines values for ServerParamsSendProxyV2SslCn.
const (
	ServerParamsSendProxyV2SslCnDisabled ServerParamsSendProxyV2SslCn = "disabled"
	ServerParamsSendProxyV2SslCnEnabled  ServerParamsSendProxyV2SslCn = "enabled"
)

// Defines values for ServerParamsSsl.
const (
	ServerParamsSslDisabled ServerParamsSsl = "disabled"
	ServerParamsSslEnabled  ServerParamsSsl = "enabled"
)

// Defines values for ServerParamsSslMaxVer.
const (
	ServerParamsSslMaxVerSSLv3  ServerParamsSslMaxVer = "SSLv3"
	ServerParamsSslMaxVerTLSv10 ServerParamsSslMaxVer = "TLSv1.0"
	ServerParamsSslMaxVerTLSv11 ServerParamsSslMaxVer = "TLSv1.1"
	ServerParamsSslMaxVerTLSv12 ServerParamsSslMaxVer = "TLSv1.2"
	ServerParamsSslMaxVerTLSv13 ServerParamsSslMaxVer = "TLSv1.3"
)

// Defines values for ServerParamsSslMinVer.
const (
	ServerParamsSslMinVerSSLv3  ServerParamsSslMinVer = "SSLv3"
	ServerParamsSslMinVerTLSv10 ServerParamsSslMinVer = "TLSv1.0"
	ServerParamsSslMinVerTLSv11 ServerParamsSslMinVer = "TLSv1.1"
	ServerParamsSslMinVerTLSv12 ServerParamsSslMinVer = "TLSv1.2"
	ServerParamsSslMinVerTLSv13 ServerParamsSslMinVer = "TLSv1.3"
)

// Defines values for ServerParamsSslReuse.
const (
	ServerParamsSslReuseDisabled ServerParamsSslReuse = "disabled"
	ServerParamsSslReuseEnabled  ServerParamsSslReuse = "enabled"
)

// Defines values for ServerParamsSslv3.
const (
	ServerParamsSslv3Disabled ServerParamsSslv3 = "disabled"
	ServerParamsSslv3Enabled  ServerParamsSslv3 = "enabled"
)

// Defines values for ServerParamsStick.
const (
	ServerParamsStickDisabled ServerParamsStick = "disabled"
	ServerParamsStickEnabled  ServerParamsStick = "enabled"
)

// Defines values for ServerParamsTfo.
const (
	ServerParamsTfoDisabled ServerParamsTfo = "disabled"
	ServerParamsTfoEnabled  ServerParamsTfo = "enabled"
)

// Defines values for ServerParamsTlsTickets.
const (
	ServerParamsTlsTicketsDisabled ServerParamsTlsTickets = "disabled"
	ServerParamsTlsTicketsEnabled  ServerParamsTlsTickets = "enabled"
)

// Defines values for ServerParamsTlsv10.
const (
	ServerParamsTlsv10Disabled ServerParamsTlsv10 = "disabled"
	ServerParamsTlsv10Enabled  ServerParamsTlsv10 = "enabled"
)

// Defines values for ServerParamsTlsv11.
const (
	ServerParamsTlsv11Disabled ServerParamsTlsv11 = "disabled"
	ServerParamsTlsv11Enabled  ServerParamsTlsv11 = "enabled"
)

// Defines values for ServerParamsTlsv12.
const (
	ServerParamsTlsv12Disabled ServerParamsTlsv12 = "disabled"
	ServerParamsTlsv12Enabled  ServerParamsTlsv12 = "enabled"
)

// Defines values for ServerParamsTlsv13.
const (
	ServerParamsTlsv13Disabled ServerParamsTlsv13 = "disabled"
	ServerParamsTlsv13Enabled  ServerParamsTlsv13 = "enabled"
)

// Defines values for ServerParamsVerify.
const (
	ServerParamsVerifyNone     ServerParamsVerify = "none"
	ServerParamsVerifyRequired ServerParamsVerify = "required"
)

// Defines values for ServerParamsWs.
const (
	ServerParamsWsAuto ServerParamsWs = "auto"
	ServerParamsWsH1   ServerParamsWs = "h1"
	ServerParamsWsH2   ServerParamsWs = "h2"
)

// Defines values for ServerSwitchingRuleCond.
const (
	ServerSwitchingRuleCondIf     ServerSwitchingRuleCond = "if"
	ServerSwitchingRuleCondUnless ServerSwitchingRuleCond = "unless"
)

// Defines values for ServerTemplateAgentCheck.
const (
	ServerTemplateAgentCheckDisabled ServerTemplateAgentCheck = "disabled"
	ServerTemplateAgentCheckEnabled  ServerTemplateAgentCheck = "enabled"
)

// Defines values for ServerTemplateBackup.
const (
	ServerTemplateBackupDisabled ServerTemplateBackup = "disabled"
	ServerTemplateBackupEnabled  ServerTemplateBackup = "enabled"
)

// Defines values for ServerTemplateCheck.
const (
	ServerTemplateCheckDisabled ServerTemplateCheck = "disabled"
	ServerTemplateCheckEnabled  ServerTemplateCheck = "enabled"
)

// Defines values for ServerTemplateCheckSendProxy.
const (
	ServerTemplateCheckSendProxyDisabled ServerTemplateCheckSendProxy = "disabled"
	ServerTemplateCheckSendProxyEnabled  ServerTemplateCheckSendProxy = "enabled"
)

// Defines values for ServerTemplateCheckSsl.
const (
	ServerTemplateCheckSslDisabled ServerTemplateCheckSsl = "disabled"
	ServerTemplateCheckSslEnabled  ServerTemplateCheckSsl = "enabled"
)

// Defines values for ServerTemplateCheckViaSocks4.
const (
	ServerTemplateCheckViaSocks4Disabled ServerTemplateCheckViaSocks4 = "disabled"
	ServerTemplateCheckViaSocks4Enabled  ServerTemplateCheckViaSocks4 = "enabled"
)

// Defines values for ServerTemplateForceSslv3.
const (
	ServerTemplateForceSslv3Disabled ServerTemplateForceSslv3 = "disabled"
	ServerTemplateForceSslv3Enabled  ServerTemplateForceSslv3 = "enabled"
)

// Defines values for ServerTemplateForceTlsv10.
const (
	ServerTemplateForceTlsv10Disabled ServerTemplateForceTlsv10 = "disabled"
	ServerTemplateForceTlsv10Enabled  ServerTemplateForceTlsv10 = "enabled"
)

// Defines values for ServerTemplateForceTlsv11.
const (
	ServerTemplateForceTlsv11Disabled ServerTemplateForceTlsv11 = "disabled"
	ServerTemplateForceTlsv11Enabled  ServerTemplateForceTlsv11 = "enabled"
)

// Defines values for ServerTemplateForceTlsv12.
const (
	ServerTemplateForceTlsv12Disabled ServerTemplateForceTlsv12 = "disabled"
	ServerTemplateForceTlsv12Enabled  ServerTemplateForceTlsv12 = "enabled"
)

// Defines values for ServerTemplateForceTlsv13.
const (
	ServerTemplateForceTlsv13Disabled ServerTemplateForceTlsv13 = "disabled"
	ServerTemplateForceTlsv13Enabled  ServerTemplateForceTlsv13 = "enabled"
)

// Defines values for ServerTemplateInitState.
const (
	ServerTemplateInitStateDown      ServerTemplateInitState = "down"
	ServerTemplateInitStateFullyDown ServerTemplateInitState = "fully-down"
	ServerTemplateInitStateFullyUp   ServerTemplateInitState = "fully-up"
	ServerTemplateInitStateUp        ServerTemplateInitState = "up"
)

// Defines values for ServerTemplateLogProto.
const (
	ServerTemplateLogProtoLegacy     ServerTemplateLogProto = "legacy"
	ServerTemplateLogProtoOctetCount ServerTemplateLogProto = "octet-count"
)

// Defines values for ServerTemplateMaintenance.
const (
	ServerTemplateMaintenanceDisabled ServerTemplateMaintenance = "disabled"
	ServerTemplateMaintenanceEnabled  ServerTemplateMaintenance = "enabled"
)

// Defines values for ServerTemplateNoSslv3.
const (
	ServerTemplateNoSslv3Disabled ServerTemplateNoSslv3 = "disabled"
	ServerTemplateNoSslv3Enabled  ServerTemplateNoSslv3 = "enabled"
)

// Defines values for ServerTemplateNoTlsv10.
const (
	ServerTemplateNoTlsv10Disabled ServerTemplateNoTlsv10 = "disabled"
	ServerTemplateNoTlsv10Enabled  ServerTemplateNoTlsv10 = "enabled"
)

// Defines values for ServerTemplateNoTlsv11.
const (
	ServerTemplateNoTlsv11Disabled ServerTemplateNoTlsv11 = "disabled"
	ServerTemplateNoTlsv11Enabled  ServerTemplateNoTlsv11 = "enabled"
)

// Defines values for ServerTemplateNoTlsv12.
const (
	ServerTemplateNoTlsv12Disabled ServerTemplateNoTlsv12 = "disabled"
	ServerTemplateNoTlsv12Enabled  ServerTemplateNoTlsv12 = "enabled"
)

// Defines values for ServerTemplateNoTlsv13.
const (
	ServerTemplateNoTlsv13Disabled ServerTemplateNoTlsv13 = "disabled"
	ServerTemplateNoTlsv13Enabled  ServerTemplateNoTlsv13 = "enabled"
)

// Defines values for ServerTemplateNoVerifyhost.
const (
	ServerTemplateNoVerifyhostDisabled ServerTemplateNoVerifyhost = "disabled"
	ServerTemplateNoVerifyhostEnabled  ServerTemplateNoVerifyhost = "enabled"
)

// Defines values for ServerTemplateObserve.
const (
	ServerTemplateObserveLayer4 ServerTemplateObserve = "layer4"
	ServerTemplateObserveLayer7 ServerTemplateObserve = "layer7"
)

// Defines values for ServerTemplateOnError.
const (
	ServerTemplateOnErrorFailCheck   ServerTemplateOnError = "fail-check"
	ServerTemplateOnErrorFastinter   ServerTemplateOnError = "fastinter"
	ServerTemplateOnErrorMarkDown    ServerTemplateOnError = "mark-down"
	ServerTemplateOnErrorSuddenDeath ServerTemplateOnError = "sudden-death"
)

// Defines values for ServerTemplateOnMarkedDown.
const (
	ServerTemplateOnMarkedDownShutdownSessions ServerTemplateOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerTemplateOnMarkedUp.
const (
	ServerTemplateOnMarkedUpShutdownBackupSessions ServerTemplateOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerTemplateProxyV2Options.
const (
	ServerTemplateProxyV2OptionsAuthority ServerTemplateProxyV2Options = "authority"
	ServerTemplateProxyV2OptionsCertCn    ServerTemplateProxyV2Options = "cert-cn"
	ServerTemplateProxyV2OptionsCertKey   ServerTemplateProxyV2Options = "cert-key"
	ServerTemplateProxyV2OptionsCertSig   ServerTemplateProxyV2Options = "cert-sig"
	ServerTemplateProxyV2OptionsCrc32c    ServerTemplateProxyV2Options = "crc32c"
	ServerTemplateProxyV2OptionsSsl       ServerTemplateProxyV2Options = "ssl"
	ServerTemplateProxyV2OptionsSslCipher ServerTemplateProxyV2Options = "ssl-cipher"
	ServerTemplateProxyV2OptionsUniqueId  ServerTemplateProxyV2Options = "unique-id"
)

// Defines values for ServerTemplateResolvePrefer.
const (
	ServerTemplateResolvePreferIpv4 ServerTemplateResolvePrefer = "ipv4"
	ServerTemplateResolvePreferIpv6 ServerTemplateResolvePrefer = "ipv6"
)

// Defines values for ServerTemplateSendProxy.
const (
	ServerTemplateSendProxyDisabled ServerTemplateSendProxy = "disabled"
	ServerTemplateSendProxyEnabled  ServerTemplateSendProxy = "enabled"
)

// Defines values for ServerTemplateSendProxyV2.
const (
	ServerTemplateSendProxyV2Disabled ServerTemplateSendProxyV2 = "disabled"
	ServerTemplateSendProxyV2Enabled  ServerTemplateSendProxyV2 = "enabled"
)

// Defines values for ServerTemplateSendProxyV2Ssl.
const (
	ServerTemplateSendProxyV2SslDisabled ServerTemplateSendProxyV2Ssl = "disabled"
	ServerTemplateSendProxyV2SslEnabled  ServerTemplateSendProxyV2Ssl = "enabled"
)

// Defines values for ServerTemplateSendProxyV2SslCn.
const (
	ServerTemplateSendProxyV2SslCnDisabled ServerTemplateSendProxyV2SslCn = "disabled"
	ServerTemplateSendProxyV2SslCnEnabled  ServerTemplateSendProxyV2SslCn = "enabled"
)

// Defines values for ServerTemplateSsl.
const (
	ServerTemplateSslDisabled ServerTemplateSsl = "disabled"
	ServerTemplateSslEnabled  ServerTemplateSsl = "enabled"
)

// Defines values for ServerTemplateSslMaxVer.
const (
	ServerTemplateSslMaxVerSSLv3  ServerTemplateSslMaxVer = "SSLv3"
	ServerTemplateSslMaxVerTLSv10 ServerTemplateSslMaxVer = "TLSv1.0"
	ServerTemplateSslMaxVerTLSv11 ServerTemplateSslMaxVer = "TLSv1.1"
	ServerTemplateSslMaxVerTLSv12 ServerTemplateSslMaxVer = "TLSv1.2"
	ServerTemplateSslMaxVerTLSv13 ServerTemplateSslMaxVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslMinVer.
const (
	ServerTemplateSslMinVerSSLv3  ServerTemplateSslMinVer = "SSLv3"
	ServerTemplateSslMinVerTLSv10 ServerTemplateSslMinVer = "TLSv1.0"
	ServerTemplateSslMinVerTLSv11 ServerTemplateSslMinVer = "TLSv1.1"
	ServerTemplateSslMinVerTLSv12 ServerTemplateSslMinVer = "TLSv1.2"
	ServerTemplateSslMinVerTLSv13 ServerTemplateSslMinVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslReuse.
const (
	ServerTemplateSslReuseDisabled ServerTemplateSslReuse = "disabled"
	ServerTemplateSslReuseEnabled  ServerTemplateSslReuse = "enabled"
)

// Defines values for ServerTemplateSslv3.
const (
	ServerTemplateSslv3Disabled ServerTemplateSslv3 = "disabled"
	ServerTemplateSslv3Enabled  ServerTemplateSslv3 = "enabled"
)

// Defines values for ServerTemplateStick.
const (
	ServerTemplateStickDisabled ServerTemplateStick = "disabled"
	ServerTemplateStickEnabled  ServerTemplateStick = "enabled"
)

// Defines values for ServerTemplateTfo.
const (
	ServerTemplateTfoDisabled ServerTemplateTfo = "disabled"
	ServerTemplateTfoEnabled  ServerTemplateTfo = "enabled"
)

// Defines values for ServerTemplateTlsTickets.
const (
	ServerTemplateTlsTicketsDisabled ServerTemplateTlsTickets = "disabled"
	ServerTemplateTlsTicketsEnabled  ServerTemplateTlsTickets = "enabled"
)

// Defines values for ServerTemplateTlsv10.
const (
	ServerTemplateTlsv10Disabled ServerTemplateTlsv10 = "disabled"
	ServerTemplateTlsv10Enabled  ServerTemplateTlsv10 = "enabled"
)

// Defines values for ServerTemplateTlsv11.
const (
	ServerTemplateTlsv11Disabled ServerTemplateTlsv11 = "disabled"
	ServerTemplateTlsv11Enabled  ServerTemplateTlsv11 = "enabled"
)

// Defines values for ServerTemplateTlsv12.
const (
	ServerTemplateTlsv12Disabled ServerTemplateTlsv12 = "disabled"
	ServerTemplateTlsv12Enabled  ServerTemplateTlsv12 = "enabled"
)

// Defines values for ServerTemplateTlsv13.
const (
	ServerTemplateTlsv13Disabled ServerTemplateTlsv13 = "disabled"
	ServerTemplateTlsv13Enabled  ServerTemplateTlsv13 = "enabled"
)

// Defines values for ServerTemplateVerify.
const (
	ServerTemplateVerifyNone     ServerTemplateVerify = "none"
	ServerTemplateVerifyRequired ServerTemplateVerify = "required"
)

// Defines values for ServerTemplateWs.
const (
	ServerTemplateWsAuto ServerTemplateWs = "auto"
	ServerTemplateWsH1   ServerTemplateWs = "h1"
	ServerTemplateWsH2   ServerTemplateWs = "h2"
)

// Defines values for SiteFarmsCond.
const (
	SiteFarmsCondIf     SiteFarmsCond = "if"
	SiteFarmsCondUnless SiteFarmsCond = "unless"
)

// Defines values for SiteFarmsMode.
const (
	SiteFarmsModeHttp SiteFarmsMode = "http"
	SiteFarmsModeTcp  SiteFarmsMode = "tcp"
)

// Defines values for SiteFarmsUseAs.
const (
	SiteFarmsUseAsConditional SiteFarmsUseAs = "conditional"
	SiteFarmsUseAsDefault     SiteFarmsUseAs = "default"
)

// Defines values for SiteServiceHttpConnectionMode.
const (
	SiteServiceHttpConnectionModeForcedClose     SiteServiceHttpConnectionMode = "forced-close"
	SiteServiceHttpConnectionModeHttpKeepAlive   SiteServiceHttpConnectionMode = "http-keep-alive"
	SiteServiceHttpConnectionModeHttpServerClose SiteServiceHttpConnectionMode = "http-server-close"
	SiteServiceHttpConnectionModeHttpTunnel      SiteServiceHttpConnectionMode = "http-tunnel"
	SiteServiceHttpConnectionModeHttpclose       SiteServiceHttpConnectionMode = "httpclose"
)

// Defines values for SiteServiceMode.
const (
	SiteServiceModeHttp SiteServiceMode = "http"
	SiteServiceModeTcp  SiteServiceMode = "tcp"
)

// Defines values for SourceUsesrc.
const (
	SourceUsesrcAddress  SourceUsesrc = "address"
	SourceUsesrcClient   SourceUsesrc = "client"
	SourceUsesrcClientip SourceUsesrc = "clientip"
	SourceUsesrcHdrIp    SourceUsesrc = "hdr_ip"
)

// Defines values for SpoeAgentAsync.
const (
	SpoeAgentAsyncDisabled SpoeAgentAsync = "disabled"
	SpoeAgentAsyncEnabled  SpoeAgentAsync = "enabled"
)

// Defines values for SpoeAgentContinueOnError.
const (
	SpoeAgentContinueOnErrorEnabled SpoeAgentContinueOnError = "enabled"
)

// Defines values for SpoeAgentDontlogNormal.
const (
	SpoeAgentDontlogNormalDisabled SpoeAgentDontlogNormal = "disabled"
	SpoeAgentDontlogNormalEnabled  SpoeAgentDontlogNormal = "enabled"
)

// Defines values for SpoeAgentForceSetVar.
const (
	SpoeAgentForceSetVarEnabled SpoeAgentForceSetVar = "enabled"
)

// Defines values for SpoeAgentPipelining.
const (
	SpoeAgentPipeliningDisabled SpoeAgentPipelining = "disabled"
	SpoeAgentPipeliningEnabled  SpoeAgentPipelining = "enabled"
)

// Defines values for SpoeAgentSendFragPayload.
const (
	SpoeAgentSendFragPayloadDisabled SpoeAgentSendFragPayload = "disabled"
	SpoeAgentSendFragPayloadEnabled  SpoeAgentSendFragPayload = "enabled"
)

// Defines values for SpoeMessageEventCond.
const (
	SpoeMessageEventCondIf     SpoeMessageEventCond = "if"
	SpoeMessageEventCondUnless SpoeMessageEventCond = "unless"
)

// Defines values for SpoeMessageEventName.
const (
	SpoeMessageEventNameOnBackendHttpRequest  SpoeMessageEventName = "on-backend-http-request"
	SpoeMessageEventNameOnBackendTcpRequest   SpoeMessageEventName = "on-backend-tcp-request"
	SpoeMessageEventNameOnClientSession       SpoeMessageEventName = "on-client-session"
	SpoeMessageEventNameOnFrontendHttpRequest SpoeMessageEventName = "on-frontend-http-request"
	SpoeMessageEventNameOnFrontendTcpRequest  SpoeMessageEventName = "on-frontend-tcp-request"
	SpoeMessageEventNameOnHttpResponse        SpoeMessageEventName = "on-http-response"
	SpoeMessageEventNameOnServerSession       SpoeMessageEventName = "on-server-session"
	SpoeMessageEventNameOnTcpResponse         SpoeMessageEventName = "on-tcp-response"
)

// Defines values for SpoeTransactionStatus.
const (
	SpoeTransactionStatusFailed     SpoeTransactionStatus = "failed"
	SpoeTransactionStatusInProgress SpoeTransactionStatus = "in_progress"
	SpoeTransactionStatusSuccess    SpoeTransactionStatus = "success"
)

// Defines values for SslOptionsModeAsync.
const (
	SslOptionsModeAsyncDisabled SslOptionsModeAsync = "disabled"
	SslOptionsModeAsyncEnabled  SslOptionsModeAsync = "enabled"
)

// Defines values for SslOptionsServerVerify.
const (
	SslOptionsServerVerifyNone     SslOptionsServerVerify = "none"
	SslOptionsServerVerifyRequired SslOptionsServerVerify = "required"
)

// Defines values for StatsHttpRequestType.
const (
	StatsHttpRequestTypeAllow StatsHttpRequestType = "allow"
	StatsHttpRequestTypeAuth  StatsHttpRequestType = "auth"
	StatsHttpRequestTypeDeny  StatsHttpRequestType = "deny"
)

// Defines values for StatsOptionsStatsAdminCond.
const (
	StatsOptionsStatsAdminCondIf     StatsOptionsStatsAdminCond = "if"
	StatsOptionsStatsAdminCondUnless StatsOptionsStatsAdminCond = "unless"
)

// Defines values for StickRuleCond.
const (
	StickRuleCondIf     StickRuleCond = "if"
	StickRuleCondUnless StickRuleCond = "unless"
)

// Defines values for StickRuleType.
const (
	StickRuleTypeMatch         StickRuleType = "match"
	StickRuleTypeOn            StickRuleType = "on"
	StickRuleTypeStoreRequest  StickRuleType = "store-request"
	StickRuleTypeStoreResponse StickRuleType = "store-response"
)

// Defines values for StickTableFieldsField.
const (
	StickTableFieldsFieldBytesInCnt   StickTableFieldsField = "bytes_in_cnt"
	StickTableFieldsFieldBytesInRate  StickTableFieldsField = "bytes_in_rate"
	StickTableFieldsFieldBytesOutCnt  StickTableFieldsField = "bytes_out_cnt"
	StickTableFieldsFieldBytesOutRate StickTableFieldsField = "bytes_out_rate"
	StickTableFieldsFieldConnCnt      StickTableFieldsField = "conn_cnt"
	StickTableFieldsFieldConnCur      StickTableFieldsField = "conn_cur"
	StickTableFieldsFieldConnRate     StickTableFieldsField = "conn_rate"
	StickTableFieldsFieldGlitchCnt    StickTableFieldsField = "glitch_cnt"
	StickTableFieldsFieldGlitchRate   StickTableFieldsField = "glitch_rate"
	StickTableFieldsFieldGpc          StickTableFieldsField = "gpc"
	StickTableFieldsFieldGpc0         StickTableFieldsField = "gpc0"
	StickTableFieldsFieldGpc0Rate     StickTableFieldsField = "gpc0_rate"
	StickTableFieldsFieldGpc1         StickTableFieldsField = "gpc1"
	StickTableFieldsFieldGpc1Rate     StickTableFieldsField = "gpc1_rate"
	StickTableFieldsFieldGpcRate      StickTableFieldsField = "gpc_rate"
	StickTableFieldsFieldGpt          StickTableFieldsField = "gpt"
	StickTableFieldsFieldGpt0         StickTableFieldsField = "gpt0"
	StickTableFieldsFieldHttpErrCnt   StickTableFieldsField = "http_err_cnt"
	StickTableFieldsFieldHttpErrRate  StickTableFieldsField = "http_err_rate"
	StickTableFieldsFieldHttpFailCnt  StickTableFieldsField = "http_fail_cnt"
	StickTableFieldsFieldHttpFailRate StickTableFieldsField = "http_fail_rate"
	StickTableFieldsFieldHttpReqCnt   StickTableFieldsField = "http_req_cnt"
	StickTableFieldsFieldHttpReqRate  StickTableFieldsField = "http_req_rate"
	StickTableFieldsFieldServerId     StickTableFieldsField = "server_id"
	StickTableFieldsFieldSessCnt      StickTableFieldsField = "sess_cnt"
	StickTableFieldsFieldSessRate     StickTableFieldsField = "sess_rate"
)

// Defines values for StickTableFieldsType.
const (
	StickTableFieldsTypeCounter StickTableFieldsType = "counter"
	StickTableFieldsTypeRate    StickTableFieldsType = "rate"
)

// Defines values for StickTableType.
const (
	StickTableTypeBinary  StickTableType = "binary"
	StickTableTypeInteger StickTableType = "integer"
	StickTableTypeIp      StickTableType = "ip"
	StickTableTypeIpv6    StickTableType = "ipv6"
	StickTableTypeString  StickTableType = "string"
)

// Defines values for TableType.
const (
	TableTypeBinary  TableType = "binary"
	TableTypeInteger TableType = "integer"
	TableTypeIp      TableType = "ip"
	TableTypeString  TableType = "string"
)

// Defines values for TcpCheckAction.
const (
	TcpCheckActionComment      TcpCheckAction = "comment"
	TcpCheckActionConnect      TcpCheckAction = "connect"
	TcpCheckActionExpect       TcpCheckAction = "expect"
	TcpCheckActionSend         TcpCheckAction = "send"
	TcpCheckActionSendBinary   TcpCheckAction = "send-binary"
	TcpCheckActionSendBinaryLf TcpCheckAction = "send-binary-lf"
	TcpCheckActionSendLf       TcpCheckAction = "send-lf"
	TcpCheckActionSetVar       TcpCheckAction = "set-var"
	TcpCheckActionSetVarFmt    TcpCheckAction = "set-var-fmt"
	TcpCheckActionUnsetVar     TcpCheckAction = "unset-var"
)

// Defines values for TcpCheckErrorStatus.
const (
	TcpCheckErrorStatusL4CON TcpCheckErrorStatus = "L4CON"
	TcpCheckErrorStatusL6RSP TcpCheckErrorStatus = "L6RSP"
	TcpCheckErrorStatusL7OKC TcpCheckErrorStatus = "L7OKC"
	TcpCheckErrorStatusL7RSP TcpCheckErrorStatus = "L7RSP"
	TcpCheckErrorStatusL7STS TcpCheckErrorStatus = "L7STS"
)

// Defines values for TcpCheckMatch.
const (
	TcpCheckMatchBinary   TcpCheckMatch = "binary"
	TcpCheckMatchBinaryLf TcpCheckMatch = "binary-lf"
	TcpCheckMatchRbinary  TcpCheckMatch = "rbinary"
	TcpCheckMatchRstring  TcpCheckMatch = "rstring"
	TcpCheckMatchString   TcpCheckMatch = "string"
	TcpCheckMatchStringLf TcpCheckMatch = "string-lf"
)

// Defines values for TcpCheckOkStatus.
const (
	TcpCheckOkStatusL4OK  TcpCheckOkStatus = "L4OK"
	TcpCheckOkStatusL6OK  TcpCheckOkStatus = "L6OK"
	TcpCheckOkStatusL7OK  TcpCheckOkStatus = "L7OK"
	TcpCheckOkStatusL7OKC TcpCheckOkStatus = "L7OKC"
)

// Defines values for TcpCheckToutStatus.
const (
	TcpCheckToutStatusL4TOUT TcpCheckToutStatus = "L4TOUT"
	TcpCheckToutStatusL6TOUT TcpCheckToutStatus = "L6TOUT"
	TcpCheckToutStatusL7TOUT TcpCheckToutStatus = "L7TOUT"
)

// Defines values for TcpRequestRuleAction.
const (
	TcpRequestRuleActionAccept             TcpRequestRuleAction = "accept"
	TcpRequestRuleActionAttachSrv          TcpRequestRuleAction = "attach-srv"
	TcpRequestRuleActionCapture            TcpRequestRuleAction = "capture"
	TcpRequestRuleActionDoLog              TcpRequestRuleAction = "do-log"
	TcpRequestRuleActionDoResolve          TcpRequestRuleAction = "do-resolve"
	TcpRequestRuleActionExpectNetscalerCip TcpRequestRuleAction = "expect-netscaler-cip"
	TcpRequestRuleActionExpectProxy        TcpRequestRuleAction = "expect-proxy"
	TcpRequestRuleActionLua                TcpRequestRuleAction = "lua"
	TcpRequestRuleActionReject             TcpRequestRuleAction = "reject"
	TcpRequestRuleActionScAddGpc           TcpRequestRuleAction = "sc-add-gpc"
	TcpRequestRuleActionScIncGpc           TcpRequestRuleAction = "sc-inc-gpc"
	TcpRequestRuleActionScIncGpc0          TcpRequestRuleAction = "sc-inc-gpc0"
	TcpRequestRuleActionScIncGpc1          TcpRequestRuleAction = "sc-inc-gpc1"
	TcpRequestRuleActionScSetGpt           TcpRequestRuleAction = "sc-set-gpt"
	TcpRequestRuleActionScSetGpt0          TcpRequestRuleAction = "sc-set-gpt0"
	TcpRequestRuleActionSendSpoeGroup      TcpRequestRuleAction = "send-spoe-group"
	TcpRequestRuleActionSetBandwidthLimit  TcpRequestRuleAction = "set-bandwidth-limit"
	TcpRequestRuleActionSetBcMark          TcpRequestRuleAction = "set-bc-mark"
	TcpRequestRuleActionSetBcTos           TcpRequestRuleAction = "set-bc-tos"
	TcpRequestRuleActionSetDst             TcpRequestRuleAction = "set-dst"
	TcpRequestRuleActionSetDstPort         TcpRequestRuleAction = "set-dst-port"
	TcpRequestRuleActionSetFcMark          TcpRequestRuleAction = "set-fc-mark"
	TcpRequestRuleActionSetFcTos           TcpRequestRuleAction = "set-fc-tos"
	TcpRequestRuleActionSetLogLevel        TcpRequestRuleAction = "set-log-level"
	TcpRequestRuleActionSetMark            TcpRequestRuleAction = "set-mark"
	TcpRequestRuleActionSetNice            TcpRequestRuleAction = "set-nice"
	TcpRequestRuleActionSetPriorityClass   TcpRequestRuleAction = "set-priority-class"
	TcpRequestRuleActionSetPriorityOffset  TcpRequestRuleAction = "set-priority-offset"
	TcpRequestRuleActionSetRetries         TcpRequestRuleAction = "set-retries"
	TcpRequestRuleActionSetSrc             TcpRequestRuleAction = "set-src"
	TcpRequestRuleActionSetSrcPort         TcpRequestRuleAction = "set-src-port"
	TcpRequestRuleActionSetTos             TcpRequestRuleAction = "set-tos"
	TcpRequestRuleActionSetVar             TcpRequestRuleAction = "set-var"
	TcpRequestRuleActionSetVarFmt          TcpRequestRuleAction = "set-var-fmt"
	TcpRequestRuleActionSilentDrop         TcpRequestRuleAction = "silent-drop"
	TcpRequestRuleActionSwitchMode         TcpRequestRuleAction = "switch-mode"
	TcpRequestRuleActionTrackSc            TcpRequestRuleAction = "track-sc"
	TcpRequestRuleActionUnsetVar           TcpRequestRuleAction = "unset-var"
	TcpRequestRuleActionUseService         TcpRequestRuleAction = "use-service"
)

// Defines values for TcpRequestRuleCond.
const (
	TcpRequestRuleCondIf     TcpRequestRuleCond = "if"
	TcpRequestRuleCondUnless TcpRequestRuleCond = "unless"
)

// Defines values for TcpRequestRuleLogLevel.
const (
	TcpRequestRuleLogLevelAlert   TcpRequestRuleLogLevel = "alert"
	TcpRequestRuleLogLevelCrit    TcpRequestRuleLogLevel = "crit"
	TcpRequestRuleLogLevelDebug   TcpRequestRuleLogLevel = "debug"
	TcpRequestRuleLogLevelEmerg   TcpRequestRuleLogLevel = "emerg"
	TcpRequestRuleLogLevelErr     TcpRequestRuleLogLevel = "err"
	TcpRequestRuleLogLevelInfo    TcpRequestRuleLogLevel = "info"
	TcpRequestRuleLogLevelNotice  TcpRequestRuleLogLevel = "notice"
	TcpRequestRuleLogLevelSilent  TcpRequestRuleLogLevel = "silent"
	TcpRequestRuleLogLevelWarning TcpRequestRuleLogLevel = "warning"
)

// Defines values for TcpRequestRuleResolveProtocol.
const (
	TcpRequestRuleResolveProtocolIpv4 TcpRequestRuleResolveProtocol = "ipv4"
	TcpRequestRuleResolveProtocolIpv6 TcpRequestRuleResolveProtocol = "ipv6"
)

// Defines values for TcpRequestRuleType.
const (
	TcpRequestRuleTypeConnection   TcpRequestRuleType = "connection"
	TcpRequestRuleTypeContent      TcpRequestRuleType = "content"
	TcpRequestRuleTypeInspectDelay TcpRequestRuleType = "inspect-delay"
	TcpRequestRuleTypeSession      TcpRequestRuleType = "session"
)

// Defines values for TcpResponseRuleAction.
const (
	TcpResponseRuleActionAccept            TcpResponseRuleAction = "accept"
	TcpResponseRuleActionClose             TcpResponseRuleAction = "close"
	TcpResponseRuleActionDoLog             TcpResponseRuleAction = "do-log"
	TcpResponseRuleActionLua               TcpResponseRuleAction = "lua"
	TcpResponseRuleActionReject            TcpResponseRuleAction = "reject"
	TcpResponseRuleActionScAddGpc          TcpResponseRuleAction = "sc-add-gpc"
	TcpResponseRuleActionScIncGpc          TcpResponseRuleAction = "sc-inc-gpc"
	TcpResponseRuleActionScIncGpc0         TcpResponseRuleAction = "sc-inc-gpc0"
	TcpResponseRuleActionScIncGpc1         TcpResponseRuleAction = "sc-inc-gpc1"
	TcpResponseRuleActionScSetGpt          TcpResponseRuleAction = "sc-set-gpt"
	TcpResponseRuleActionScSetGpt0         TcpResponseRuleAction = "sc-set-gpt0"
	TcpResponseRuleActionSendSpoeGroup     TcpResponseRuleAction = "send-spoe-group"
	TcpResponseRuleActionSetBandwidthLimit TcpResponseRuleAction = "set-bandwidth-limit"
	TcpResponseRuleActionSetFcMark         TcpResponseRuleAction = "set-fc-mark"
	TcpResponseRuleActionSetFcTos          TcpResponseRuleAction = "set-fc-tos"
	TcpResponseRuleActionSetLogLevel       TcpResponseRuleAction = "set-log-level"
	TcpResponseRuleActionSetMark           TcpResponseRuleAction = "set-mark"
	TcpResponseRuleActionSetNice           TcpResponseRuleAction = "set-nice"
	TcpResponseRuleActionSetTos            TcpResponseRuleAction = "set-tos"
	TcpResponseRuleActionSetVar            TcpResponseRuleAction = "set-var"
	TcpResponseRuleActionSetVarFmt         TcpResponseRuleAction = "set-var-fmt"
	TcpResponseRuleActionSilentDrop        TcpResponseRuleAction = "silent-drop"
	TcpResponseRuleActionUnsetVar          TcpResponseRuleAction = "unset-var"
)

// Defines values for TcpResponseRuleCond.
const (
	TcpResponseRuleCondIf     TcpResponseRuleCond = "if"
	TcpResponseRuleCondUnless TcpResponseRuleCond = "unless"
)

// Defines values for TcpResponseRuleLogLevel.
const (
	TcpResponseRuleLogLevelAlert   TcpResponseRuleLogLevel = "alert"
	TcpResponseRuleLogLevelCrit    TcpResponseRuleLogLevel = "crit"
	TcpResponseRuleLogLevelDebug   TcpResponseRuleLogLevel = "debug"
	TcpResponseRuleLogLevelEmerg   TcpResponseRuleLogLevel = "emerg"
	TcpResponseRuleLogLevelErr     TcpResponseRuleLogLevel = "err"
	TcpResponseRuleLogLevelInfo    TcpResponseRuleLogLevel = "info"
	TcpResponseRuleLogLevelNotice  TcpResponseRuleLogLevel = "notice"
	TcpResponseRuleLogLevelSilent  TcpResponseRuleLogLevel = "silent"
	TcpResponseRuleLogLevelWarning TcpResponseRuleLogLevel = "warning"
)

// Defines values for TcpResponseRuleType.
const (
	TcpResponseRuleTypeContent      TcpResponseRuleType = "content"
	TcpResponseRuleTypeInspectDelay TcpResponseRuleType = "inspect-delay"
)

// Defines values for TransactionStatus.
const (
	TransactionStatusFailed     TransactionStatus = "failed"
	TransactionStatusInProgress TransactionStatus = "in_progress"
	TransactionStatusOutdated   TransactionStatus = "outdated"
	TransactionStatusSuccess    TransactionStatus = "success"
)

// Defines values for TuneLuaOptionsLogLoggers.
const (
	TuneLuaOptionsLogLoggersDisabled TuneLuaOptionsLogLoggers = "disabled"
	TuneLuaOptionsLogLoggersEnabled  TuneLuaOptionsLogLoggers = "enabled"
)

// Defines values for TuneLuaOptionsLogStderr.
const (
	TuneLuaOptionsLogStderrAuto     TuneLuaOptionsLogStderr = "auto"
	TuneLuaOptionsLogStderrDisabled TuneLuaOptionsLogStderr = "disabled"
	TuneLuaOptionsLogStderrEnabled  TuneLuaOptionsLogStderr = "enabled"
)

// Defines values for TuneOptionsAppletZeroCopyForwarding.
const (
	TuneOptionsAppletZeroCopyForwardingDisabled TuneOptionsAppletZeroCopyForwarding = "disabled"
	TuneOptionsAppletZeroCopyForwardingEnabled  TuneOptionsAppletZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsFdEdgeTriggered.
const (
	TuneOptionsFdEdgeTriggeredDisabled TuneOptionsFdEdgeTriggered = "disabled"
	TuneOptionsFdEdgeTriggeredEnabled  TuneOptionsFdEdgeTriggered = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdRecv.
const (
	TuneOptionsH1ZeroCopyFwdRecvDisabled TuneOptionsH1ZeroCopyFwdRecv = "disabled"
	TuneOptionsH1ZeroCopyFwdRecvEnabled  TuneOptionsH1ZeroCopyFwdRecv = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdSend.
const (
	TuneOptionsH1ZeroCopyFwdSendDisabled TuneOptionsH1ZeroCopyFwdSend = "disabled"
	TuneOptionsH1ZeroCopyFwdSendEnabled  TuneOptionsH1ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsH2ZeroCopyFwdSend.
const (
	TuneOptionsH2ZeroCopyFwdSendDisabled TuneOptionsH2ZeroCopyFwdSend = "disabled"
	TuneOptionsH2ZeroCopyFwdSendEnabled  TuneOptionsH2ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsIdlePoolShared.
const (
	TuneOptionsIdlePoolSharedDisabled TuneOptionsIdlePoolShared = "disabled"
	TuneOptionsIdlePoolSharedEnabled  TuneOptionsIdlePoolShared = "enabled"
)

// Defines values for TuneOptionsListenerDefaultShards.
const (
	TuneOptionsListenerDefaultShardsByGroup   TuneOptionsListenerDefaultShards = "by-group"
	TuneOptionsListenerDefaultShardsByProcess TuneOptionsListenerDefaultShards = "by-process"
	TuneOptionsListenerDefaultShardsByThread  TuneOptionsListenerDefaultShards = "by-thread"
)

// Defines values for TuneOptionsListenerMultiQueue.
const (
	TuneOptionsListenerMultiQueueDisabled TuneOptionsListenerMultiQueue = "disabled"
	TuneOptionsListenerMultiQueueEnabled  TuneOptionsListenerMultiQueue = "enabled"
)

// Defines values for TuneOptionsPtZeroCopyForwarding.
const (
	TuneOptionsPtZeroCopyForwardingDisabled TuneOptionsPtZeroCopyForwarding = "disabled"
	TuneOptionsPtZeroCopyForwardingEnabled  TuneOptionsPtZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsSchedLowLatency.
const (
	TuneOptionsSchedLowLatencyDisabled TuneOptionsSchedLowLatency = "disabled"
	TuneOptionsSchedLowLatencyEnabled  TuneOptionsSchedLowLatency = "enabled"
)

// Defines values for TuneQuicOptionsSocketOwner.
const (
	TuneQuicOptionsSocketOwnerConnection TuneQuicOptionsSocketOwner = "connection"
	TuneQuicOptionsSocketOwnerListener   TuneQuicOptionsSocketOwner = "listener"
)

// Defines values for TuneQuicOptionsZeroCopyFwdSend.
const (
	TuneQuicOptionsZeroCopyFwdSendDisabled TuneQuicOptionsZeroCopyFwdSend = "disabled"
	TuneQuicOptionsZeroCopyFwdSendEnabled  TuneQuicOptionsZeroCopyFwdSend = "enabled"
)

// Defines values for TuneSslOptionsKeylog.
const (
	TuneSslOptionsKeylogDisabled TuneSslOptionsKeylog = "disabled"
	TuneSslOptionsKeylogEnabled  TuneSslOptionsKeylog = "enabled"
)

// Defines values for DeleteClusterParamsConfiguration.
const (
	DeleteClusterParamsConfigurationKeep DeleteClusterParamsConfiguration = "keep"
)

// Defines values for PostClusterParamsConfiguration.
const (
	PostClusterParamsConfigurationKeep PostClusterParamsConfiguration = "keep"
)

// Defines values for GetAllSpoeTransactionParamsStatus.
const (
	GetAllSpoeTransactionParamsStatusFailed     GetAllSpoeTransactionParamsStatus = "failed"
	GetAllSpoeTransactionParamsStatusInProgress GetAllSpoeTransactionParamsStatus = "in_progress"
)

// Defines values for GetStatsParamsType.
const (
	GetStatsParamsTypeBackend  GetStatsParamsType = "backend"
	GetStatsParamsTypeFrontend GetStatsParamsType = "frontend"
	GetStatsParamsTypeServer   GetStatsParamsType = "server"
)

// Defines values for GetTransactionsParamsStatus.
const (
	GetTransactionsParamsStatusFailed     GetTransactionsParamsStatus = "failed"
	GetTransactionsParamsStatusInProgress GetTransactionsParamsStatus = "in_progress"
)

// Acl The use of Access Control Lists (ACL) provides a flexible solution to perform
// content switching and generally to take decisions based on content extracted
// from the request, the response or any environmental status.
type Acl struct {
	AclName   string  `json:"acl_name"`
	Criterion string  `json:"criterion"`
	Value     *string `json:"value,omitempty"`
}

// AclFile ACL File
type AclFile struct {
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// AclFileEntry One ACL File Entry
type AclFileEntry struct {
	Id    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// AclFiles Array of runtime acl files
type AclFiles = []AclFile

// AclFilesEntries Array of entries of one runtime acl file
type AclFilesEntries = []AclFileEntry

// Acls HAProxy ACL lines array (corresponds to acl directives)
type Acls = []Acl

// AwsFilters defines model for awsFilters.
type AwsFilters struct {
	// Key Key to use as filter, using the format specified at https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html#options
	Key string `json:"key"`

	// Value Value of the filter to use
	Value string `json:"value"`
}

// AwsRegion AWS region configuration
type AwsRegion struct {
	// AccessKeyId AWS Access Key ID.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// Allowlist Specify the AWS filters used to filter the EC2 instances to add
	Allowlist *[]AwsFilters `json:"allowlist,omitempty"`

	// Denylist Specify the AWS filters used to filter the EC2 instances to ignore
	Denylist    *[]AwsFilters `json:"denylist,omitempty"`
	Description *string       `json:"description,omitempty"`
	Enabled     bool          `json:"enabled"`

	// Id Auto generated ID.
	Id *string `json:"id"`

	// Ipv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
	Ipv4Address AwsRegionIpv4Address `json:"ipv4_address"`
	Name        string               `json:"name"`
	Region      string               `json:"region"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the AWS region
	RetryTimeout int `json:"retry_timeout"`

	// SecretAccessKey AWS Secret Access Key.
	SecretAccessKey            *string                         `json:"secret_access_key,omitempty"`
	ServerSlotsBase            *int                            `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                            `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *AwsRegionServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
}

// AwsRegionIpv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
type AwsRegionIpv4Address string

// AwsRegionServerSlotsGrowthType defines model for AwsRegion.ServerSlotsGrowthType.
type AwsRegionServerSlotsGrowthType string

// AwsRegions AWS regions array
type AwsRegions = []AwsRegion

// Backend defines model for backend.
type Backend struct {
	Abortonclose                         *BackendAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse            *BackendAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *BackendAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList          *Acls              `json:"acl_list,omitempty"`
	AdvCheck         *BackendAdvCheck   `json:"adv_check,omitempty"`
	Allbackups       *BackendAllbackups `json:"allbackups,omitempty"`
	Balance          *Balance           `json:"balance,omitempty"`
	CheckTimeout     *int               `json:"check_timeout"`
	Checkcache       *BackendCheckcache `json:"checkcache,omitempty"`
	Compression      *Compression       `json:"compression,omitempty"`
	ConnectTimeout   *int               `json:"connect_timeout"`
	Cookie           *Cookie            `json:"cookie,omitempty"`
	DefaultServer    *DefaultServer     `json:"default_server,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Disabled         *bool              `json:"disabled,omitempty"`
	DynamicCookieKey *string            `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert           `json:"email_alert,omitempty"`
	Enabled                  *bool                 `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile          `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles         `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc             `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc             `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string               `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string               `json:"external_check_path,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList *Filters `json:"filter_list,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendForcePersistCond `json:"cond"`
		CondTest string                  `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendForcePersistListCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                     `json:"forwardfor,omitempty"`
	From                    *string                         `json:"from,omitempty"`
	Fullconn                *int                            `json:"fullconn"`
	Guid                    *string                         `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                            `json:"hash_balance_factor"`
	HashType                *HashType                       `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpNoDelay             *BackendHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendHttpUseHtx              `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules    `json:"http_after_response_rule_list,omitempty"`
	HttpCheckList             *HttpChecks                `json:"http_check_list,omitempty"`
	HttpConnectionMode        *BackendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules              `json:"http_error_rule_list,omitempty"`
	HttpKeepAliveTimeout *int                         `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive *BackendHttpPretendKeepalive `json:"http_pretend_keepalive,omitempty"`
	HttpProxy            *BackendHttpProxy            `json:"http_proxy,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules              `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *BackendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                         `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                  `json:"httpchk_params,omitempty"`
	Id                      *int                            `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendIgnorePersistCond `json:"cond"`
		CondTest string                   `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendIgnorePersistListCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                         `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList       *LogTargets              `json:"log_target_list,omitempty"`
	MaxKeepAliveQueue   *int                     `json:"max_keep_alive_queue"`
	Mode                *BackendMode             `json:"mode,omitempty"`
	MysqlCheckParams    *MysqlCheckParams        `json:"mysql_check_params,omitempty"`
	Name                string                   `json:"name"`
	Nolinger            *BackendNolinger         `json:"nolinger,omitempty"`
	Originalto          *Originalto              `json:"originalto,omitempty"`
	Persist             *BackendPersist          `json:"persist,omitempty"`
	PersistRule         *PersistRule             `json:"persist_rule,omitempty"`
	PgsqlCheckParams    *PgsqlCheckParams        `json:"pgsql_check_params,omitempty"`
	PreferLastServer    *BackendPreferLastServer `json:"prefer_last_server,omitempty"`
	QueueTimeout        *int                     `json:"queue_timeout"`
	Redispatch          *Redispatch              `json:"redispatch,omitempty"`
	Retries             *int                     `json:"retries"`
	RetryOn             *string                  `json:"retry_on,omitempty"`
	ServerFinTimeout    *int                     `json:"server_fin_timeout"`
	ServerStateFileName *string                  `json:"server_state_file_name,omitempty"`

	// ServerSwitchingRuleList HAProxy backend server switching rules array (corresponds to use-server directives)
	ServerSwitchingRuleList *ServerSwitchingRules      `json:"server_switching_rule_list,omitempty"`
	ServerTemplates         *map[string]ServerTemplate `json:"server_templates,omitempty"`
	ServerTimeout           *int                       `json:"server_timeout"`
	Servers                 *map[string]Server         `json:"servers,omitempty"`
	SmtpchkParams           *SmtpchkParams             `json:"smtpchk_params,omitempty"`
	Source                  *Source                    `json:"source,omitempty"`
	SpliceAuto              *BackendSpliceAuto         `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendSpliceRequest      `json:"splice_request,omitempty"`
	SpliceResponse          *BackendSpliceResponse     `json:"splice_response,omitempty"`
	SpopCheck               *BackendSpopCheck          `json:"spop_check,omitempty"`
	Srvtcpka                *BackendSrvtcpka           `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                       `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                       `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                       `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions              `json:"stats_options,omitempty"`

	// StickRuleList HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
	StickRuleList    *StickRules       `json:"stick_rule_list,omitempty"`
	StickTable       *ConfigStickTable `json:"stick_table,omitempty"`
	TarpitTimeout    *int              `json:"tarpit_timeout"`
	TcpCheckRuleList *TcpChecks        `json:"tcp_check_rule_list,omitempty"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules `json:"tcp_request_rule_list,omitempty"`

	// TcpResponseRuleList HAProxy TCP response rules array (corresponds to tcp-response directive)
	TcpResponseRuleList *TcpResponseRules       `json:"tcp_response_rule_list,omitempty"`
	TcpSmartConnect     *BackendTcpSmartConnect `json:"tcp_smart_connect,omitempty"`
	Tcpka               *BackendTcpka           `json:"tcpka,omitempty"`
	Transparent         *BackendTransparent     `json:"transparent,omitempty"`
	TunnelTimeout       *int                    `json:"tunnel_timeout"`
	UseFcgiApp          *string                 `json:"use_fcgi_app,omitempty"`
}

// BackendAbortonclose defines model for Backend.Abortonclose.
type BackendAbortonclose string

// BackendAcceptInvalidHttpResponse defines model for Backend.AcceptInvalidHttpResponse.
type BackendAcceptInvalidHttpResponse string

// BackendAcceptUnsafeViolationsInHttpResponse defines model for Backend.AcceptUnsafeViolationsInHttpResponse.
type BackendAcceptUnsafeViolationsInHttpResponse string

// BackendAdvCheck defines model for Backend.AdvCheck.
type BackendAdvCheck string

// BackendAllbackups defines model for Backend.Allbackups.
type BackendAllbackups string

// BackendCheckcache defines model for Backend.Checkcache.
type BackendCheckcache string

// BackendExternalCheck defines model for Backend.ExternalCheck.
type BackendExternalCheck string

// BackendForcePersistCond defines model for Backend.ForcePersist.Cond.
type BackendForcePersistCond string

// BackendForcePersistListCond defines model for Backend.ForcePersistList.Cond.
type BackendForcePersistListCond string

// BackendH1CaseAdjustBogusServer defines model for Backend.H1CaseAdjustBogusServer.
type BackendH1CaseAdjustBogusServer string

// BackendHttpBufferRequest defines model for Backend.HttpBufferRequest.
type BackendHttpBufferRequest string

// BackendHttpNoDelay defines model for Backend.HttpNoDelay.
type BackendHttpNoDelay string

// BackendHttpUseHtx defines model for Backend.HttpUseHtx.
type BackendHttpUseHtx string

// BackendHttpConnectionMode defines model for Backend.HttpConnectionMode.
type BackendHttpConnectionMode string

// BackendHttpPretendKeepalive defines model for Backend.HttpPretendKeepalive.
type BackendHttpPretendKeepalive string

// BackendHttpProxy defines model for Backend.HttpProxy.
type BackendHttpProxy string

// BackendHttpRestrictReqHdrNames defines model for Backend.HttpRestrictReqHdrNames.
type BackendHttpRestrictReqHdrNames string

// BackendHttpReuse defines model for Backend.HttpReuse.
type BackendHttpReuse string

// BackendIgnorePersistCond defines model for Backend.IgnorePersist.Cond.
type BackendIgnorePersistCond string

// BackendIgnorePersistListCond defines model for Backend.IgnorePersistList.Cond.
type BackendIgnorePersistListCond string

// BackendIndependentStreams defines model for Backend.IndependentStreams.
type BackendIndependentStreams string

// BackendLoadServerStateFromFile defines model for Backend.LoadServerStateFromFile.
type BackendLoadServerStateFromFile string

// BackendLogHealthChecks defines model for Backend.LogHealthChecks.
type BackendLogHealthChecks string

// BackendMode defines model for Backend.Mode.
type BackendMode string

// BackendNolinger defines model for Backend.Nolinger.
type BackendNolinger string

// BackendPersist defines model for Backend.Persist.
type BackendPersist string

// BackendPreferLastServer defines model for Backend.PreferLastServer.
type BackendPreferLastServer string

// BackendSpliceAuto defines model for Backend.SpliceAuto.
type BackendSpliceAuto string

// BackendSpliceRequest defines model for Backend.SpliceRequest.
type BackendSpliceRequest string

// BackendSpliceResponse defines model for Backend.SpliceResponse.
type BackendSpliceResponse string

// BackendSpopCheck defines model for Backend.SpopCheck.
type BackendSpopCheck string

// BackendSrvtcpka defines model for Backend.Srvtcpka.
type BackendSrvtcpka string

// BackendTcpSmartConnect defines model for Backend.TcpSmartConnect.
type BackendTcpSmartConnect string

// BackendTcpka defines model for Backend.Tcpka.
type BackendTcpka string

// BackendTransparent defines model for Backend.Transparent.
type BackendTransparent string

// BackendBase HAProxy backend configuration
type BackendBase struct {
	Abortonclose                         *BackendBaseAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse            *BackendBaseAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *BackendBaseAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`
	AdvCheck                             *BackendBaseAdvCheck                             `json:"adv_check,omitempty"`
	Allbackups                           *BackendBaseAllbackups                           `json:"allbackups,omitempty"`
	Balance                              *Balance                                         `json:"balance,omitempty"`
	CheckTimeout                         *int                                             `json:"check_timeout"`
	Checkcache                           *BackendBaseCheckcache                           `json:"checkcache,omitempty"`
	Compression                          *Compression                                     `json:"compression,omitempty"`
	ConnectTimeout                       *int                                             `json:"connect_timeout"`
	Cookie                               *Cookie                                          `json:"cookie,omitempty"`
	DefaultServer                        *DefaultServer                                   `json:"default_server,omitempty"`
	Description                          *string                                          `json:"description,omitempty"`
	Disabled                             *bool                                            `json:"disabled,omitempty"`
	DynamicCookieKey                     *string                                          `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert               `json:"email_alert,omitempty"`
	Enabled                  *bool                     `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile              `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles             `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                 `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                 `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendBaseExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                   `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                   `json:"external_check_path,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendBaseForcePersistCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendBaseForcePersistListCond `json:"cond"`
		CondTest string                          `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                         `json:"forwardfor,omitempty"`
	From                    *string                             `json:"from,omitempty"`
	Fullconn                *int                                `json:"fullconn"`
	Guid                    *string                             `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendBaseH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                                `json:"hash_balance_factor"`
	HashType                *HashType                           `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpNoDelay             *BackendBaseHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode      *BackendBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpKeepAliveTimeout    *int                                `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive    *BackendBaseHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpProxy               *BackendBaseHttpProxy               `json:"http_proxy,omitempty"`
	HttpRequestTimeout      *int                                `json:"http_request_timeout"`
	HttpRestrictReqHdrNames *BackendBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendBaseHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                             `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                      `json:"httpchk_params,omitempty"`
	Id                      *int                                `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendBaseIgnorePersistCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendBaseIgnorePersistListCond `json:"cond"`
		CondTest string                           `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendBaseLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendBaseLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                             `json:"log_tag,omitempty"`
	MaxKeepAliveQueue       *int                                `json:"max_keep_alive_queue"`
	Mode                    *BackendBaseMode                    `json:"mode,omitempty"`
	MysqlCheckParams        *MysqlCheckParams                   `json:"mysql_check_params,omitempty"`
	Name                    string                              `json:"name"`
	Nolinger                *BackendBaseNolinger                `json:"nolinger,omitempty"`
	Originalto              *Originalto                         `json:"originalto,omitempty"`
	Persist                 *BackendBasePersist                 `json:"persist,omitempty"`
	PersistRule             *PersistRule                        `json:"persist_rule,omitempty"`
	PgsqlCheckParams        *PgsqlCheckParams                   `json:"pgsql_check_params,omitempty"`
	PreferLastServer        *BackendBasePreferLastServer        `json:"prefer_last_server,omitempty"`
	QueueTimeout            *int                                `json:"queue_timeout"`
	Redispatch              *Redispatch                         `json:"redispatch,omitempty"`
	Retries                 *int                                `json:"retries"`
	RetryOn                 *string                             `json:"retry_on,omitempty"`
	ServerFinTimeout        *int                                `json:"server_fin_timeout"`
	ServerStateFileName     *string                             `json:"server_state_file_name,omitempty"`
	ServerTimeout           *int                                `json:"server_timeout"`
	SmtpchkParams           *SmtpchkParams                      `json:"smtpchk_params,omitempty"`
	Source                  *Source                             `json:"source,omitempty"`
	SpliceAuto              *BackendBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse          *BackendBaseSpliceResponse          `json:"splice_response,omitempty"`
	SpopCheck               *BackendBaseSpopCheck               `json:"spop_check,omitempty"`
	Srvtcpka                *BackendBaseSrvtcpka                `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                                `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                                `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                                `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions                       `json:"stats_options,omitempty"`
	StickTable              *ConfigStickTable                   `json:"stick_table,omitempty"`
	TarpitTimeout           *int                                `json:"tarpit_timeout"`
	TcpSmartConnect         *BackendBaseTcpSmartConnect         `json:"tcp_smart_connect,omitempty"`
	Tcpka                   *BackendBaseTcpka                   `json:"tcpka,omitempty"`
	Transparent             *BackendBaseTransparent             `json:"transparent,omitempty"`
	TunnelTimeout           *int                                `json:"tunnel_timeout"`
	UseFcgiApp              *string                             `json:"use_fcgi_app,omitempty"`
}

// BackendBaseAbortonclose defines model for BackendBase.Abortonclose.
type BackendBaseAbortonclose string

// BackendBaseAcceptInvalidHttpResponse defines model for BackendBase.AcceptInvalidHttpResponse.
type BackendBaseAcceptInvalidHttpResponse string

// BackendBaseAcceptUnsafeViolationsInHttpResponse defines model for BackendBase.AcceptUnsafeViolationsInHttpResponse.
type BackendBaseAcceptUnsafeViolationsInHttpResponse string

// BackendBaseAdvCheck defines model for BackendBase.AdvCheck.
type BackendBaseAdvCheck string

// BackendBaseAllbackups defines model for BackendBase.Allbackups.
type BackendBaseAllbackups string

// BackendBaseCheckcache defines model for BackendBase.Checkcache.
type BackendBaseCheckcache string

// BackendBaseExternalCheck defines model for BackendBase.ExternalCheck.
type BackendBaseExternalCheck string

// BackendBaseForcePersistCond defines model for BackendBase.ForcePersist.Cond.
type BackendBaseForcePersistCond string

// BackendBaseForcePersistListCond defines model for BackendBase.ForcePersistList.Cond.
type BackendBaseForcePersistListCond string

// BackendBaseH1CaseAdjustBogusServer defines model for BackendBase.H1CaseAdjustBogusServer.
type BackendBaseH1CaseAdjustBogusServer string

// BackendBaseHttpBufferRequest defines model for BackendBase.HttpBufferRequest.
type BackendBaseHttpBufferRequest string

// BackendBaseHttpNoDelay defines model for BackendBase.HttpNoDelay.
type BackendBaseHttpNoDelay string

// BackendBaseHttpUseHtx defines model for BackendBase.HttpUseHtx.
type BackendBaseHttpUseHtx string

// BackendBaseHttpConnectionMode defines model for BackendBase.HttpConnectionMode.
type BackendBaseHttpConnectionMode string

// BackendBaseHttpPretendKeepalive defines model for BackendBase.HttpPretendKeepalive.
type BackendBaseHttpPretendKeepalive string

// BackendBaseHttpProxy defines model for BackendBase.HttpProxy.
type BackendBaseHttpProxy string

// BackendBaseHttpRestrictReqHdrNames defines model for BackendBase.HttpRestrictReqHdrNames.
type BackendBaseHttpRestrictReqHdrNames string

// BackendBaseHttpReuse defines model for BackendBase.HttpReuse.
type BackendBaseHttpReuse string

// BackendBaseIgnorePersistCond defines model for BackendBase.IgnorePersist.Cond.
type BackendBaseIgnorePersistCond string

// BackendBaseIgnorePersistListCond defines model for BackendBase.IgnorePersistList.Cond.
type BackendBaseIgnorePersistListCond string

// BackendBaseIndependentStreams defines model for BackendBase.IndependentStreams.
type BackendBaseIndependentStreams string

// BackendBaseLoadServerStateFromFile defines model for BackendBase.LoadServerStateFromFile.
type BackendBaseLoadServerStateFromFile string

// BackendBaseLogHealthChecks defines model for BackendBase.LogHealthChecks.
type BackendBaseLogHealthChecks string

// BackendBaseMode defines model for BackendBase.Mode.
type BackendBaseMode string

// BackendBaseNolinger defines model for BackendBase.Nolinger.
type BackendBaseNolinger string

// BackendBasePersist defines model for BackendBase.Persist.
type BackendBasePersist string

// BackendBasePreferLastServer defines model for BackendBase.PreferLastServer.
type BackendBasePreferLastServer string

// BackendBaseSpliceAuto defines model for BackendBase.SpliceAuto.
type BackendBaseSpliceAuto string

// BackendBaseSpliceRequest defines model for BackendBase.SpliceRequest.
type BackendBaseSpliceRequest string

// BackendBaseSpliceResponse defines model for BackendBase.SpliceResponse.
type BackendBaseSpliceResponse string

// BackendBaseSpopCheck defines model for BackendBase.SpopCheck.
type BackendBaseSpopCheck string

// BackendBaseSrvtcpka defines model for BackendBase.Srvtcpka.
type BackendBaseSrvtcpka string

// BackendBaseTcpSmartConnect defines model for BackendBase.TcpSmartConnect.
type BackendBaseTcpSmartConnect string

// BackendBaseTcpka defines model for BackendBase.Tcpka.
type BackendBaseTcpka string

// BackendBaseTransparent defines model for BackendBase.Transparent.
type BackendBaseTransparent string

// BackendSwitchingRule HAProxy backend switching rule configuration (corresponds to use_backend directive)
type BackendSwitchingRule struct {
	Cond     *BackendSwitchingRuleCond `json:"cond,omitempty"`
	CondTest *string                   `json:"cond_test,omitempty"`
	Name     string                    `json:"name"`
}

// BackendSwitchingRuleCond defines model for BackendSwitchingRule.Cond.
type BackendSwitchingRuleCond string

// BackendSwitchingRules HAProxy backend switching rules array (corresponds to use_backend directives)
type BackendSwitchingRules = []BackendSwitchingRule

// Backends HAProxy backends array
type Backends = []Backend

// Balance defines model for balance.
type Balance struct {
	Algorithm         BalanceAlgorithm `json:"algorithm"`
	HashExpression    *string          `json:"hash_expression,omitempty"`
	HdrName           *string          `json:"hdr_name,omitempty"`
	HdrUseDomainOnly  *bool            `json:"hdr_use_domain_only,omitempty"`
	RandomDraws       *int             `json:"random_draws,omitempty"`
	RdpCookieName     *string          `json:"rdp_cookie_name,omitempty"`
	UriDepth          *int             `json:"uri_depth,omitempty"`
	UriLen            *int             `json:"uri_len,omitempty"`
	UriPathOnly       *bool            `json:"uri_path_only,omitempty"`
	UriWhole          *bool            `json:"uri_whole,omitempty"`
	UrlParam          *string          `json:"url_param,omitempty"`
	UrlParamCheckPost *int             `json:"url_param_check_post,omitempty"`
	UrlParamMaxWait   *int             `json:"url_param_max_wait,omitempty"`
}

// BalanceAlgorithm defines model for Balance.Algorithm.
type BalanceAlgorithm string

// Bind defines model for bind.
type Bind struct {
	AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
	Address            *string   `json:"address,omitempty"`
	Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
	Alpn               *string   `json:"alpn,omitempty"`
	Backlog            *string   `json:"backlog,omitempty"`
	CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
	CaSignFile         *string   `json:"ca_sign_file,omitempty"`
	CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
	Ciphers            *string   `json:"ciphers,omitempty"`
	Ciphersuites       *string   `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
	CrlFile            *string   `json:"crl_file,omitempty"`
	CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
	CrtList            *string   `json:"crt_list,omitempty"`
	Curves             *string   `json:"curves,omitempty"`
	DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
	DeferAccept        *bool     `json:"defer_accept,omitempty"`
	Ecdhe              *string   `json:"ecdhe,omitempty"`
	ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *bool `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13          *bool      `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool      `json:"generate_certificates,omitempty"`
	Gid                  *int       `json:"gid,omitempty"`
	Group                *string    `json:"group,omitempty"`
	GuidPrefix           *string    `json:"guid_prefix,omitempty"`
	Id                   *string    `json:"id,omitempty"`
	Interface            *string    `json:"interface,omitempty"`
	Level                *BindLevel `json:"level,omitempty"`
	Maxconn              *int       `json:"maxconn,omitempty"`
	Mode                 *string    `json:"mode,omitempty"`
	Mss                  *string    `json:"mss,omitempty"`
	Name                 *string    `json:"name,omitempty"`
	Namespace            *string    `json:"namespace,omitempty"`
	Nbconn               *int       `json:"nbconn,omitempty"`
	Nice                 *int       `json:"nice,omitempty"`
	NoAlpn               *bool      `json:"no_alpn,omitempty"`
	NoCaNames            *bool      `json:"no_ca_names,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3      *bool `json:"no_sslv3,omitempty"`
	NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	NoTlsv13            *bool               `json:"no_tlsv13,omitempty"`
	Npn                 *string             `json:"npn,omitempty"`
	Port                *int                `json:"port"`
	PortRangeEnd        *int                `json:"port-range-end"`
	PreferClientCiphers *bool               `json:"prefer_client_ciphers,omitempty"`
	Proto               *string             `json:"proto,omitempty"`
	QuicCcAlgo          *BindQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry      *bool               `json:"quic-force-retry,omitempty"`
	QuicSocket          *BindQuicSocket     `json:"quic-socket,omitempty"`
	QuicCcAlgoBurstSize *int                `json:"quic_cc_algo_burst_size"`
	QuicCcAlgoMaxWindow *int                `json:"quic_cc_algo_max_window"`
	SeverityOutput      *BindSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs             *string             `json:"sigalgs,omitempty"`
	Ssl                 *bool               `json:"ssl,omitempty"`
	SslCafile           *string             `json:"ssl_cafile,omitempty"`
	SslCertificate      *string             `json:"ssl_certificate,omitempty"`
	SslMaxVer           *BindSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer           *BindSslMinVer      `json:"ssl_min_ver,omitempty"`
	Sslv3               *BindSslv3          `json:"sslv3,omitempty"`
	StrictSni           *bool               `json:"strict_sni,omitempty"`
	TcpUserTimeout      *int                `json:"tcp_user_timeout"`
	Tfo                 *bool               `json:"tfo,omitempty"`
	Thread              *string             `json:"thread,omitempty"`
	TlsTicketKeys       *string             `json:"tls_ticket_keys,omitempty"`
	Tlsv10              *BindTlsv10         `json:"tlsv10,omitempty"`
	Tlsv11              *BindTlsv11         `json:"tlsv11,omitempty"`
	Tlsv12              *BindTlsv12         `json:"tlsv12,omitempty"`
	Tlsv13              *BindTlsv13         `json:"tlsv13,omitempty"`
	Transparent         *bool               `json:"transparent,omitempty"`
	Uid                 *string             `json:"uid,omitempty"`
	User                *string             `json:"user,omitempty"`
	V4v6                *bool               `json:"v4v6,omitempty"`
	V6only              *bool               `json:"v6only,omitempty"`
	Verify              *BindVerify         `json:"verify,omitempty"`
}

// BindLevel defines model for Bind.Level.
type BindLevel string

// BindQuicCcAlgo defines model for Bind.QuicCcAlgo.
type BindQuicCcAlgo string

// BindQuicSocket defines model for Bind.QuicSocket.
type BindQuicSocket string

// BindSeverityOutput defines model for Bind.SeverityOutput.
type BindSeverityOutput string

// BindSslMaxVer defines model for Bind.SslMaxVer.
type BindSslMaxVer string

// BindSslMinVer defines model for Bind.SslMinVer.
type BindSslMinVer string

// BindSslv3 defines model for Bind.Sslv3.
type BindSslv3 string

// BindTlsv10 defines model for Bind.Tlsv10.
type BindTlsv10 string

// BindTlsv11 defines model for Bind.Tlsv11.
type BindTlsv11 string

// BindTlsv12 defines model for Bind.Tlsv12.
type BindTlsv12 string

// BindTlsv13 defines model for Bind.Tlsv13.
type BindTlsv13 string

// BindVerify defines model for Bind.Verify.
type BindVerify string

// BindParams defines model for bind_params.
type BindParams struct {
	AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
	Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
	Alpn               *string   `json:"alpn,omitempty"`
	Backlog            *string   `json:"backlog,omitempty"`
	CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
	CaSignFile         *string   `json:"ca_sign_file,omitempty"`
	CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
	Ciphers            *string   `json:"ciphers,omitempty"`
	Ciphersuites       *string   `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
	CrlFile            *string   `json:"crl_file,omitempty"`
	CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
	CrtList            *string   `json:"crt_list,omitempty"`
	Curves             *string   `json:"curves,omitempty"`
	DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
	DeferAccept        *bool     `json:"defer_accept,omitempty"`
	Ecdhe              *string   `json:"ecdhe,omitempty"`
	ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *bool `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13          *bool            `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool            `json:"generate_certificates,omitempty"`
	Gid                  *int             `json:"gid,omitempty"`
	Group                *string          `json:"group,omitempty"`
	GuidPrefix           *string          `json:"guid_prefix,omitempty"`
	Id                   *string          `json:"id,omitempty"`
	Interface            *string          `json:"interface,omitempty"`
	Level                *BindParamsLevel `json:"level,omitempty"`
	Maxconn              *int             `json:"maxconn,omitempty"`
	Mode                 *string          `json:"mode,omitempty"`
	Mss                  *string          `json:"mss,omitempty"`
	Name                 *string          `json:"name,omitempty"`
	Namespace            *string          `json:"namespace,omitempty"`
	Nbconn               *int             `json:"nbconn,omitempty"`
	Nice                 *int             `json:"nice,omitempty"`
	NoAlpn               *bool            `json:"no_alpn,omitempty"`
	NoCaNames            *bool            `json:"no_ca_names,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3      *bool `json:"no_sslv3,omitempty"`
	NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	NoTlsv13            *bool                     `json:"no_tlsv13,omitempty"`
	Npn                 *string                   `json:"npn,omitempty"`
	PreferClientCiphers *bool                     `json:"prefer_client_ciphers,omitempty"`
	Proto               *string                   `json:"proto,omitempty"`
	QuicCcAlgo          *BindParamsQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry      *bool                     `json:"quic-force-retry,omitempty"`
	QuicSocket          *BindParamsQuicSocket     `json:"quic-socket,omitempty"`
	QuicCcAlgoBurstSize *int                      `json:"quic_cc_algo_burst_size"`
	QuicCcAlgoMaxWindow *int                      `json:"quic_cc_algo_max_window"`
	SeverityOutput      *BindParamsSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs             *string                   `json:"sigalgs,omitempty"`
	Ssl                 *bool                     `json:"ssl,omitempty"`
	SslCafile           *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate      *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer           *BindParamsSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer           *BindParamsSslMinVer      `json:"ssl_min_ver,omitempty"`
	Sslv3               *BindParamsSslv3          `json:"sslv3,omitempty"`
	StrictSni           *bool                     `json:"strict_sni,omitempty"`
	TcpUserTimeout      *int                      `json:"tcp_user_timeout"`
	Tfo                 *bool                     `json:"tfo,omitempty"`
	Thread              *string                   `json:"thread,omitempty"`
	TlsTicketKeys       *string                   `json:"tls_ticket_keys,omitempty"`
	Tlsv10              *BindParamsTlsv10         `json:"tlsv10,omitempty"`
	Tlsv11              *BindParamsTlsv11         `json:"tlsv11,omitempty"`
	Tlsv12              *BindParamsTlsv12         `json:"tlsv12,omitempty"`
	Tlsv13              *BindParamsTlsv13         `json:"tlsv13,omitempty"`
	Transparent         *bool                     `json:"transparent,omitempty"`
	Uid                 *string                   `json:"uid,omitempty"`
	User                *string                   `json:"user,omitempty"`
	V4v6                *bool                     `json:"v4v6,omitempty"`
	V6only              *bool                     `json:"v6only,omitempty"`
	Verify              *BindParamsVerify         `json:"verify,omitempty"`
}

// BindParamsLevel defines model for BindParams.Level.
type BindParamsLevel string

// BindParamsQuicCcAlgo defines model for BindParams.QuicCcAlgo.
type BindParamsQuicCcAlgo string

// BindParamsQuicSocket defines model for BindParams.QuicSocket.
type BindParamsQuicSocket string

// BindParamsSeverityOutput defines model for BindParams.SeverityOutput.
type BindParamsSeverityOutput string

// BindParamsSslMaxVer defines model for BindParams.SslMaxVer.
type BindParamsSslMaxVer string

// BindParamsSslMinVer defines model for BindParams.SslMinVer.
type BindParamsSslMinVer string

// BindParamsSslv3 defines model for BindParams.Sslv3.
type BindParamsSslv3 string

// BindParamsTlsv10 defines model for BindParams.Tlsv10.
type BindParamsTlsv10 string

// BindParamsTlsv11 defines model for BindParams.Tlsv11.
type BindParamsTlsv11 string

// BindParamsTlsv12 defines model for BindParams.Tlsv12.
type BindParamsTlsv12 string

// BindParamsTlsv13 defines model for BindParams.Tlsv13.
type BindParamsTlsv13 string

// BindParamsVerify defines model for BindParams.Verify.
type BindParamsVerify string

// Binds HAProxy frontend binds array (corresponds to bind directives)
type Binds = []Bind

// Cache HAPRoxy Cache section
type Cache struct {
	MaxAge              *int   `json:"max_age,omitempty"`
	MaxObjectSize       *int   `json:"max_object_size,omitempty"`
	MaxSecondaryEntries *int   `json:"max_secondary_entries,omitempty"`
	Name                string `json:"name"`
	ProcessVary         *bool  `json:"process_vary"`
	TotalMaxSize        *int   `json:"total_max_size,omitempty"`
}

// Caches HAProxy caches array
type Caches = []Cache

// Capture defines model for capture.
type Capture struct {
	Length int         `json:"length"`
	Type   CaptureType `json:"type"`
}

// CaptureType defines model for Capture.Type.
type CaptureType string

// Captures defines model for captures.
type Captures = []Capture

// ClusterSettings Settings related to a cluster.
type ClusterSettings struct {
	BootstrapKey *string `json:"bootstrap_key,omitempty"`
	Cluster      *struct {
		Address           *string `json:"address,omitempty"`
		ApiBasePath       *string `json:"api_base_path,omitempty"`
		ClusterId         *string `json:"cluster_id,omitempty"`
		Description       *string `json:"description,omitempty"`
		ClusterLogTargets *[]struct {
			Address   string                                   `json:"address"`
			LogFormat *string                                  `json:"log_format,omitempty"`
			Port      int                                      `json:"port"`
			Protocol  ClusterSettingsClusterLogTargetsProtocol `json:"protocol"`
		} `json:"log_targets,omitempty"`
		Name *string `json:"name,omitempty"`
		Port *int    `json:"port"`
	} `json:"cluster,omitempty"`
	Mode   *ClusterSettingsMode   `json:"mode,omitempty"`
	Status *ClusterSettingsStatus `json:"status,omitempty"`
}

// ClusterSettingsClusterLogTargetsProtocol defines model for ClusterSettings.Cluster.LogTargets.Protocol.
type ClusterSettingsClusterLogTargetsProtocol string

// ClusterSettingsMode defines model for ClusterSettings.Mode.
type ClusterSettingsMode string

// ClusterSettingsStatus defines model for ClusterSettings.Status.
type ClusterSettingsStatus string

// Compression defines model for compression.
type Compression struct {
	AlgoReq    *CompressionAlgoReq      `json:"algo-req,omitempty"`
	Algorithms *[]CompressionAlgorithms `json:"algorithms,omitempty"`
	AlgosRes   *[]CompressionAlgosRes   `json:"algos-res,omitempty"`
	Direction  *CompressionDirection    `json:"direction,omitempty"`
	Offload    *bool                    `json:"offload,omitempty"`
	Types      *[]string                `json:"types,omitempty"`
	TypesReq   *[]string                `json:"types-req,omitempty"`
	TypesRes   *[]string                `json:"types-res,omitempty"`
}

// CompressionAlgoReq defines model for Compression.AlgoReq.
type CompressionAlgoReq string

// CompressionAlgorithms defines model for Compression.Algorithms.
type CompressionAlgorithms string

// CompressionAlgosRes defines model for Compression.AlgosRes.
type CompressionAlgosRes string

// CompressionDirection defines model for Compression.Direction.
type CompressionDirection string

// ConfigStickTable defines model for config_stick_table.
type ConfigStickTable struct {
	Expire  *int                    `json:"expire"`
	Keylen  *int                    `json:"keylen"`
	Nopurge *bool                   `json:"nopurge,omitempty"`
	Peers   *string                 `json:"peers,omitempty"`
	Size    *int                    `json:"size"`
	Srvkey  *ConfigStickTableSrvkey `json:"srvkey"`
	Store   *string                 `json:"store,omitempty"`
	Type    *ConfigStickTableType   `json:"type,omitempty"`
	WriteTo *string                 `json:"write_to"`
}

// ConfigStickTableSrvkey defines model for ConfigStickTable.Srvkey.
type ConfigStickTableSrvkey string

// ConfigStickTableType defines model for ConfigStickTable.Type.
type ConfigStickTableType string

// Consul Consul server configuration
type Consul struct {
	Address string `json:"address"`

	// Defaults Name of the defaults section to be used in backends created by this service
	Defaults    *string `json:"defaults,omitempty"`
	Description *string `json:"description,omitempty"`
	Enabled     bool    `json:"enabled"`

	// HealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
	//   none: all nodes are considered valid
	//   any: a node is considered valid if any one health check is 'passing'
	//   all: a node is considered valid if all health checks are 'passing'
	//   min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
	//     If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
	HealthCheckPolicy    *ConsulHealthCheckPolicy `json:"health_check_policy,omitempty"`
	HealthCheckPolicyMin *int                     `json:"health_check_policy_min,omitempty"`

	// Id Auto generated ID.
	Id        *string     `json:"id"`
	Mode      *ConsulMode `json:"mode,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Namespace *string     `json:"namespace,omitempty"`
	Port      int         `json:"port"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the consul server
	RetryTimeout               int                          `json:"retry_timeout"`
	ServerSlotsBase            *int                         `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                         `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *ConsulServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
	ServiceAllowlist           *[]string                    `json:"service_allowlist,omitempty"`
	ServiceDenylist            *[]string                    `json:"service_denylist,omitempty"`

	// ServiceNameRegexp Regular expression used to filter services by name.
	ServiceNameRegexp *string `json:"service_name_regexp,omitempty"`
	Token             *string `json:"token,omitempty"`
}

// ConsulHealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
//
//	none: all nodes are considered valid
//	any: a node is considered valid if any one health check is 'passing'
//	all: a node is considered valid if all health checks are 'passing'
//	min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
//	  If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
type ConsulHealthCheckPolicy string

// ConsulMode defines model for Consul.Mode.
type ConsulMode string

// ConsulServerSlotsGrowthType defines model for Consul.ServerSlotsGrowthType.
type ConsulServerSlotsGrowthType string

// Consuls Consuls array
type Consuls = []Consul

// Cookie defines model for cookie.
type Cookie struct {
	Attrs *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"attr,omitempty"`
	Domains *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"domain,omitempty"`
	Dynamic  *bool       `json:"dynamic,omitempty"`
	Httponly *bool       `json:"httponly,omitempty"`
	Indirect *bool       `json:"indirect,omitempty"`
	Maxidle  *int        `json:"maxidle,omitempty"`
	Maxlife  *int        `json:"maxlife,omitempty"`
	Name     string      `json:"name"`
	Nocache  *bool       `json:"nocache,omitempty"`
	Postonly *bool       `json:"postonly,omitempty"`
	Preserve *bool       `json:"preserve,omitempty"`
	Secure   *bool       `json:"secure,omitempty"`
	Type     *CookieType `json:"type,omitempty"`
}

// CookieType defines model for Cookie.Type.
type CookieType string

// CrtLoad Loads a certificate from a store with options
type CrtLoad struct {
	// Alias Certificate alias
	Alias *string `json:"alias,omitempty"`

	// Certificate Certificate filename
	Certificate string `json:"certificate"`

	// Issuer OCSP issuer filename
	Issuer *string `json:"issuer,omitempty"`

	// Key Private key filename
	Key *string `json:"key,omitempty"`

	// Ocsp OCSP response filename
	Ocsp *string `json:"ocsp,omitempty"`

	// OcspUpdate Automatic OCSP response update
	OcspUpdate *CrtLoadOcspUpdate `json:"ocsp_update,omitempty"`

	// Sctl Signed Certificate Timestamp List filename
	Sctl *string `json:"sctl,omitempty"`
}

// CrtLoadOcspUpdate Automatic OCSP response update
type CrtLoadOcspUpdate string

// CrtLoads List of certificates to load from a Certificate Store
type CrtLoads = []CrtLoad

// CrtStore Storage mechanism to load and store certificates used in the configuration
type CrtStore struct {
	// CrtBase Default directory to fetch SSL certificates from
	CrtBase *string `json:"crt_base,omitempty"`

	// KeyBase Default directory to fetch SSL private keys from
	KeyBase *string `json:"key_base,omitempty"`

	// Loads List of certificates to load from a Certificate Store
	Loads *CrtLoads `json:"loads,omitempty"`
	Name  string    `json:"name"`
}

// CrtStores List of Certificate Stores
type CrtStores = []CrtStore

// DebugOptions defines model for debug_options.
type DebugOptions struct {
	Anonkey     *int  `json:"anonkey"`
	Quiet       *bool `json:"quiet,omitempty"`
	ZeroWarning *bool `json:"zero_warning,omitempty"`
}

// DefaultBind defines model for default_bind.
type DefaultBind = BindParams

// DefaultServer defines model for default_server.
type DefaultServer = ServerParams

// Defaults defines model for defaults.
type Defaults struct {
	Abortonclose                         *DefaultsAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest             *DefaultsAcceptInvalidHttpRequest             `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse            *DefaultsAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpRequest  *DefaultsAcceptUnsafeViolationsInHttpRequest  `json:"accept_unsafe_violations_in_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *DefaultsAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`
	AdvCheck                             *DefaultsAdvCheck                             `json:"adv_check,omitempty"`
	Allbackups                           *DefaultsAllbackups                           `json:"allbackups,omitempty"`
	Backlog                              *int                                          `json:"backlog"`
	Balance                              *Balance                                      `json:"balance,omitempty"`
	CheckTimeout                         *int                                          `json:"check_timeout"`
	Checkcache                           *DefaultsCheckcache                           `json:"checkcache,omitempty"`
	Clflog                               *bool                                         `json:"clflog,omitempty"`
	ClientFinTimeout                     *int                                          `json:"client_fin_timeout"`
	ClientTimeout                        *int                                          `json:"client_timeout"`
	Clitcpka                             *DefaultsClitcpka                             `json:"clitcpka,omitempty"`
	ClitcpkaCnt                          *int                                          `json:"clitcpka_cnt"`
	ClitcpkaIdle                         *int                                          `json:"clitcpka_idle"`
	ClitcpkaIntvl                        *int                                          `json:"clitcpka_intvl"`
	Compression                          *Compression                                  `json:"compression,omitempty"`
	ConnectTimeout                       *int                                          `json:"connect_timeout"`
	Contstats                            *DefaultsContstats                            `json:"contstats,omitempty"`
	Cookie                               *Cookie                                       `json:"cookie,omitempty"`
	DefaultBackend                       *string                                       `json:"default_backend,omitempty"`
	DefaultServer                        *DefaultServer                                `json:"default_server,omitempty"`
	DisableH2Upgrade                     *DefaultsDisableH2Upgrade                     `json:"disable_h2_upgrade,omitempty"`
	Disabled                             *bool                                         `json:"disabled,omitempty"`
	DontlogNormal                        *DefaultsDontlogNormal                        `json:"dontlog_normal,omitempty"`
	Dontlognull                          *DefaultsDontlognull                          `json:"dontlognull,omitempty"`
	DynamicCookieKey                     *string                                       `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                      `json:"email_alert,omitempty"`
	Enabled                  *bool                            `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                     `json:"error_files,omitempty"`
	ErrorLogFormat           *string                          `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                    `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                        `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                        `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsExternalCheck           `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                          `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                          `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                      `json:"forwardfor,omitempty"`
	From                     *string                          `json:"from,omitempty"`
	Fullconn                 *int                             `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                             `json:"hash_balance_factor"`
	HashType                 *HashType                        `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *DefaultsHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpCheckList            *HttpChecks                      `json:"http_check_list,omitempty"`
	HttpConnectionMode       *DefaultsHttpConnectionMode      `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList       *HttpErrorRules                  `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes        *DefaultsHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout    *int                             `json:"http_keep_alive_timeout"`
	HttpNoDelay             *DefaultsHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive    *DefaultsHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpRequestTimeout      *int                             `json:"http_request_timeout"`
	HttpRestrictReqHdrNames *DefaultsHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *DefaultsHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                          `json:"http_send_name_header"`
	HttpUseProxyHeader      *DefaultsHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	HttpchkParams           *HttpchkParams                   `json:"httpchk_params,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *DefaultsHttpslog                `json:"httpslog,omitempty"`
	IdleCloseOnResponse     *DefaultsIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *DefaultsIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *DefaultsLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogHealthChecks         *DefaultsLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogSeparateErrors       *DefaultsLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                *[]DefaultsLogSteps              `json:"log_steps,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList     *LogTargets               `json:"log_target_list,omitempty"`
	Logasap           *DefaultsLogasap          `json:"logasap,omitempty"`
	MaxKeepAliveQueue *int                      `json:"max_keep_alive_queue"`
	Maxconn           *int                      `json:"maxconn"`
	Mode              *DefaultsMode             `json:"mode,omitempty"`
	MonitorUri        *MonitorUri               `json:"monitor_uri,omitempty"`
	MysqlCheckParams  *MysqlCheckParams         `json:"mysql_check_params,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	Nolinger          *DefaultsNolinger         `json:"nolinger,omitempty"`
	Originalto        *Originalto               `json:"originalto,omitempty"`
	Persist           *DefaultsPersist          `json:"persist,omitempty"`
	PersistRule       *PersistRule              `json:"persist_rule,omitempty"`
	PgsqlCheckParams  *PgsqlCheckParams         `json:"pgsql_check_params,omitempty"`
	PreferLastServer  *DefaultsPreferLastServer `json:"prefer_last_server,omitempty"`
	QueueTimeout      *int                      `json:"queue_timeout"`
	QUICInitialRules  *QUICInitialRules         `json:"quic_initial_rule_list,omitempty"`
	Redispatch        *Redispatch               `json:"redispatch,omitempty"`
	Retries           *int                      `json:"retries"`
	RetryOn           *string                   `json:"retry_on,omitempty"`
	ServerFinTimeout  *int                      `json:"server_fin_timeout"`
	ServerTimeout     *int                      `json:"server_timeout"`
	SmtpchkParams     *SmtpchkParams            `json:"smtpchk_params,omitempty"`
	SocketStats       *DefaultsSocketStats      `json:"socket_stats,omitempty"`
	Source            *Source                   `json:"source,omitempty"`
	SpliceAuto        *DefaultsSpliceAuto       `json:"splice_auto,omitempty"`
	SpliceRequest     *DefaultsSpliceRequest    `json:"splice_request,omitempty"`
	SpliceResponse    *DefaultsSpliceResponse   `json:"splice_response,omitempty"`
	Srvtcpka          *DefaultsSrvtcpka         `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt       *int                      `json:"srvtcpka_cnt"`
	SrvtcpkaIdle      *int                      `json:"srvtcpka_idle"`
	SrvtcpkaIntvl     *int                      `json:"srvtcpka_intvl"`
	StatsOptions      *StatsOptions             `json:"stats_options,omitempty"`
	TarpitTimeout     *int                      `json:"tarpit_timeout"`
	TcpCheckRuleList  *TcpChecks                `json:"tcp_check_rule_list,omitempty"`
	TcpSmartAccept    *DefaultsTcpSmartAccept   `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect   *DefaultsTcpSmartConnect  `json:"tcp_smart_connect,omitempty"`
	Tcpka             *DefaultsTcpka            `json:"tcpka,omitempty"`
	Tcplog            *bool                     `json:"tcplog,omitempty"`
	Transparent       *DefaultsTransparent      `json:"transparent,omitempty"`
	TunnelTimeout     *int                      `json:"tunnel_timeout"`
	UniqueIdFormat    *string                   `json:"unique_id_format,omitempty"`
	UniqueIdHeader    *string                   `json:"unique_id_header,omitempty"`
}

// DefaultsAbortonclose defines model for Defaults.Abortonclose.
type DefaultsAbortonclose string

// DefaultsAcceptInvalidHttpRequest defines model for Defaults.AcceptInvalidHttpRequest.
type DefaultsAcceptInvalidHttpRequest string

// DefaultsAcceptInvalidHttpResponse defines model for Defaults.AcceptInvalidHttpResponse.
type DefaultsAcceptInvalidHttpResponse string

// DefaultsAcceptUnsafeViolationsInHttpRequest defines model for Defaults.AcceptUnsafeViolationsInHttpRequest.
type DefaultsAcceptUnsafeViolationsInHttpRequest string

// DefaultsAcceptUnsafeViolationsInHttpResponse defines model for Defaults.AcceptUnsafeViolationsInHttpResponse.
type DefaultsAcceptUnsafeViolationsInHttpResponse string

// DefaultsAdvCheck defines model for Defaults.AdvCheck.
type DefaultsAdvCheck string

// DefaultsAllbackups defines model for Defaults.Allbackups.
type DefaultsAllbackups string

// DefaultsCheckcache defines model for Defaults.Checkcache.
type DefaultsCheckcache string

// DefaultsClitcpka defines model for Defaults.Clitcpka.
type DefaultsClitcpka string

// DefaultsContstats defines model for Defaults.Contstats.
type DefaultsContstats string

// DefaultsDisableH2Upgrade defines model for Defaults.DisableH2Upgrade.
type DefaultsDisableH2Upgrade string

// DefaultsDontlogNormal defines model for Defaults.DontlogNormal.
type DefaultsDontlogNormal string

// DefaultsDontlognull defines model for Defaults.Dontlognull.
type DefaultsDontlognull string

// DefaultsExternalCheck defines model for Defaults.ExternalCheck.
type DefaultsExternalCheck string

// DefaultsH1CaseAdjustBogusClient defines model for Defaults.H1CaseAdjustBogusClient.
type DefaultsH1CaseAdjustBogusClient string

// DefaultsH1CaseAdjustBogusServer defines model for Defaults.H1CaseAdjustBogusServer.
type DefaultsH1CaseAdjustBogusServer string

// DefaultsHttpBufferRequest defines model for Defaults.HttpBufferRequest.
type DefaultsHttpBufferRequest string

// DefaultsHttpUseHtx defines model for Defaults.HttpUseHtx.
type DefaultsHttpUseHtx string

// DefaultsHttpConnectionMode defines model for Defaults.HttpConnectionMode.
type DefaultsHttpConnectionMode string

// DefaultsHttpIgnoreProbes defines model for Defaults.HttpIgnoreProbes.
type DefaultsHttpIgnoreProbes string

// DefaultsHttpNoDelay defines model for Defaults.HttpNoDelay.
type DefaultsHttpNoDelay string

// DefaultsHttpPretendKeepalive defines model for Defaults.HttpPretendKeepalive.
type DefaultsHttpPretendKeepalive string

// DefaultsHttpRestrictReqHdrNames defines model for Defaults.HttpRestrictReqHdrNames.
type DefaultsHttpRestrictReqHdrNames string

// DefaultsHttpReuse defines model for Defaults.HttpReuse.
type DefaultsHttpReuse string

// DefaultsHttpUseProxyHeader defines model for Defaults.HttpUseProxyHeader.
type DefaultsHttpUseProxyHeader string

// DefaultsHttpslog defines model for Defaults.Httpslog.
type DefaultsHttpslog string

// DefaultsIdleCloseOnResponse defines model for Defaults.IdleCloseOnResponse.
type DefaultsIdleCloseOnResponse string

// DefaultsIndependentStreams defines model for Defaults.IndependentStreams.
type DefaultsIndependentStreams string

// DefaultsLoadServerStateFromFile defines model for Defaults.LoadServerStateFromFile.
type DefaultsLoadServerStateFromFile string

// DefaultsLogHealthChecks defines model for Defaults.LogHealthChecks.
type DefaultsLogHealthChecks string

// DefaultsLogSeparateErrors defines model for Defaults.LogSeparateErrors.
type DefaultsLogSeparateErrors string

// DefaultsLogSteps defines model for Defaults.LogSteps.
type DefaultsLogSteps string

// DefaultsLogasap defines model for Defaults.Logasap.
type DefaultsLogasap string

// DefaultsMode defines model for Defaults.Mode.
type DefaultsMode string

// DefaultsNolinger defines model for Defaults.Nolinger.
type DefaultsNolinger string

// DefaultsPersist defines model for Defaults.Persist.
type DefaultsPersist string

// DefaultsPreferLastServer defines model for Defaults.PreferLastServer.
type DefaultsPreferLastServer string

// DefaultsSocketStats defines model for Defaults.SocketStats.
type DefaultsSocketStats string

// DefaultsSpliceAuto defines model for Defaults.SpliceAuto.
type DefaultsSpliceAuto string

// DefaultsSpliceRequest defines model for Defaults.SpliceRequest.
type DefaultsSpliceRequest string

// DefaultsSpliceResponse defines model for Defaults.SpliceResponse.
type DefaultsSpliceResponse string

// DefaultsSrvtcpka defines model for Defaults.Srvtcpka.
type DefaultsSrvtcpka string

// DefaultsTcpSmartAccept defines model for Defaults.TcpSmartAccept.
type DefaultsTcpSmartAccept string

// DefaultsTcpSmartConnect defines model for Defaults.TcpSmartConnect.
type DefaultsTcpSmartConnect string

// DefaultsTcpka defines model for Defaults.Tcpka.
type DefaultsTcpka string

// DefaultsTransparent defines model for Defaults.Transparent.
type DefaultsTransparent string

// DefaultsBase HAProxy defaults configuration
type DefaultsBase struct {
	Abortonclose                         *DefaultsBaseAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest             *DefaultsBaseAcceptInvalidHttpRequest             `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse            *DefaultsBaseAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpRequest  *DefaultsBaseAcceptUnsafeViolationsInHttpRequest  `json:"accept_unsafe_violations_in_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *DefaultsBaseAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`
	AdvCheck                             *DefaultsBaseAdvCheck                             `json:"adv_check,omitempty"`
	Allbackups                           *DefaultsBaseAllbackups                           `json:"allbackups,omitempty"`
	Backlog                              *int                                              `json:"backlog"`
	Balance                              *Balance                                          `json:"balance,omitempty"`
	CheckTimeout                         *int                                              `json:"check_timeout"`
	Checkcache                           *DefaultsBaseCheckcache                           `json:"checkcache,omitempty"`
	Clflog                               *bool                                             `json:"clflog,omitempty"`
	ClientFinTimeout                     *int                                              `json:"client_fin_timeout"`
	ClientTimeout                        *int                                              `json:"client_timeout"`
	Clitcpka                             *DefaultsBaseClitcpka                             `json:"clitcpka,omitempty"`
	ClitcpkaCnt                          *int                                              `json:"clitcpka_cnt"`
	ClitcpkaIdle                         *int                                              `json:"clitcpka_idle"`
	ClitcpkaIntvl                        *int                                              `json:"clitcpka_intvl"`
	Compression                          *Compression                                      `json:"compression,omitempty"`
	ConnectTimeout                       *int                                              `json:"connect_timeout"`
	Contstats                            *DefaultsBaseContstats                            `json:"contstats,omitempty"`
	Cookie                               *Cookie                                           `json:"cookie,omitempty"`
	DefaultBackend                       *string                                           `json:"default_backend,omitempty"`
	DefaultServer                        *DefaultServer                                    `json:"default_server,omitempty"`
	DisableH2Upgrade                     *DefaultsBaseDisableH2Upgrade                     `json:"disable_h2_upgrade,omitempty"`
	Disabled                             *bool                                             `json:"disabled,omitempty"`
	DontlogNormal                        *DefaultsBaseDontlogNormal                        `json:"dontlog_normal,omitempty"`
	Dontlognull                          *DefaultsBaseDontlognull                          `json:"dontlognull,omitempty"`
	DynamicCookieKey                     *string                                           `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                          `json:"email_alert,omitempty"`
	Enabled                  *bool                                `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                         `json:"error_files,omitempty"`
	ErrorLogFormat           *string                              `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                        `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                            `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                            `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsBaseExternalCheck           `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                              `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                              `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                          `json:"forwardfor,omitempty"`
	From                     *string                              `json:"from,omitempty"`
	Fullconn                 *int                                 `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsBaseH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsBaseH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                                 `json:"hash_balance_factor"`
	HashType                 *HashType                            `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *DefaultsBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *DefaultsBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *DefaultsBaseHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                 `json:"http_keep_alive_timeout"`
	HttpNoDelay              *DefaultsBaseHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive     *DefaultsBaseHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpRequestTimeout       *int                                 `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *DefaultsBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse                *DefaultsBaseHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader       *string                              `json:"http_send_name_header"`
	HttpUseProxyHeader       *DefaultsBaseHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	HttpchkParams            *HttpchkParams                       `json:"httpchk_params,omitempty"`
	Httplog                  *bool                                `json:"httplog,omitempty"`
	Httpslog                 *DefaultsBaseHttpslog                `json:"httpslog,omitempty"`
	IdleCloseOnResponse      *DefaultsBaseIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *DefaultsBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile  *DefaultsBaseLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogFormat                *string                              `json:"log_format,omitempty"`
	LogFormatSd              *string                              `json:"log_format_sd,omitempty"`
	LogHealthChecks          *DefaultsBaseLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogSeparateErrors        *DefaultsBaseLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                 *[]DefaultsBaseLogSteps              `json:"log_steps,omitempty"`
	LogTag                   *string                              `json:"log_tag,omitempty"`
	Logasap                  *DefaultsBaseLogasap                 `json:"logasap,omitempty"`
	MaxKeepAliveQueue        *int                                 `json:"max_keep_alive_queue"`
	Maxconn                  *int                                 `json:"maxconn"`
	Mode                     *DefaultsBaseMode                    `json:"mode,omitempty"`
	MonitorUri               *MonitorUri                          `json:"monitor_uri,omitempty"`
	MysqlCheckParams         *MysqlCheckParams                    `json:"mysql_check_params,omitempty"`
	Name                     *string                              `json:"name,omitempty"`
	Nolinger                 *DefaultsBaseNolinger                `json:"nolinger,omitempty"`
	Originalto               *Originalto                          `json:"originalto,omitempty"`
	Persist                  *DefaultsBasePersist                 `json:"persist,omitempty"`
	PersistRule              *PersistRule                         `json:"persist_rule,omitempty"`
	PgsqlCheckParams         *PgsqlCheckParams                    `json:"pgsql_check_params,omitempty"`
	PreferLastServer         *DefaultsBasePreferLastServer        `json:"prefer_last_server,omitempty"`
	QueueTimeout             *int                                 `json:"queue_timeout"`
	Redispatch               *Redispatch                          `json:"redispatch,omitempty"`
	Retries                  *int                                 `json:"retries"`
	RetryOn                  *string                              `json:"retry_on,omitempty"`
	ServerFinTimeout         *int                                 `json:"server_fin_timeout"`
	ServerTimeout            *int                                 `json:"server_timeout"`
	SmtpchkParams            *SmtpchkParams                       `json:"smtpchk_params,omitempty"`
	SocketStats              *DefaultsBaseSocketStats             `json:"socket_stats,omitempty"`
	Source                   *Source                              `json:"source,omitempty"`
	SpliceAuto               *DefaultsBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest            *DefaultsBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse           *DefaultsBaseSpliceResponse          `json:"splice_response,omitempty"`
	Srvtcpka                 *DefaultsBaseSrvtcpka                `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt              *int                                 `json:"srvtcpka_cnt"`
	SrvtcpkaIdle             *int                                 `json:"srvtcpka_idle"`
	SrvtcpkaIntvl            *int                                 `json:"srvtcpka_intvl"`
	StatsOptions             *StatsOptions                        `json:"stats_options,omitempty"`
	TarpitTimeout            *int                                 `json:"tarpit_timeout"`
	TcpSmartAccept           *DefaultsBaseTcpSmartAccept          `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect          *DefaultsBaseTcpSmartConnect         `json:"tcp_smart_connect,omitempty"`
	Tcpka                    *DefaultsBaseTcpka                   `json:"tcpka,omitempty"`
	Tcplog                   *bool                                `json:"tcplog,omitempty"`
	Transparent              *DefaultsBaseTransparent             `json:"transparent,omitempty"`
	TunnelTimeout            *int                                 `json:"tunnel_timeout"`
	UniqueIdFormat           *string                              `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                              `json:"unique_id_header,omitempty"`
}

// DefaultsBaseAbortonclose defines model for DefaultsBase.Abortonclose.
type DefaultsBaseAbortonclose string

// DefaultsBaseAcceptInvalidHttpRequest defines model for DefaultsBase.AcceptInvalidHttpRequest.
type DefaultsBaseAcceptInvalidHttpRequest string

// DefaultsBaseAcceptInvalidHttpResponse defines model for DefaultsBase.AcceptInvalidHttpResponse.
type DefaultsBaseAcceptInvalidHttpResponse string

// DefaultsBaseAcceptUnsafeViolationsInHttpRequest defines model for DefaultsBase.AcceptUnsafeViolationsInHttpRequest.
type DefaultsBaseAcceptUnsafeViolationsInHttpRequest string

// DefaultsBaseAcceptUnsafeViolationsInHttpResponse defines model for DefaultsBase.AcceptUnsafeViolationsInHttpResponse.
type DefaultsBaseAcceptUnsafeViolationsInHttpResponse string

// DefaultsBaseAdvCheck defines model for DefaultsBase.AdvCheck.
type DefaultsBaseAdvCheck string

// DefaultsBaseAllbackups defines model for DefaultsBase.Allbackups.
type DefaultsBaseAllbackups string

// DefaultsBaseCheckcache defines model for DefaultsBase.Checkcache.
type DefaultsBaseCheckcache string

// DefaultsBaseClitcpka defines model for DefaultsBase.Clitcpka.
type DefaultsBaseClitcpka string

// DefaultsBaseContstats defines model for DefaultsBase.Contstats.
type DefaultsBaseContstats string

// DefaultsBaseDisableH2Upgrade defines model for DefaultsBase.DisableH2Upgrade.
type DefaultsBaseDisableH2Upgrade string

// DefaultsBaseDontlogNormal defines model for DefaultsBase.DontlogNormal.
type DefaultsBaseDontlogNormal string

// DefaultsBaseDontlognull defines model for DefaultsBase.Dontlognull.
type DefaultsBaseDontlognull string

// DefaultsBaseExternalCheck defines model for DefaultsBase.ExternalCheck.
type DefaultsBaseExternalCheck string

// DefaultsBaseH1CaseAdjustBogusClient defines model for DefaultsBase.H1CaseAdjustBogusClient.
type DefaultsBaseH1CaseAdjustBogusClient string

// DefaultsBaseH1CaseAdjustBogusServer defines model for DefaultsBase.H1CaseAdjustBogusServer.
type DefaultsBaseH1CaseAdjustBogusServer string

// DefaultsBaseHttpBufferRequest defines model for DefaultsBase.HttpBufferRequest.
type DefaultsBaseHttpBufferRequest string

// DefaultsBaseHttpUseHtx defines model for DefaultsBase.HttpUseHtx.
type DefaultsBaseHttpUseHtx string

// DefaultsBaseHttpConnectionMode defines model for DefaultsBase.HttpConnectionMode.
type DefaultsBaseHttpConnectionMode string

// DefaultsBaseHttpIgnoreProbes defines model for DefaultsBase.HttpIgnoreProbes.
type DefaultsBaseHttpIgnoreProbes string

// DefaultsBaseHttpNoDelay defines model for DefaultsBase.HttpNoDelay.
type DefaultsBaseHttpNoDelay string

// DefaultsBaseHttpPretendKeepalive defines model for DefaultsBase.HttpPretendKeepalive.
type DefaultsBaseHttpPretendKeepalive string

// DefaultsBaseHttpRestrictReqHdrNames defines model for DefaultsBase.HttpRestrictReqHdrNames.
type DefaultsBaseHttpRestrictReqHdrNames string

// DefaultsBaseHttpReuse defines model for DefaultsBase.HttpReuse.
type DefaultsBaseHttpReuse string

// DefaultsBaseHttpUseProxyHeader defines model for DefaultsBase.HttpUseProxyHeader.
type DefaultsBaseHttpUseProxyHeader string

// DefaultsBaseHttpslog defines model for DefaultsBase.Httpslog.
type DefaultsBaseHttpslog string

// DefaultsBaseIdleCloseOnResponse defines model for DefaultsBase.IdleCloseOnResponse.
type DefaultsBaseIdleCloseOnResponse string

// DefaultsBaseIndependentStreams defines model for DefaultsBase.IndependentStreams.
type DefaultsBaseIndependentStreams string

// DefaultsBaseLoadServerStateFromFile defines model for DefaultsBase.LoadServerStateFromFile.
type DefaultsBaseLoadServerStateFromFile string

// DefaultsBaseLogHealthChecks defines model for DefaultsBase.LogHealthChecks.
type DefaultsBaseLogHealthChecks string

// DefaultsBaseLogSeparateErrors defines model for DefaultsBase.LogSeparateErrors.
type DefaultsBaseLogSeparateErrors string

// DefaultsBaseLogSteps defines model for DefaultsBase.LogSteps.
type DefaultsBaseLogSteps string

// DefaultsBaseLogasap defines model for DefaultsBase.Logasap.
type DefaultsBaseLogasap string

// DefaultsBaseMode defines model for DefaultsBase.Mode.
type DefaultsBaseMode string

// DefaultsBaseNolinger defines model for DefaultsBase.Nolinger.
type DefaultsBaseNolinger string

// DefaultsBasePersist defines model for DefaultsBase.Persist.
type DefaultsBasePersist string

// DefaultsBasePreferLastServer defines model for DefaultsBase.PreferLastServer.
type DefaultsBasePreferLastServer string

// DefaultsBaseSocketStats defines model for DefaultsBase.SocketStats.
type DefaultsBaseSocketStats string

// DefaultsBaseSpliceAuto defines model for DefaultsBase.SpliceAuto.
type DefaultsBaseSpliceAuto string

// DefaultsBaseSpliceRequest defines model for DefaultsBase.SpliceRequest.
type DefaultsBaseSpliceRequest string

// DefaultsBaseSpliceResponse defines model for DefaultsBase.SpliceResponse.
type DefaultsBaseSpliceResponse string

// DefaultsBaseSrvtcpka defines model for DefaultsBase.Srvtcpka.
type DefaultsBaseSrvtcpka string

// DefaultsBaseTcpSmartAccept defines model for DefaultsBase.TcpSmartAccept.
type DefaultsBaseTcpSmartAccept string

// DefaultsBaseTcpSmartConnect defines model for DefaultsBase.TcpSmartConnect.
type DefaultsBaseTcpSmartConnect string

// DefaultsBaseTcpka defines model for DefaultsBase.Tcpka.
type DefaultsBaseTcpka string

// DefaultsBaseTransparent defines model for DefaultsBase.Transparent.
type DefaultsBaseTransparent string

// DefaultsSections HAProxy defaults sections array
type DefaultsSections = []Defaults

// DeviceAtlasOptions defines model for device_atlas_options.
type DeviceAtlasOptions struct {
	JsonFile         *string `json:"json_file,omitempty"`
	LogLevel         *string `json:"log_level,omitempty"`
	PropertiesCookie *string `json:"properties_cookie,omitempty"`
	Separator        *string `json:"separator,omitempty"`
}

// DgramBind HAProxy log forward dgram bind configuration
type DgramBind struct {
	Address      *string `json:"address,omitempty"`
	Interface    *string `json:"interface,omitempty"`
	Name         *string `json:"name,omitempty"`
	Namespace    *string `json:"namespace,omitempty"`
	Port         *int    `json:"port"`
	PortRangeEnd *int    `json:"port-range-end"`
	Transparent  *bool   `json:"transparent,omitempty"`
}

// DgramBinds HAProxy dgram bind array
type DgramBinds = []DgramBind

// EmailAlert Send emails for important log messages.
type EmailAlert struct {
	From       string           `json:"from"`
	Level      *EmailAlertLevel `json:"level,omitempty"`
	Mailers    string           `json:"mailers"`
	Myhostname *string          `json:"myhostname,omitempty"`
	To         string           `json:"to"`
}

// EmailAlertLevel defines model for EmailAlert.Level.
type EmailAlertLevel string

// Endpoint Endpoint definition
type Endpoint struct {
	// Description Endpoint description
	Description *string `json:"description,omitempty"`

	// Title Endpoint title
	Title *string `json:"title,omitempty"`

	// Url Path to the endpoint
	Url *string `json:"url,omitempty"`
}

// Endpoints Collection of endpoints
type Endpoints = []Endpoint

// EnvironmentOptions defines model for environment_options.
type EnvironmentOptions struct {
	PresetEnvs *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"presetenv,omitempty"`
	Resetenv *string `json:"resetenv,omitempty"`
	SetEnvs  *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"setenv,omitempty"`
	Unsetenv *string `json:"unsetenv,omitempty"`
}

// Error API Error
type Error struct {
	Code                 *int              `json:"code"`
	Message              *string           `json:"message"`
	AdditionalProperties map[string]string `json:"-"`
}

// Errorfile defines model for errorfile.
type Errorfile struct {
	Code *ErrorfileCode `json:"code,omitempty"`
	File *string        `json:"file,omitempty"`
}

// ErrorfileCode defines model for Errorfile.Code.
type ErrorfileCode int

// Errorfiles defines model for errorfiles.
type Errorfiles struct {
	Codes *[]ErrorfilesCodes `json:"codes,omitempty"`
	Name  *string            `json:"name,omitempty"`
}

// ErrorfilesCodes defines model for Errorfiles.Codes.
type ErrorfilesCodes int

// Errorloc defines model for errorloc.
type Errorloc struct {
	Code ErrorlocCode `json:"code"`
	Url  string       `json:"url"`
}

// ErrorlocCode defines model for Errorloc.Code.
type ErrorlocCode int

// FCGIApp defines model for fcgiApp.
type FCGIApp struct {
	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs *int `json:"max_reqs,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppGetValues string

// FcgiAppKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppKeepConn string

// FcgiAppMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppMpxsConns string

// FcgiAppBase HAProxy FastCGI application configuration
type FcgiAppBase struct {
	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppBaseGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppBaseKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr     `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs *int `json:"max_reqs,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppBaseMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppBaseGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppBaseGetValues string

// FcgiAppBaseKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppBaseKeepConn string

// FcgiAppBaseMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppBaseMpxsConns string

// FcgiApps defines model for fcgiApps.
type FcgiApps = []FCGIApp

// FcgiLogStderr Enables logging of STDERR messages that the FastCGI application reports.
// It is an optional setting. By default, HAProxy Enterprise ignores STDERR messages.
type FcgiLogStderr struct {
	Address  *string `json:"address,omitempty"`
	Facility *string `json:"facility,omitempty"`
	Format   *string `json:"format,omitempty"`
	Global   *bool   `json:"global,omitempty"`
	Len      *int    `json:"len,omitempty"`
	Level    *string `json:"level,omitempty"`
	Minlevel *string `json:"minlevel,omitempty"`
	Sample   *struct {
		Ranges string `json:"ranges"`
		Size   int    `json:"size"`
	} `json:"sample,omitempty"`
}

// FcgiPassHeader Specifies the name of a request header to pass to the FastCGI application.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
// Most request headers are already available to the FastCGI application with the prefix "HTTP".
// Thus, you only need this directive to pass headers that are purposefully omitted.
// Currently, the headers "Authorization", "Proxy-Authorization", and hop-by-hop headers are omitted.
// Note that the headers "Content-type" and "Content-length" never pass to the FastCGI application because they are already converted into parameters.
type FcgiPassHeader struct {
	Cond     *FcgiPassHeaderCond `json:"cond,omitempty"`
	CondTest *string             `json:"cond_test,omitempty"`
	Name     *string             `json:"name,omitempty"`
}

// FcgiPassHeaderCond defines model for FcgiPassHeader.Cond.
type FcgiPassHeaderCond string

// FcgiSetParam Sets a FastCGI parameter to pass to this application.
// Its value, defined by <format> can take a formatted string, the same as the log directive.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
type FcgiSetParam struct {
	Cond     *FcgiSetParamCond `json:"cond,omitempty"`
	CondTest *string           `json:"cond_test,omitempty"`
	Format   *string           `json:"format,omitempty"`
	Name     *string           `json:"name,omitempty"`
}

// FcgiSetParamCond defines model for FcgiSetParam.Cond.
type FcgiSetParamCond string

// FiftyOneDegreesOptions defines model for fifty_one_degrees_options.
type FiftyOneDegreesOptions struct {
	CacheSize         *int    `json:"cache_size,omitempty"`
	DataFile          *string `json:"data_file,omitempty"`
	PropertyNameList  *string `json:"property_name_list,omitempty"`
	PropertySeparator *string `json:"property_separator,omitempty"`
}

// Filter HAProxy filters
type Filter struct {
	// AppName Name of the fcgi-app section this filter will use.
	AppName *string `json:"app_name,omitempty"`

	// BandwidthLimitName Filter name that will be used by 'set-bandwidth-limit' actions to reference a specific bandwidth limitation filter
	BandwidthLimitName *string `json:"bandwidth_limit_name,omitempty"`
	CacheName          *string `json:"cache_name,omitempty"`

	// DefaultLimit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	DefaultLimit *int `json:"default_limit,omitempty"`

	// DefaultPeriod The default time period used to evaluate the bandwidth limitation rate.
	// It can be specified for per-stream bandwidth limitation filters only.
	// It follows the HAProxy time format and is expressed in milliseconds.
	DefaultPeriod *int `json:"default_period,omitempty"`

	// Key A sample expression rule.
	// It describes what elements will be analyzed, extracted, combined, and used to select which table entry to update the counters.
	// It must be specified for shared bandwidth limitation filters only.
	Key *string `json:"key,omitempty"`

	// Limit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	Limit *int `json:"limit,omitempty"`

	// MinSize The optional minimum number of bytes forwarded at a time by a stream excluding the last packet that may be smaller.
	// This value can be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	MinSize    *int    `json:"min_size,omitempty"`
	SpoeConfig *string `json:"spoe_config,omitempty"`
	SpoeEngine *string `json:"spoe_engine,omitempty"`

	// Table An optional table to be used instead of the default one, which is the stick-table declared in the current proxy.
	// It can be specified for shared bandwidth limitation filters only.
	Table              *string    `json:"table,omitempty"`
	TraceHexdump       *bool      `json:"trace_hexdump,omitempty"`
	TraceName          *string    `json:"trace_name,omitempty"`
	TraceRndForwarding *bool      `json:"trace_rnd_forwarding,omitempty"`
	TraceRndParsing    *bool      `json:"trace_rnd_parsing,omitempty"`
	Type               FilterType `json:"type"`
}

// FilterType defines model for Filter.Type.
type FilterType string

// Filters HAProxy filters array (corresponds to filter directive)
type Filters = []Filter

// Forwardfor defines model for forwardfor.
type Forwardfor struct {
	Enabled ForwardforEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
	Ifnone  *bool             `json:"ifnone,omitempty"`
}

// ForwardforEnabled defines model for Forwardfor.Enabled.
type ForwardforEnabled string

// Frontend defines model for frontend.
type Frontend struct {
	AcceptInvalidHttpRequest            *FrontendAcceptInvalidHttpRequest            `json:"accept_invalid_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpRequest *FrontendAcceptUnsafeViolationsInHttpRequest `json:"accept_unsafe_violations_in_http_request,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// BackendSwitchingRuleList HAProxy backend switching rules array (corresponds to use_backend directives)
	BackendSwitchingRuleList *BackendSwitchingRules    `json:"backend_switching_rule_list,omitempty"`
	Backlog                  *int                      `json:"backlog"`
	Binds                    *map[string]Bind          `json:"binds,omitempty"`
	CaptureList              *Captures                 `json:"capture_list,omitempty"`
	Clflog                   *bool                     `json:"clflog,omitempty"`
	ClientFinTimeout         *int                      `json:"client_fin_timeout"`
	ClientTimeout            *int                      `json:"client_timeout"`
	Clitcpka                 *FrontendClitcpka         `json:"clitcpka,omitempty"`
	ClitcpkaCnt              *int                      `json:"clitcpka_cnt"`
	ClitcpkaIdle             *int                      `json:"clitcpka_idle"`
	ClitcpkaIntvl            *int                      `json:"clitcpka_intvl"`
	Compression              *Compression              `json:"compression,omitempty"`
	Contstats                *FrontendContstats        `json:"contstats,omitempty"`
	DefaultBackend           *string                   `json:"default_backend,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DisableH2Upgrade         *FrontendDisableH2Upgrade `json:"disable_h2_upgrade,omitempty"`
	Disabled                 *bool                     `json:"disabled,omitempty"`
	DontlogNormal            *FrontendDontlogNormal    `json:"dontlog_normal,omitempty"`
	Dontlognull              *FrontendDontlognull      `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert   `json:"email_alert,omitempty"`
	Enabled                  *bool         `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile  `json:"error_files,omitempty"`
	ErrorLogFormat           *string       `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc     `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc     `json:"errorloc303,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList              *Filters                         `json:"filter_list,omitempty"`
	Forwardfor              *Forwardfor                      `json:"forwardfor,omitempty"`
	From                    *string                          `json:"from,omitempty"`
	Guid                    *string                          `json:"guid,omitempty"`
	H1CaseAdjustBogusClient *FrontendH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest       *FrontendHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx              *FrontendHttpUseHtx              `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules     `json:"http_after_response_rule_list,omitempty"`
	HttpConnectionMode        *FrontendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules           `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes     *FrontendHttpIgnoreProbes `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout *int                      `json:"http_keep_alive_timeout"`
	HttpNoDelay          *FrontendHttpNoDelay      `json:"http_no_delay,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules               `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *FrontendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader      *FrontendHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *FrontendHttpslog                `json:"httpslog,omitempty"`
	Id                      *int                             `json:"id"`
	IdleCloseOnResponse     *FrontendIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *FrontendIndependentStreams      `json:"independent_streams,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogSeparateErrors       *FrontendLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                *[]FrontendLogSteps              `json:"log_steps,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList    *LogTargets             `json:"log_target_list,omitempty"`
	Logasap          *FrontendLogasap        `json:"logasap,omitempty"`
	Maxconn          *int                    `json:"maxconn"`
	Mode             *FrontendMode           `json:"mode,omitempty"`
	MonitorFail      *MonitorFail            `json:"monitor_fail,omitempty"`
	MonitorUri       *MonitorUri             `json:"monitor_uri,omitempty"`
	Name             string                  `json:"name"`
	Nolinger         *FrontendNolinger       `json:"nolinger,omitempty"`
	Originalto       *Originalto             `json:"originalto,omitempty"`
	QUICInitialRules *QUICInitialRules       `json:"quic_initial_rule_list,omitempty"`
	SocketStats      *FrontendSocketStats    `json:"socket_stats,omitempty"`
	SpliceAuto       *FrontendSpliceAuto     `json:"splice_auto,omitempty"`
	SpliceRequest    *FrontendSpliceRequest  `json:"splice_request,omitempty"`
	SpliceResponse   *FrontendSpliceResponse `json:"splice_response,omitempty"`
	StatsOptions     *StatsOptions           `json:"stats_options,omitempty"`
	StickTable       *ConfigStickTable       `json:"stick_table,omitempty"`
	TarpitTimeout    *int                    `json:"tarpit_timeout"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules        `json:"tcp_request_rule_list,omitempty"`
	TcpSmartAccept     *FrontendTcpSmartAccept `json:"tcp_smart_accept,omitempty"`
	Tcpka              *FrontendTcpka          `json:"tcpka,omitempty"`
	Tcplog             *bool                   `json:"tcplog,omitempty"`
	UniqueIdFormat     *string                 `json:"unique_id_format,omitempty"`
	UniqueIdHeader     *string                 `json:"unique_id_header,omitempty"`
}

// FrontendAcceptInvalidHttpRequest defines model for Frontend.AcceptInvalidHttpRequest.
type FrontendAcceptInvalidHttpRequest string

// FrontendAcceptUnsafeViolationsInHttpRequest defines model for Frontend.AcceptUnsafeViolationsInHttpRequest.
type FrontendAcceptUnsafeViolationsInHttpRequest string

// FrontendClitcpka defines model for Frontend.Clitcpka.
type FrontendClitcpka string

// FrontendContstats defines model for Frontend.Contstats.
type FrontendContstats string

// FrontendDisableH2Upgrade defines model for Frontend.DisableH2Upgrade.
type FrontendDisableH2Upgrade string

// FrontendDontlogNormal defines model for Frontend.DontlogNormal.
type FrontendDontlogNormal string

// FrontendDontlognull defines model for Frontend.Dontlognull.
type FrontendDontlognull string

// FrontendH1CaseAdjustBogusClient defines model for Frontend.H1CaseAdjustBogusClient.
type FrontendH1CaseAdjustBogusClient string

// FrontendHttpBufferRequest defines model for Frontend.HttpBufferRequest.
type FrontendHttpBufferRequest string

// FrontendHttpUseHtx defines model for Frontend.HttpUseHtx.
type FrontendHttpUseHtx string

// FrontendHttpConnectionMode defines model for Frontend.HttpConnectionMode.
type FrontendHttpConnectionMode string

// FrontendHttpIgnoreProbes defines model for Frontend.HttpIgnoreProbes.
type FrontendHttpIgnoreProbes string

// FrontendHttpNoDelay defines model for Frontend.HttpNoDelay.
type FrontendHttpNoDelay string

// FrontendHttpRestrictReqHdrNames defines model for Frontend.HttpRestrictReqHdrNames.
type FrontendHttpRestrictReqHdrNames string

// FrontendHttpUseProxyHeader defines model for Frontend.HttpUseProxyHeader.
type FrontendHttpUseProxyHeader string

// FrontendHttpslog defines model for Frontend.Httpslog.
type FrontendHttpslog string

// FrontendIdleCloseOnResponse defines model for Frontend.IdleCloseOnResponse.
type FrontendIdleCloseOnResponse string

// FrontendIndependentStreams defines model for Frontend.IndependentStreams.
type FrontendIndependentStreams string

// FrontendLogSeparateErrors defines model for Frontend.LogSeparateErrors.
type FrontendLogSeparateErrors string

// FrontendLogSteps defines model for Frontend.LogSteps.
type FrontendLogSteps string

// FrontendLogasap defines model for Frontend.Logasap.
type FrontendLogasap string

// FrontendMode defines model for Frontend.Mode.
type FrontendMode string

// FrontendNolinger defines model for Frontend.Nolinger.
type FrontendNolinger string

// FrontendSocketStats defines model for Frontend.SocketStats.
type FrontendSocketStats string

// FrontendSpliceAuto defines model for Frontend.SpliceAuto.
type FrontendSpliceAuto string

// FrontendSpliceRequest defines model for Frontend.SpliceRequest.
type FrontendSpliceRequest string

// FrontendSpliceResponse defines model for Frontend.SpliceResponse.
type FrontendSpliceResponse string

// FrontendTcpSmartAccept defines model for Frontend.TcpSmartAccept.
type FrontendTcpSmartAccept string

// FrontendTcpka defines model for Frontend.Tcpka.
type FrontendTcpka string

// FrontendBase HAProxy frontend configuration
type FrontendBase struct {
	AcceptInvalidHttpRequest            *FrontendBaseAcceptInvalidHttpRequest            `json:"accept_invalid_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpRequest *FrontendBaseAcceptUnsafeViolationsInHttpRequest `json:"accept_unsafe_violations_in_http_request,omitempty"`
	Backlog                             *int                                             `json:"backlog"`
	Clflog                              *bool                                            `json:"clflog,omitempty"`
	ClientFinTimeout                    *int                                             `json:"client_fin_timeout"`
	ClientTimeout                       *int                                             `json:"client_timeout"`
	Clitcpka                            *FrontendBaseClitcpka                            `json:"clitcpka,omitempty"`
	ClitcpkaCnt                         *int                                             `json:"clitcpka_cnt"`
	ClitcpkaIdle                        *int                                             `json:"clitcpka_idle"`
	ClitcpkaIntvl                       *int                                             `json:"clitcpka_intvl"`
	Compression                         *Compression                                     `json:"compression,omitempty"`
	Contstats                           *FrontendBaseContstats                           `json:"contstats,omitempty"`
	DefaultBackend                      *string                                          `json:"default_backend,omitempty"`
	Description                         *string                                          `json:"description,omitempty"`
	DisableH2Upgrade                    *FrontendBaseDisableH2Upgrade                    `json:"disable_h2_upgrade,omitempty"`
	Disabled                            *bool                                            `json:"disabled,omitempty"`
	DontlogNormal                       *FrontendBaseDontlogNormal                       `json:"dontlog_normal,omitempty"`
	Dontlognull                         *FrontendBaseDontlognull                         `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                          `json:"email_alert,omitempty"`
	Enabled                  *bool                                `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                         `json:"error_files,omitempty"`
	ErrorLogFormat           *string                              `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                        `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                            `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                            `json:"errorloc303,omitempty"`
	Forwardfor               *Forwardfor                          `json:"forwardfor,omitempty"`
	From                     *string                              `json:"from,omitempty"`
	Guid                     *string                              `json:"guid,omitempty"`
	H1CaseAdjustBogusClient  *FrontendBaseH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest        *FrontendBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *FrontendBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *FrontendBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *FrontendBaseHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                 `json:"http_keep_alive_timeout"`
	HttpNoDelay              *FrontendBaseHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpRequestTimeout       *int                                 `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *FrontendBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader       *FrontendBaseHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	Httplog                  *bool                                `json:"httplog,omitempty"`
	Httpslog                 *FrontendBaseHttpslog                `json:"httpslog,omitempty"`
	Id                       *int                                 `json:"id"`
	IdleCloseOnResponse      *FrontendBaseIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *FrontendBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LogFormat                *string                              `json:"log_format,omitempty"`
	LogFormatSd              *string                              `json:"log_format_sd,omitempty"`
	LogSeparateErrors        *FrontendBaseLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                 *[]FrontendBaseLogSteps              `json:"log_steps,omitempty"`
	LogTag                   *string                              `json:"log_tag,omitempty"`
	Logasap                  *FrontendBaseLogasap                 `json:"logasap,omitempty"`
	Maxconn                  *int                                 `json:"maxconn"`
	Mode                     *FrontendBaseMode                    `json:"mode,omitempty"`
	MonitorFail              *MonitorFail                         `json:"monitor_fail,omitempty"`
	MonitorUri               *MonitorUri                          `json:"monitor_uri,omitempty"`
	Name                     string                               `json:"name"`
	Nolinger                 *FrontendBaseNolinger                `json:"nolinger,omitempty"`
	Originalto               *Originalto                          `json:"originalto,omitempty"`
	SocketStats              *FrontendBaseSocketStats             `json:"socket_stats,omitempty"`
	SpliceAuto               *FrontendBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest            *FrontendBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse           *FrontendBaseSpliceResponse          `json:"splice_response,omitempty"`
	StatsOptions             *StatsOptions                        `json:"stats_options,omitempty"`
	StickTable               *ConfigStickTable                    `json:"stick_table,omitempty"`
	TarpitTimeout            *int                                 `json:"tarpit_timeout"`
	TcpSmartAccept           *FrontendBaseTcpSmartAccept          `json:"tcp_smart_accept,omitempty"`
	Tcpka                    *FrontendBaseTcpka                   `json:"tcpka,omitempty"`
	Tcplog                   *bool                                `json:"tcplog,omitempty"`
	UniqueIdFormat           *string                              `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                              `json:"unique_id_header,omitempty"`
}

// FrontendBaseAcceptInvalidHttpRequest defines model for FrontendBase.AcceptInvalidHttpRequest.
type FrontendBaseAcceptInvalidHttpRequest string

// FrontendBaseAcceptUnsafeViolationsInHttpRequest defines model for FrontendBase.AcceptUnsafeViolationsInHttpRequest.
type FrontendBaseAcceptUnsafeViolationsInHttpRequest string

// FrontendBaseClitcpka defines model for FrontendBase.Clitcpka.
type FrontendBaseClitcpka string

// FrontendBaseContstats defines model for FrontendBase.Contstats.
type FrontendBaseContstats string

// FrontendBaseDisableH2Upgrade defines model for FrontendBase.DisableH2Upgrade.
type FrontendBaseDisableH2Upgrade string

// FrontendBaseDontlogNormal defines model for FrontendBase.DontlogNormal.
type FrontendBaseDontlogNormal string

// FrontendBaseDontlognull defines model for FrontendBase.Dontlognull.
type FrontendBaseDontlognull string

// FrontendBaseH1CaseAdjustBogusClient defines model for FrontendBase.H1CaseAdjustBogusClient.
type FrontendBaseH1CaseAdjustBogusClient string

// FrontendBaseHttpBufferRequest defines model for FrontendBase.HttpBufferRequest.
type FrontendBaseHttpBufferRequest string

// FrontendBaseHttpUseHtx defines model for FrontendBase.HttpUseHtx.
type FrontendBaseHttpUseHtx string

// FrontendBaseHttpConnectionMode defines model for FrontendBase.HttpConnectionMode.
type FrontendBaseHttpConnectionMode string

// FrontendBaseHttpIgnoreProbes defines model for FrontendBase.HttpIgnoreProbes.
type FrontendBaseHttpIgnoreProbes string

// FrontendBaseHttpNoDelay defines model for FrontendBase.HttpNoDelay.
type FrontendBaseHttpNoDelay string

// FrontendBaseHttpRestrictReqHdrNames defines model for FrontendBase.HttpRestrictReqHdrNames.
type FrontendBaseHttpRestrictReqHdrNames string

// FrontendBaseHttpUseProxyHeader defines model for FrontendBase.HttpUseProxyHeader.
type FrontendBaseHttpUseProxyHeader string

// FrontendBaseHttpslog defines model for FrontendBase.Httpslog.
type FrontendBaseHttpslog string

// FrontendBaseIdleCloseOnResponse defines model for FrontendBase.IdleCloseOnResponse.
type FrontendBaseIdleCloseOnResponse string

// FrontendBaseIndependentStreams defines model for FrontendBase.IndependentStreams.
type FrontendBaseIndependentStreams string

// FrontendBaseLogSeparateErrors defines model for FrontendBase.LogSeparateErrors.
type FrontendBaseLogSeparateErrors string

// FrontendBaseLogSteps defines model for FrontendBase.LogSteps.
type FrontendBaseLogSteps string

// FrontendBaseLogasap defines model for FrontendBase.Logasap.
type FrontendBaseLogasap string

// FrontendBaseMode defines model for FrontendBase.Mode.
type FrontendBaseMode string

// FrontendBaseNolinger defines model for FrontendBase.Nolinger.
type FrontendBaseNolinger string

// FrontendBaseSocketStats defines model for FrontendBase.SocketStats.
type FrontendBaseSocketStats string

// FrontendBaseSpliceAuto defines model for FrontendBase.SpliceAuto.
type FrontendBaseSpliceAuto string

// FrontendBaseSpliceRequest defines model for FrontendBase.SpliceRequest.
type FrontendBaseSpliceRequest string

// FrontendBaseSpliceResponse defines model for FrontendBase.SpliceResponse.
type FrontendBaseSpliceResponse string

// FrontendBaseTcpSmartAccept defines model for FrontendBase.TcpSmartAccept.
type FrontendBaseTcpSmartAccept string

// FrontendBaseTcpka defines model for FrontendBase.Tcpka.
type FrontendBaseTcpka string

// Frontends HAProxy frontends array
type Frontends = []Frontend

// GeneralFile General use file
type GeneralFile struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// GeneralFiles Array of general use files
type GeneralFiles = []GeneralFile

// Global defines model for global.
type Global struct {
	Chroot          *string `json:"chroot,omitempty"`
	CloseSpreadTime *int    `json:"close_spread_time"`
	ClusterSecret   *string `json:"cluster_secret,omitempty"`
	CPUMaps         *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string               `json:"path,omitempty"`
		Type GlobalDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeDeprecatedDirectives   *bool                   `json:"expose_deprecated_directives,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	ForceCfgParserPause          *int                    `json:"force_cfg_parser_pause"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalLogSendHostnameEnabled `json:"enabled"`
		Param   *string                      `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList      *LogTargets           `json:"log_target_list,omitempty"`
	LuaOptions         *LuaOptions           `json:"lua_options,omitempty"`
	MasterWorker       *bool                 `json:"master-worker,omitempty"`
	MworkerMaxReloads  *int                  `json:"mworker_max_reloads"`
	Nbthread           *int                  `json:"nbthread,omitempty"`
	NoQuic             *bool                 `json:"no_quic,omitempty"`
	Node               *string               `json:"node,omitempty"`
	NumaCpuMapping     *GlobalNumaCpuMapping `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions    `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions   `json:"performance_options,omitempty"`
	Pidfile            *string               `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                 `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                 `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
		Address            string    `json:"address"`
		Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
		Alpn               *string   `json:"alpn,omitempty"`
		Backlog            *string   `json:"backlog,omitempty"`
		CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
		CaSignFile         *string   `json:"ca_sign_file,omitempty"`
		CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
		CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
		Ciphers            *string   `json:"ciphers,omitempty"`
		Ciphersuites       *string   `json:"ciphersuites,omitempty"`
		ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
		CrlFile            *string   `json:"crl_file,omitempty"`
		CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
		CrtList            *string   `json:"crt_list,omitempty"`
		Curves             *string   `json:"curves,omitempty"`
		DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
		DeferAccept        *bool     `json:"defer_accept,omitempty"`
		Ecdhe              *string   `json:"ecdhe,omitempty"`
		ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

		// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		ForceSslv3 *bool `json:"force_sslv3,omitempty"`

		// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

		// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

		// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

		// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		ForceTlsv13          *bool                   `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                   `json:"generate_certificates,omitempty"`
		Gid                  *int                    `json:"gid,omitempty"`
		Group                *string                 `json:"group,omitempty"`
		GuidPrefix           *string                 `json:"guid_prefix,omitempty"`
		Id                   *string                 `json:"id,omitempty"`
		Interface            *string                 `json:"interface,omitempty"`
		Level                *GlobalRuntimeApisLevel `json:"level,omitempty"`
		Maxconn              *int                    `json:"maxconn,omitempty"`
		Mode                 *string                 `json:"mode,omitempty"`
		Mss                  *string                 `json:"mss,omitempty"`
		Name                 *string                 `json:"name,omitempty"`
		Namespace            *string                 `json:"namespace,omitempty"`
		Nbconn               *int                    `json:"nbconn,omitempty"`
		Nice                 *int                    `json:"nice,omitempty"`
		NoAlpn               *bool                   `json:"no_alpn,omitempty"`
		NoCaNames            *bool                   `json:"no_ca_names,omitempty"`

		// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		NoSslv3      *bool `json:"no_sslv3,omitempty"`
		NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

		// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

		// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

		// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

		// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		NoTlsv13            *bool                            `json:"no_tlsv13,omitempty"`
		Npn                 *string                          `json:"npn,omitempty"`
		PreferClientCiphers *bool                            `json:"prefer_client_ciphers,omitempty"`
		Proto               *string                          `json:"proto,omitempty"`
		QuicCcAlgo          *GlobalRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry      *bool                            `json:"quic-force-retry,omitempty"`
		QuicSocket          *GlobalRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		QuicCcAlgoBurstSize *int                             `json:"quic_cc_algo_burst_size"`
		QuicCcAlgoMaxWindow *int                             `json:"quic_cc_algo_max_window"`
		SeverityOutput      *GlobalRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs             *string                          `json:"sigalgs,omitempty"`
		Ssl                 *bool                            `json:"ssl,omitempty"`
		SslCafile           *string                          `json:"ssl_cafile,omitempty"`
		SslCertificate      *string                          `json:"ssl_certificate,omitempty"`
		SslMaxVer           *GlobalRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer           *GlobalRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		Sslv3               *GlobalRuntimeApisSslv3          `json:"sslv3,omitempty"`
		StrictSni           *bool                            `json:"strict_sni,omitempty"`
		TcpUserTimeout      *int                             `json:"tcp_user_timeout"`
		Tfo                 *bool                            `json:"tfo,omitempty"`
		Thread              *string                          `json:"thread,omitempty"`
		TlsTicketKeys       *string                          `json:"tls_ticket_keys,omitempty"`
		Tlsv10              *GlobalRuntimeApisTlsv10         `json:"tlsv10,omitempty"`
		Tlsv11              *GlobalRuntimeApisTlsv11         `json:"tlsv11,omitempty"`
		Tlsv12              *GlobalRuntimeApisTlsv12         `json:"tlsv12,omitempty"`
		Tlsv13              *GlobalRuntimeApisTlsv13         `json:"tlsv13,omitempty"`
		Transparent         *bool                            `json:"transparent,omitempty"`
		Uid                 *string                          `json:"uid,omitempty"`
		User                *string                          `json:"user,omitempty"`
		V4v6                *bool                            `json:"v4v6,omitempty"`
		V6only              *bool                            `json:"v6only,omitempty"`
		Verify              *GlobalRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`
	SetDumpable *bool `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap           *string     `json:"setcap,omitempty"`
	SslOptions       *SslOptions `json:"ssl_options,omitempty"`
	StatsFile        *string     `json:"stats_file,omitempty"`
	StatsMaxconn     *int        `json:"stats_maxconn"`
	StatsTimeout     *int        `json:"stats_timeout"`
	StrictLimits     *bool       `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups            *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions       *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions          *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions             *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions         *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions          *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions         *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions         *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid                     *int               `json:"uid,omitempty"`
	UlimitN                 *int               `json:"ulimit_n,omitempty"`
	User                    *string            `json:"user,omitempty"`
	WarnBlockedTrafficAfter *int               `json:"warn_blocked_traffic_after"`
	WurflOptions            *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalDefaultPathType defines model for Global.DefaultPath.Type.
type GlobalDefaultPathType string

// GlobalHardenRejectPrivilegedPortsQuic defines model for Global.Harden.RejectPrivilegedPorts.Quic.
type GlobalHardenRejectPrivilegedPortsQuic string

// GlobalHardenRejectPrivilegedPortsTcp defines model for Global.Harden.RejectPrivilegedPorts.Tcp.
type GlobalHardenRejectPrivilegedPortsTcp string

// GlobalLogSendHostnameEnabled defines model for Global.LogSendHostname.Enabled.
type GlobalLogSendHostnameEnabled string

// GlobalNumaCpuMapping defines model for Global.NumaCpuMapping.
type GlobalNumaCpuMapping string

// GlobalRuntimeApisLevel defines model for Global.RuntimeApis.Level.
type GlobalRuntimeApisLevel string

// GlobalRuntimeApisQuicCcAlgo defines model for Global.RuntimeApis.QuicCcAlgo.
type GlobalRuntimeApisQuicCcAlgo string

// GlobalRuntimeApisQuicSocket defines model for Global.RuntimeApis.QuicSocket.
type GlobalRuntimeApisQuicSocket string

// GlobalRuntimeApisSeverityOutput defines model for Global.RuntimeApis.SeverityOutput.
type GlobalRuntimeApisSeverityOutput string

// GlobalRuntimeApisSslMaxVer defines model for Global.RuntimeApis.SslMaxVer.
type GlobalRuntimeApisSslMaxVer string

// GlobalRuntimeApisSslMinVer defines model for Global.RuntimeApis.SslMinVer.
type GlobalRuntimeApisSslMinVer string

// GlobalRuntimeApisSslv3 defines model for Global.RuntimeApis.Sslv3.
type GlobalRuntimeApisSslv3 string

// GlobalRuntimeApisTlsv10 defines model for Global.RuntimeApis.Tlsv10.
type GlobalRuntimeApisTlsv10 string

// GlobalRuntimeApisTlsv11 defines model for Global.RuntimeApis.Tlsv11.
type GlobalRuntimeApisTlsv11 string

// GlobalRuntimeApisTlsv12 defines model for Global.RuntimeApis.Tlsv12.
type GlobalRuntimeApisTlsv12 string

// GlobalRuntimeApisTlsv13 defines model for Global.RuntimeApis.Tlsv13.
type GlobalRuntimeApisTlsv13 string

// GlobalRuntimeApisVerify defines model for Global.RuntimeApis.Verify.
type GlobalRuntimeApisVerify string

// GlobalBase HAProxy global configuration
type GlobalBase struct {
	Chroot          *string `json:"chroot,omitempty"`
	CloseSpreadTime *int    `json:"close_spread_time"`
	ClusterSecret   *string `json:"cluster_secret,omitempty"`
	CPUMaps         *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string                   `json:"path,omitempty"`
		Type GlobalBaseDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeDeprecatedDirectives   *bool                   `json:"expose_deprecated_directives,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	ForceCfgParserPause          *int                    `json:"force_cfg_parser_pause"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalBaseHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalBaseHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalBaseLogSendHostnameEnabled `json:"enabled"`
		Param   *string                          `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`
	LuaOptions         *LuaOptions               `json:"lua_options,omitempty"`
	MasterWorker       *bool                     `json:"master-worker,omitempty"`
	MworkerMaxReloads  *int                      `json:"mworker_max_reloads"`
	Nbthread           *int                      `json:"nbthread,omitempty"`
	NoQuic             *bool                     `json:"no_quic,omitempty"`
	Node               *string                   `json:"node,omitempty"`
	NumaCpuMapping     *GlobalBaseNumaCpuMapping `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions        `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions       `json:"performance_options,omitempty"`
	Pidfile            *string                   `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                     `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                     `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
		Address            string    `json:"address"`
		Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
		Alpn               *string   `json:"alpn,omitempty"`
		Backlog            *string   `json:"backlog,omitempty"`
		CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
		CaSignFile         *string   `json:"ca_sign_file,omitempty"`
		CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
		CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
		Ciphers            *string   `json:"ciphers,omitempty"`
		Ciphersuites       *string   `json:"ciphersuites,omitempty"`
		ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
		CrlFile            *string   `json:"crl_file,omitempty"`
		CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
		CrtList            *string   `json:"crt_list,omitempty"`
		Curves             *string   `json:"curves,omitempty"`
		DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
		DeferAccept        *bool     `json:"defer_accept,omitempty"`
		Ecdhe              *string   `json:"ecdhe,omitempty"`
		ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

		// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		ForceSslv3 *bool `json:"force_sslv3,omitempty"`

		// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

		// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

		// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

		// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		ForceTlsv13          *bool                       `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                       `json:"generate_certificates,omitempty"`
		Gid                  *int                        `json:"gid,omitempty"`
		Group                *string                     `json:"group,omitempty"`
		GuidPrefix           *string                     `json:"guid_prefix,omitempty"`
		Id                   *string                     `json:"id,omitempty"`
		Interface            *string                     `json:"interface,omitempty"`
		Level                *GlobalBaseRuntimeApisLevel `json:"level,omitempty"`
		Maxconn              *int                        `json:"maxconn,omitempty"`
		Mode                 *string                     `json:"mode,omitempty"`
		Mss                  *string                     `json:"mss,omitempty"`
		Name                 *string                     `json:"name,omitempty"`
		Namespace            *string                     `json:"namespace,omitempty"`
		Nbconn               *int                        `json:"nbconn,omitempty"`
		Nice                 *int                        `json:"nice,omitempty"`
		NoAlpn               *bool                       `json:"no_alpn,omitempty"`
		NoCaNames            *bool                       `json:"no_ca_names,omitempty"`

		// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		NoSslv3      *bool `json:"no_sslv3,omitempty"`
		NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

		// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

		// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

		// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

		// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		NoTlsv13            *bool                                `json:"no_tlsv13,omitempty"`
		Npn                 *string                              `json:"npn,omitempty"`
		PreferClientCiphers *bool                                `json:"prefer_client_ciphers,omitempty"`
		Proto               *string                              `json:"proto,omitempty"`
		QuicCcAlgo          *GlobalBaseRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry      *bool                                `json:"quic-force-retry,omitempty"`
		QuicSocket          *GlobalBaseRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		QuicCcAlgoBurstSize *int                                 `json:"quic_cc_algo_burst_size"`
		QuicCcAlgoMaxWindow *int                                 `json:"quic_cc_algo_max_window"`
		SeverityOutput      *GlobalBaseRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs             *string                              `json:"sigalgs,omitempty"`
		Ssl                 *bool                                `json:"ssl,omitempty"`
		SslCafile           *string                              `json:"ssl_cafile,omitempty"`
		SslCertificate      *string                              `json:"ssl_certificate,omitempty"`
		SslMaxVer           *GlobalBaseRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer           *GlobalBaseRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		Sslv3               *GlobalBaseRuntimeApisSslv3          `json:"sslv3,omitempty"`
		StrictSni           *bool                                `json:"strict_sni,omitempty"`
		TcpUserTimeout      *int                                 `json:"tcp_user_timeout"`
		Tfo                 *bool                                `json:"tfo,omitempty"`
		Thread              *string                              `json:"thread,omitempty"`
		TlsTicketKeys       *string                              `json:"tls_ticket_keys,omitempty"`
		Tlsv10              *GlobalBaseRuntimeApisTlsv10         `json:"tlsv10,omitempty"`
		Tlsv11              *GlobalBaseRuntimeApisTlsv11         `json:"tlsv11,omitempty"`
		Tlsv12              *GlobalBaseRuntimeApisTlsv12         `json:"tlsv12,omitempty"`
		Tlsv13              *GlobalBaseRuntimeApisTlsv13         `json:"tlsv13,omitempty"`
		Transparent         *bool                                `json:"transparent,omitempty"`
		Uid                 *string                              `json:"uid,omitempty"`
		User                *string                              `json:"user,omitempty"`
		V4v6                *bool                                `json:"v4v6,omitempty"`
		V6only              *bool                                `json:"v6only,omitempty"`
		Verify              *GlobalBaseRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`
	SetDumpable *bool `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap           *string     `json:"setcap,omitempty"`
	SslOptions       *SslOptions `json:"ssl_options,omitempty"`
	StatsFile        *string     `json:"stats_file,omitempty"`
	StatsMaxconn     *int        `json:"stats_maxconn"`
	StatsTimeout     *int        `json:"stats_timeout"`
	StrictLimits     *bool       `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups            *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions       *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions          *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions             *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions         *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions          *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions         *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions         *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid                     *int               `json:"uid,omitempty"`
	UlimitN                 *int               `json:"ulimit_n,omitempty"`
	User                    *string            `json:"user,omitempty"`
	WarnBlockedTrafficAfter *int               `json:"warn_blocked_traffic_after"`
	WurflOptions            *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalBaseDefaultPathType defines model for GlobalBase.DefaultPath.Type.
type GlobalBaseDefaultPathType string

// GlobalBaseHardenRejectPrivilegedPortsQuic defines model for GlobalBase.Harden.RejectPrivilegedPorts.Quic.
type GlobalBaseHardenRejectPrivilegedPortsQuic string

// GlobalBaseHardenRejectPrivilegedPortsTcp defines model for GlobalBase.Harden.RejectPrivilegedPorts.Tcp.
type GlobalBaseHardenRejectPrivilegedPortsTcp string

// GlobalBaseLogSendHostnameEnabled defines model for GlobalBase.LogSendHostname.Enabled.
type GlobalBaseLogSendHostnameEnabled string

// GlobalBaseNumaCpuMapping defines model for GlobalBase.NumaCpuMapping.
type GlobalBaseNumaCpuMapping string

// GlobalBaseRuntimeApisLevel defines model for GlobalBase.RuntimeApis.Level.
type GlobalBaseRuntimeApisLevel string

// GlobalBaseRuntimeApisQuicCcAlgo defines model for GlobalBase.RuntimeApis.QuicCcAlgo.
type GlobalBaseRuntimeApisQuicCcAlgo string

// GlobalBaseRuntimeApisQuicSocket defines model for GlobalBase.RuntimeApis.QuicSocket.
type GlobalBaseRuntimeApisQuicSocket string

// GlobalBaseRuntimeApisSeverityOutput defines model for GlobalBase.RuntimeApis.SeverityOutput.
type GlobalBaseRuntimeApisSeverityOutput string

// GlobalBaseRuntimeApisSslMaxVer defines model for GlobalBase.RuntimeApis.SslMaxVer.
type GlobalBaseRuntimeApisSslMaxVer string

// GlobalBaseRuntimeApisSslMinVer defines model for GlobalBase.RuntimeApis.SslMinVer.
type GlobalBaseRuntimeApisSslMinVer string

// GlobalBaseRuntimeApisSslv3 defines model for GlobalBase.RuntimeApis.Sslv3.
type GlobalBaseRuntimeApisSslv3 string

// GlobalBaseRuntimeApisTlsv10 defines model for GlobalBase.RuntimeApis.Tlsv10.
type GlobalBaseRuntimeApisTlsv10 string

// GlobalBaseRuntimeApisTlsv11 defines model for GlobalBase.RuntimeApis.Tlsv11.
type GlobalBaseRuntimeApisTlsv11 string

// GlobalBaseRuntimeApisTlsv12 defines model for GlobalBase.RuntimeApis.Tlsv12.
type GlobalBaseRuntimeApisTlsv12 string

// GlobalBaseRuntimeApisTlsv13 defines model for GlobalBase.RuntimeApis.Tlsv13.
type GlobalBaseRuntimeApisTlsv13 string

// GlobalBaseRuntimeApisVerify defines model for GlobalBase.RuntimeApis.Verify.
type GlobalBaseRuntimeApisVerify string

// Group HAProxy userlist group
type Group struct {
	Name  string  `json:"name"`
	Users *string `json:"users,omitempty"`
}

// Groups HAProxy userlist groups array
type Groups = []Group

// HashType defines model for hash_type.
type HashType struct {
	Function *HashTypeFunction `json:"function,omitempty"`
	Method   *HashTypeMethod   `json:"method,omitempty"`
	Modifier *HashTypeModifier `json:"modifier,omitempty"`
}

// HashTypeFunction defines model for HashType.Function.
type HashTypeFunction string

// HashTypeMethod defines model for HashType.Method.
type HashTypeMethod string

// HashTypeModifier defines model for HashType.Modifier.
type HashTypeModifier string

// Health defines model for health.
type Health struct {
	Haproxy *HealthHaproxy `json:"haproxy,omitempty"`
}

// HealthHaproxy defines model for Health.Haproxy.
type HealthHaproxy string

// HttpAfterResponseRule HAProxy HTTP after response rule configuration (corresponds to http-after-response directives)
type HttpAfterResponseRule struct {
	AclFile       *string                          `json:"acl_file,omitempty"`
	AclKeyfmt     *string                          `json:"acl_keyfmt,omitempty"`
	CaptureId     *int                             `json:"capture_id"`
	CaptureLen    *int                             `json:"capture_len,omitempty"`
	CaptureSample *string                          `json:"capture_sample,omitempty"`
	Cond          *HttpAfterResponseRuleCond       `json:"cond,omitempty"`
	CondTest      *string                          `json:"cond_test,omitempty"`
	HdrFormat     *string                          `json:"hdr_format,omitempty"`
	HdrMatch      *string                          `json:"hdr_match,omitempty"`
	HdrMethod     *string                          `json:"hdr_method,omitempty"`
	HdrName       *string                          `json:"hdr_name,omitempty"`
	LogLevel      *HttpAfterResponseRuleLogLevel   `json:"log_level,omitempty"`
	MapFile       *string                          `json:"map_file,omitempty"`
	MapKeyfmt     *string                          `json:"map_keyfmt,omitempty"`
	MapValuefmt   *string                          `json:"map_valuefmt,omitempty"`
	ScExpr        *string                          `json:"sc_expr,omitempty"`
	ScId          *int                             `json:"sc_id,omitempty"`
	ScIdx         *int                             `json:"sc_idx,omitempty"`
	ScInt         *int                             `json:"sc_int"`
	Status        *int                             `json:"status,omitempty"`
	StatusReason  *string                          `json:"status_reason,omitempty"`
	StrictMode    *HttpAfterResponseRuleStrictMode `json:"strict_mode,omitempty"`
	Type          HttpAfterResponseRuleType        `json:"type"`
	VarExpr       *string                          `json:"var_expr,omitempty"`
	VarFormat     *string                          `json:"var_format,omitempty"`
	VarName       *string                          `json:"var_name,omitempty"`
	VarScope      *string                          `json:"var_scope,omitempty"`
}

// HttpAfterResponseRuleCond defines model for HttpAfterResponseRule.Cond.
type HttpAfterResponseRuleCond string

// HttpAfterResponseRuleLogLevel defines model for HttpAfterResponseRule.LogLevel.
type HttpAfterResponseRuleLogLevel string

// HttpAfterResponseRuleStrictMode defines model for HttpAfterResponseRule.StrictMode.
type HttpAfterResponseRuleStrictMode string

// HttpAfterResponseRuleType defines model for HttpAfterResponseRule.Type.
type HttpAfterResponseRuleType string

// HttpAfterResponseRules HAProxy HTTP after response rules array (corresponds to http-after-response directives)
type HttpAfterResponseRules = []HttpAfterResponseRule

// HttpCheck defines model for http_check.
type HttpCheck struct {
	Addr            *string               `json:"addr,omitempty"`
	Alpn            *string               `json:"alpn,omitempty"`
	Body            *string               `json:"body,omitempty"`
	BodyLogFormat   *string               `json:"body_log_format,omitempty"`
	CheckComment    *string               `json:"check_comment,omitempty"`
	Default         *bool                 `json:"default,omitempty"`
	ErrorStatus     *HttpCheckErrorStatus `json:"error_status,omitempty"`
	ExclamationMark *bool                 `json:"exclamation_mark,omitempty"`
	CheckHeaders    *[]ReturnHeader       `json:"headers,omitempty"`
	Linger          *bool                 `json:"linger,omitempty"`
	Match           *HttpCheckMatch       `json:"match,omitempty"`
	Method          *HttpCheckMethod      `json:"method,omitempty"`
	MinRecv         *int                  `json:"min_recv"`
	OkStatus        *HttpCheckOkStatus    `json:"ok_status,omitempty"`
	OnError         *string               `json:"on_error,omitempty"`
	OnSuccess       *string               `json:"on_success,omitempty"`
	Pattern         *string               `json:"pattern,omitempty"`
	Port            *int                  `json:"port"`
	PortString      *string               `json:"port_string,omitempty"`
	Proto           *string               `json:"proto,omitempty"`
	SendProxy       *bool                 `json:"send_proxy,omitempty"`
	Sni             *string               `json:"sni,omitempty"`
	Ssl             *bool                 `json:"ssl,omitempty"`
	StatusCode      *string               `json:"status-code,omitempty"`
	ToutStatus      *HttpCheckToutStatus  `json:"tout_status,omitempty"`
	Type            HttpCheckType         `json:"type"`
	Uri             *string               `json:"uri,omitempty"`
	UriLogFormat    *string               `json:"uri_log_format,omitempty"`
	VarExpr         *string               `json:"var_expr,omitempty"`
	VarFormat       *string               `json:"var_format,omitempty"`
	VarName         *string               `json:"var_name,omitempty"`
	VarScope        *string               `json:"var_scope,omitempty"`
	Version         *string               `json:"version,omitempty"`
	ViaSocks4       *bool                 `json:"via_socks4,omitempty"`
}

// HttpCheckErrorStatus defines model for HttpCheck.ErrorStatus.
type HttpCheckErrorStatus string

// HttpCheckMatch defines model for HttpCheck.Match.
type HttpCheckMatch string

// HttpCheckMethod defines model for HttpCheck.Method.
type HttpCheckMethod string

// HttpCheckOkStatus defines model for HttpCheck.OkStatus.
type HttpCheckOkStatus string

// HttpCheckToutStatus defines model for HttpCheck.ToutStatus.
type HttpCheckToutStatus string

// HttpCheckType defines model for HttpCheck.Type.
type HttpCheckType string

// HttpChecks defines model for http_checks.
type HttpChecks = []HttpCheck

// HttpClientOptions defines model for http_client_options.
type HttpClientOptions struct {
	ResolversDisabled *HttpClientOptionsResolversDisabled `json:"resolvers_disabled,omitempty"`
	ResolversId       *string                             `json:"resolvers_id,omitempty"`
	ResolversPrefer   *HttpClientOptionsResolversPrefer   `json:"resolvers_prefer,omitempty"`
	Retries           *int                                `json:"retries,omitempty"`
	SslCaFile         *string                             `json:"ssl_ca_file,omitempty"`
	SslVerify         *HttpClientOptionsSslVerify         `json:"ssl_verify"`
	TimeoutConnect    *int                                `json:"timeout_connect"`
}

// HttpClientOptionsResolversDisabled defines model for HttpClientOptions.ResolversDisabled.
type HttpClientOptionsResolversDisabled string

// HttpClientOptionsResolversPrefer defines model for HttpClientOptions.ResolversPrefer.
type HttpClientOptionsResolversPrefer string

// HttpClientOptionsSslVerify defines model for HttpClientOptions.SslVerify.
type HttpClientOptionsSslVerify string

// HTTPCodes defines model for http_codes.
type HTTPCodes struct {
	Value string `json:"value"`
}

// HttpErrorRule HAProxy HTTP error rule configuration (corresponds to http-error directives)
type HttpErrorRule struct {
	ReturnContent       *string                           `json:"return_content,omitempty"`
	ReturnContentFormat *HttpErrorRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType   *string                           `json:"return_content_type"`
	ReturnHeaders       *[]ReturnHeader                   `json:"return_hdrs,omitempty"`
	Status              HttpErrorRuleStatus               `json:"status"`
	Type                HttpErrorRuleType                 `json:"type"`
}

// HttpErrorRuleReturnContentFormat defines model for HttpErrorRule.ReturnContentFormat.
type HttpErrorRuleReturnContentFormat string

// HttpErrorRuleStatus defines model for HttpErrorRule.Status.
type HttpErrorRuleStatus int

// HttpErrorRuleType defines model for HttpErrorRule.Type.
type HttpErrorRuleType string

// HttpErrorRules HAProxy HTTP error rules array (corresponds to http-error directives)
type HttpErrorRules = []HttpErrorRule

// HttpErrorsSection A globally declared group of HTTP errors
type HttpErrorsSection struct {
	ErrorFiles []Errorfile `json:"error_files"`
	Name       string      `json:"name"`
}

// HttpErrorsSections An array of HAProxy http-error sections
type HttpErrorsSections = []HttpErrorsSection

// HttpRequestRule HAProxy HTTP request rule configuration (corresponds to http-request directives)
type HttpRequestRule struct {
	AclFile              *string                             `json:"acl_file,omitempty"`
	AclKeyfmt            *string                             `json:"acl_keyfmt,omitempty"`
	AuthRealm            *string                             `json:"auth_realm,omitempty"`
	BandwidthLimitLimit  *string                             `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                             `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                             `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                             `json:"cache_name,omitempty"`
	CaptureId            *int                                `json:"capture_id"`
	CaptureLen           *int                                `json:"capture_len,omitempty"`
	CaptureSample        *string                             `json:"capture_sample,omitempty"`
	Cond                 *HttpRequestRuleCond                `json:"cond,omitempty"`
	CondTest             *string                             `json:"cond_test,omitempty"`
	DenyStatus           *int                                `json:"deny_status"`
	Expr                 *string                             `json:"expr,omitempty"`
	HdrFormat            *string                             `json:"hdr_format,omitempty"`
	HdrMatch             *string                             `json:"hdr_match,omitempty"`
	HdrMethod            *string                             `json:"hdr_method,omitempty"`
	HdrName              *string                             `json:"hdr_name,omitempty"`
	HintFormat           *string                             `json:"hint_format,omitempty"`
	HintName             *string                             `json:"hint_name,omitempty"`
	LogLevel             *HttpRequestRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                             `json:"lua_action,omitempty"`
	LuaParams            *string                             `json:"lua_params,omitempty"`
	MapFile              *string                             `json:"map_file,omitempty"`
	MapKeyfmt            *string                             `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                             `json:"map_valuefmt,omitempty"`
	MarkValue            *string                             `json:"mark_value,omitempty"`
	MethodFmt            *string                             `json:"method_fmt,omitempty"`
	NiceValue            *int                                `json:"nice_value,omitempty"`
	Normalizer           *HttpRequestRuleNormalizer          `json:"normalizer,omitempty"`
	NormalizerFull       *bool                               `json:"normalizer_full,omitempty"`
	NormalizerStrict     *bool                               `json:"normalizer_strict,omitempty"`
	PathFmt              *string                             `json:"path_fmt,omitempty"`
	PathMatch            *string                             `json:"path_match,omitempty"`
	Protocol             *HttpRequestRuleProtocol            `json:"protocol,omitempty"`
	QueryFmt             *string                             `json:"query-fmt,omitempty"`
	RedirCode            *HttpRequestRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                             `json:"redir_option,omitempty"`
	RedirType            *HttpRequestRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                             `json:"redir_value,omitempty"`
	Resolvers            *string                             `json:"resolvers,omitempty"`
	ReturnContent        *string                             `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpRequestRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                             `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                     `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                `json:"return_status_code"`
	RstTtl               *int                                `json:"rst_ttl,omitempty"`
	ScExpr               *string                             `json:"sc_expr,omitempty"`
	ScId                 *int                                `json:"sc_id,omitempty"`
	ScIdx                *int                                `json:"sc_idx,omitempty"`
	ScInt                *int                                `json:"sc_int"`
	ServiceName          *string                             `json:"service_name,omitempty"`
	SpoeEngine           *string                             `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                             `json:"spoe_group,omitempty"`
	StrictMode           *HttpRequestRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                             `json:"timeout,omitempty"`
	TimeoutType          *HttpRequestRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                             `json:"tos_value,omitempty"`
	TrackScKey           *string                             `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                `json:"track_sc_stick_counter"`
	TrackScTable         *string                             `json:"track_sc_table,omitempty"`
	Type                 HttpRequestRuleType                 `json:"type"`
	UriFmt               *string                             `json:"uri-fmt,omitempty"`
	UriMatch             *string                             `json:"uri-match,omitempty"`
	VarExpr              *string                             `json:"var_expr,omitempty"`
	VarFormat            *string                             `json:"var_format,omitempty"`
	VarName              *string                             `json:"var_name,omitempty"`
	VarScope             *string                             `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                `json:"wait_at_least"`
	WaitTime             *int                                `json:"wait_time"`
}

// HttpRequestRuleCond defines model for HttpRequestRule.Cond.
type HttpRequestRuleCond string

// HttpRequestRuleLogLevel defines model for HttpRequestRule.LogLevel.
type HttpRequestRuleLogLevel string

// HttpRequestRuleNormalizer defines model for HttpRequestRule.Normalizer.
type HttpRequestRuleNormalizer string

// HttpRequestRuleProtocol defines model for HttpRequestRule.Protocol.
type HttpRequestRuleProtocol string

// HttpRequestRuleRedirCode defines model for HttpRequestRule.RedirCode.
type HttpRequestRuleRedirCode int

// HttpRequestRuleRedirType defines model for HttpRequestRule.RedirType.
type HttpRequestRuleRedirType string

// HttpRequestRuleReturnContentFormat defines model for HttpRequestRule.ReturnContentFormat.
type HttpRequestRuleReturnContentFormat string

// HttpRequestRuleStrictMode defines model for HttpRequestRule.StrictMode.
type HttpRequestRuleStrictMode string

// HttpRequestRuleTimeoutType defines model for HttpRequestRule.TimeoutType.
type HttpRequestRuleTimeoutType string

// HttpRequestRuleType defines model for HttpRequestRule.Type.
type HttpRequestRuleType string

// HttpRequestRules HAProxy HTTP request rules array (corresponds to http-request directives)
type HttpRequestRules = []HttpRequestRule

// HttpResponseRule HAProxy HTTP response rule configuration (corresponds to http-response directives)
type HttpResponseRule struct {
	AclFile              *string                              `json:"acl_file,omitempty"`
	AclKeyfmt            *string                              `json:"acl_keyfmt,omitempty"`
	BandwidthLimitLimit  *string                              `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                              `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                              `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                              `json:"cache_name,omitempty"`
	CaptureId            *int                                 `json:"capture_id"`
	CaptureSample        *string                              `json:"capture_sample,omitempty"`
	Cond                 *HttpResponseRuleCond                `json:"cond,omitempty"`
	CondTest             *string                              `json:"cond_test,omitempty"`
	DenyStatus           *int                                 `json:"deny_status"`
	Expr                 *string                              `json:"expr,omitempty"`
	HdrFormat            *string                              `json:"hdr_format,omitempty"`
	HdrMatch             *string                              `json:"hdr_match,omitempty"`
	HdrMethod            *string                              `json:"hdr_method,omitempty"`
	HdrName              *string                              `json:"hdr_name,omitempty"`
	LogLevel             *HttpResponseRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                              `json:"lua_action,omitempty"`
	LuaParams            *string                              `json:"lua_params,omitempty"`
	MapFile              *string                              `json:"map_file,omitempty"`
	MapKeyfmt            *string                              `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                              `json:"map_valuefmt,omitempty"`
	MarkValue            *string                              `json:"mark_value,omitempty"`
	NiceValue            *int                                 `json:"nice_value,omitempty"`
	RedirCode            *HttpResponseRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                              `json:"redir_option,omitempty"`
	RedirType            *HttpResponseRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                              `json:"redir_value,omitempty"`
	ReturnContent        *string                              `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpResponseRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                              `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                      `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                 `json:"return_status_code"`
	RstTtl               *int                                 `json:"rst_ttl,omitempty"`
	ScExpr               *string                              `json:"sc_expr,omitempty"`
	ScId                 *int                                 `json:"sc_id,omitempty"`
	ScIdx                *int                                 `json:"sc_idx,omitempty"`
	ScInt                *int                                 `json:"sc_int"`
	SpoeEngine           *string                              `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                              `json:"spoe_group,omitempty"`
	Status               *int                                 `json:"status,omitempty"`
	StatusReason         *string                              `json:"status_reason,omitempty"`
	StrictMode           *HttpResponseRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                              `json:"timeout,omitempty"`
	TimeoutType          *HttpResponseRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                              `json:"tos_value,omitempty"`
	TrackScKey           *string                              `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                 `json:"track_sc_stick_counter"`
	TrackScTable         *string                              `json:"track_sc_table,omitempty"`
	Type                 HttpResponseRuleType                 `json:"type"`
	VarExpr              *string                              `json:"var_expr,omitempty"`
	VarFormat            *string                              `json:"var_format,omitempty"`
	VarName              *string                              `json:"var_name,omitempty"`
	VarScope             *string                              `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                 `json:"wait_at_least"`
	WaitTime             *int                                 `json:"wait_time"`
}

// HttpResponseRuleCond defines model for HttpResponseRule.Cond.
type HttpResponseRuleCond string

// HttpResponseRuleLogLevel defines model for HttpResponseRule.LogLevel.
type HttpResponseRuleLogLevel string

// HttpResponseRuleRedirCode defines model for HttpResponseRule.RedirCode.
type HttpResponseRuleRedirCode int

// HttpResponseRuleRedirType defines model for HttpResponseRule.RedirType.
type HttpResponseRuleRedirType string

// HttpResponseRuleReturnContentFormat defines model for HttpResponseRule.ReturnContentFormat.
type HttpResponseRuleReturnContentFormat string

// HttpResponseRuleStrictMode defines model for HttpResponseRule.StrictMode.
type HttpResponseRuleStrictMode string

// HttpResponseRuleTimeoutType defines model for HttpResponseRule.TimeoutType.
type HttpResponseRuleTimeoutType string

// HttpResponseRuleType defines model for HttpResponseRule.Type.
type HttpResponseRuleType string

// HttpResponseRules HAProxy HTTP response rules array (corresponds to http-response directives)
type HttpResponseRules = []HttpResponseRule

// HttpchkParams defines model for httpchk_params.
type HttpchkParams struct {
	Host    *string              `json:"host,omitempty"`
	Method  *HttpchkParamsMethod `json:"method,omitempty"`
	Uri     *string              `json:"uri,omitempty"`
	Version *string              `json:"version,omitempty"`
}

// HttpchkParamsMethod defines model for HttpchkParams.Method.
type HttpchkParamsMethod string

// Info General API, OS and hardware information
type Info struct {
	Api *struct {
		// BuildDate HAProxy Dataplane API build date
		BuildDate *time.Time `json:"build_date,omitempty"`

		// Version HAProxy Dataplane API version string
		Version *string `json:"version,omitempty"`
	} `json:"api,omitempty"`
	System *struct {
		CpuInfo *struct {
			Model *string `json:"model,omitempty"`

			// NumCpus Number of logical CPUs
			NumCpus *int `json:"num_cpus,omitempty"`
		} `json:"cpu_info,omitempty"`

		// Hostname Hostname where the HAProxy is running
		Hostname *string `json:"hostname,omitempty"`
		MemInfo  *struct {
			DataplaneapiMemory *int `json:"dataplaneapi_memory,omitempty"`
			FreeMemory         *int `json:"free_memory,omitempty"`
			TotalMemory        *int `json:"total_memory,omitempty"`
		} `json:"mem_info,omitempty"`

		// OsString OS string
		OsString *string `json:"os_string,omitempty"`

		// Time Current time in milliseconds since Epoch.
		Time *int `json:"time,omitempty"`

		// Uptime System uptime
		Uptime *int `json:"uptime"`
	} `json:"system,omitempty"`
}

// LogForward defines model for log_forward.
type LogForward struct {
	Backlog    *int                  `json:"backlog"`
	Binds      *map[string]Bind      `json:"binds,omitempty"`
	DgramBinds *map[string]DgramBind `json:"dgram_binds,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets `json:"log_target_list,omitempty"`
	Maxconn       *int        `json:"maxconn"`
	Name          string      `json:"name"`
	TimeoutClient *int        `json:"timeout_client"`
}

// LogForwardBase HAProxy log forward configuration
type LogForwardBase struct {
	Backlog       *int   `json:"backlog"`
	Maxconn       *int   `json:"maxconn"`
	Name          string `json:"name"`
	TimeoutClient *int   `json:"timeout_client"`
}

// LogForwards HAProxy log forwards array
type LogForwards = []LogForward

// LogProfile Defines a logging profile for one or more steps.
type LogProfile struct {
	// LogTag Override syslog log tag set by other "log-tag" directives.
	LogTag *string `json:"log_tag,omitempty"`

	// Name Name of the logging profile.
	Name string `json:"name"`

	// Steps List of steps where to override the logging.
	Steps *LogProfileSteps `json:"steps,omitempty"`
}

// LogProfileStep Defines what to log for a given step.
type LogProfileStep struct {
	// Drop If enabled, no log shall be emitted for the given step.
	Drop *LogProfileStepDrop `json:"drop,omitempty"`

	// Format Override "log-format" or "error-log-format" strings depending on the step.
	Format *string `json:"format,omitempty"`

	// Sd Override the "log-format-sd" string.
	Sd *string `json:"sd,omitempty"`

	// Step Logging step name.
	Step LogProfileStepStep `json:"step"`
}

// LogProfileStepDrop If enabled, no log shall be emitted for the given step.
type LogProfileStepDrop string

// LogProfileStepStep Logging step name.
type LogProfileStepStep string

// LogProfileSteps List of steps where to override the logging.
type LogProfileSteps = []LogProfileStep

// LogProfiles List of Logging Profiles
type LogProfiles = []LogProfile

// LogTarget Per-instance logging of events and traffic.
type LogTarget struct {
	Address     *string            `json:"address,omitempty"`
	Facility    *LogTargetFacility `json:"facility,omitempty"`
	Format      *LogTargetFormat   `json:"format,omitempty"`
	Global      *bool              `json:"global,omitempty"`
	Length      *int               `json:"length,omitempty"`
	Level       *LogTargetLevel    `json:"level,omitempty"`
	Minlevel    *LogTargetMinlevel `json:"minlevel,omitempty"`
	Nolog       *bool              `json:"nolog,omitempty"`
	Profile     *string            `json:"profile,omitempty"`
	SampleRange *string            `json:"sample_range,omitempty"`
	SampleSize  *int               `json:"sample_size,omitempty"`
}

// LogTargetFacility defines model for LogTarget.Facility.
type LogTargetFacility string

// LogTargetFormat defines model for LogTarget.Format.
type LogTargetFormat string

// LogTargetLevel defines model for LogTarget.Level.
type LogTargetLevel string

// LogTargetMinlevel defines model for LogTarget.Minlevel.
type LogTargetMinlevel string

// LogTargets HAProxy log target array (corresponds to log directives)
type LogTargets = []LogTarget

// LuaOptions defines model for lua_options.
type LuaOptions struct {
	LoadPerThread *string `json:"load_per_thread,omitempty"`
	Loads         *[]struct {
		File string `json:"file"`
	} `json:"loads,omitempty"`
	PrependPath *[]struct {
		Path string                     `json:"path"`
		Type *LuaOptionsPrependPathType `json:"type,omitempty"`
	} `json:"prepend_path,omitempty"`
}

// LuaOptionsPrependPathType defines model for LuaOptions.PrependPath.Type.
type LuaOptionsPrependPathType string

// MailerEntries HAProxy mailer entries
type MailerEntries = []MailerEntry

// MailerEntry Mailer entry of a Mailers section
type MailerEntry struct {
	Address string `json:"address"`
	Name    string `json:"name"`
	Port    int    `json:"port"`
}

// MailersSection defines model for mailers_section.
type MailersSection struct {
	MailerEntries *map[string]MailerEntry `json:"mailer_entries,omitempty"`
	Name          string                  `json:"name"`
	Timeout       *int                    `json:"timeout"`
}

// MailersSectionBase A list of SMTP servers used by HAProxy to send emails.
type MailersSectionBase struct {
	Name    string `json:"name"`
	Timeout *int   `json:"timeout"`
}

// MailersSections HAProxy mailers_section array
type MailersSections = []MailersSection

// Map Map File
type Map struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// MapEntries Entries of one runtime map
type MapEntries = []MapEntry

// MapEntry One Map Entry
type MapEntry struct {
	Id    *string `json:"id,omitempty"`
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Maps Array of runtime map files
type Maps = []Map

// MonitorFail defines model for monitor_fail.
type MonitorFail struct {
	Cond     MonitorFailCond `json:"cond"`
	CondTest string          `json:"cond_test"`
}

// MonitorFailCond defines model for MonitorFail.Cond.
type MonitorFailCond string

// MonitorUri defines model for monitor_uri.
type MonitorUri = string

// MysqlCheckParams defines model for mysql_check_params.
type MysqlCheckParams struct {
	ClientVersion *MysqlCheckParamsClientVersion `json:"client_version,omitempty"`
	Username      *string                        `json:"username,omitempty"`
}

// MysqlCheckParamsClientVersion defines model for MysqlCheckParams.ClientVersion.
type MysqlCheckParamsClientVersion string

// Nameserver Nameserver used in Runtime DNS configuration
type Nameserver struct {
	Address string `json:"address"`
	Name    string `json:"name"`
	Port    *int   `json:"port"`
}

// Nameservers Nameservers array
type Nameservers = []Nameserver

// NativeStat Current stats for one object.
type NativeStat struct {
	BackendName *string          `json:"backend_name,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Stats       *NativeStatStats `json:"stats,omitempty"`
	Type        *NativeStatType  `json:"type,omitempty"`
}

// NativeStatType defines model for NativeStat.Type.
type NativeStatType string

// NativeStatStats defines model for native_stat_stats.
type NativeStatStats struct {
	Act           *int                        `json:"act"`
	Addr          *string                     `json:"addr,omitempty"`
	AgentCode     *int                        `json:"agent_code"`
	AgentDesc     *string                     `json:"agent_desc,omitempty"`
	AgentDuration *int                        `json:"agent_duration"`
	AgentFall     *int                        `json:"agent_fall"`
	AgentHealth   *int                        `json:"agent_health"`
	AgentRise     *int                        `json:"agent_rise"`
	AgentStatus   *NativeStatStatsAgentStatus `json:"agent_status,omitempty"`
	Algo          *string                     `json:"algo,omitempty"`
	Bck           *int                        `json:"bck"`
	Bin           *int                        `json:"bin"`
	Bout          *int                        `json:"bout"`
	CheckCode     *int                        `json:"check_code"`
	CheckDesc     *string                     `json:"check_desc,omitempty"`
	CheckDuration *int                        `json:"check_duration"`
	CheckFall     *int                        `json:"check_fall"`
	CheckHealth   *int                        `json:"check_health"`
	CheckRise     *int                        `json:"check_rise"`
	CheckStatus   *NativeStatStatsCheckStatus `json:"check_status,omitempty"`
	Chkdown       *int                        `json:"chkdown"`
	Chkfail       *int                        `json:"chkfail"`
	CliAbrt       *int                        `json:"cli_abrt"`
	CompByp       *int                        `json:"comp_byp"`
	CompIn        *int                        `json:"comp_in"`
	CompOut       *int                        `json:"comp_out"`
	CompRsp       *int                        `json:"comp_rsp"`
	ConnRate      *int                        `json:"conn_rate"`
	ConnRateMax   *int                        `json:"conn_rate_max"`
	ConnTot       *int                        `json:"conn_tot"`
	Cookie        *string                     `json:"cookie,omitempty"`
	Ctime         *int                        `json:"ctime"`
	Dcon          *int                        `json:"dcon"`
	Downtime      *int                        `json:"downtime"`
	Dreq          *int                        `json:"dreq"`
	Dresp         *int                        `json:"dresp"`
	Dses          *int                        `json:"dses"`
	Econ          *int                        `json:"econ"`
	Ereq          *int                        `json:"ereq"`
	Eresp         *int                        `json:"eresp"`
	Hanafail      *string                     `json:"hanafail,omitempty"`
	Hrsp1xx       *int                        `json:"hrsp_1xx"`
	Hrsp2xx       *int                        `json:"hrsp_2xx"`
	Hrsp3xx       *int                        `json:"hrsp_3xx"`
	Hrsp4xx       *int                        `json:"hrsp_4xx"`
	Hrsp5xx       *int                        `json:"hrsp_5xx"`
	HrspOther     *int                        `json:"hrsp_other"`
	Iid           *int                        `json:"iid"`
	Intercepted   *int                        `json:"intercepted"`
	LastAgt       *string                     `json:"last_agt"`
	LastChk       *string                     `json:"last_chk"`
	Lastchg       *int                        `json:"lastchg"`
	Lastsess      *int                        `json:"lastsess"`
	Lbtot         *int                        `json:"lbtot"`
	Mode          *NativeStatStatsMode        `json:"mode,omitempty"`
	Pid           *int                        `json:"pid"`
	Qcur          *int                        `json:"qcur"`
	Qlimit        *int                        `json:"qlimit"`
	Qmax          *int                        `json:"qmax"`
	Qtime         *int                        `json:"qtime"`
	Rate          *int                        `json:"rate"`
	RateLim       *int                        `json:"rate_lim"`
	RateMax       *int                        `json:"rate_max"`
	ReqRate       *int                        `json:"req_rate"`
	ReqRateMax    *int                        `json:"req_rate_max"`
	ReqTot        *int                        `json:"req_tot"`
	Rtime         *int                        `json:"rtime"`
	Scur          *int                        `json:"scur"`
	Sid           *int                        `json:"sid"`
	Slim          *int                        `json:"slim"`
	Smax          *int                        `json:"smax"`
	SrvAbrt       *int                        `json:"srv_abrt"`
	Status        *NativeStatStatsStatus      `json:"status,omitempty"`
	Stot          *int                        `json:"stot"`
	Throttle      *int                        `json:"throttle"`
	Tracked       *string                     `json:"tracked,omitempty"`
	Ttime         *int                        `json:"ttime"`
	Weight        *int                        `json:"weight"`
	Wredis        *int                        `json:"wredis"`
	Wretr         *int                        `json:"wretr"`
}

// NativeStatStatsAgentStatus defines model for NativeStatStats.AgentStatus.
type NativeStatStatsAgentStatus string

// NativeStatStatsCheckStatus defines model for NativeStatStats.CheckStatus.
type NativeStatStatsCheckStatus string

// NativeStatStatsMode defines model for NativeStatStats.Mode.
type NativeStatStatsMode string

// NativeStatStatsStatus defines model for NativeStatStats.Status.
type NativeStatStatsStatus string

// NativeStats HAProxy stats array
type NativeStats struct {
	Error      *string       `json:"error,omitempty"`
	RuntimeAPI *string       `json:"runtimeAPI,omitempty"`
	Stats      *[]NativeStat `json:"stats,omitempty"`
}

// OcspUpdateOptions defines model for ocsp_update_options.
type OcspUpdateOptions struct {
	Disable   *bool `json:"disable"`
	Httpproxy *struct {
		Address *string `json:"address,omitempty"`
		Port    *int    `json:"port"`
	} `json:"httpproxy,omitempty"`

	// Maxdelay Sets the maximum interval between two automatic updates of the same OCSP response.This time is expressed in seconds
	Maxdelay *int `json:"maxdelay"`

	// Mindelay Sets the minimum interval between two automatic updates of the same OCSP response. This time is expressed in seconds
	Mindelay *int                   `json:"mindelay"`
	Mode     *OcspUpdateOptionsMode `json:"mode,omitempty"`
}

// OcspUpdateOptionsMode defines model for OcspUpdateOptions.Mode.
type OcspUpdateOptionsMode string

// Originalto defines model for originalto.
type Originalto struct {
	Enabled OriginaltoEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
}

// OriginaltoEnabled defines model for Originalto.Enabled.
type OriginaltoEnabled string

// PeerEntries HAProxy peer entries array
type PeerEntries = []PeerEntry

// PeerEntry Peer Entry from peers table
type PeerEntry struct {
	Address string `json:"address"`
	Name    string `json:"name"`
	Port    *int   `json:"port"`
	Shard   *int   `json:"shard,omitempty"`
}

// PeerSection defines model for peer_section.
type PeerSection struct {
	Binds *map[string]Bind `json:"binds,omitempty"`

	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind   `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer `json:"default_server,omitempty"`
	Disabled      *bool          `json:"disabled,omitempty"`
	Enabled       *bool          `json:"enabled,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets           `json:"log_target_list,omitempty"`
	Name          string                `json:"name"`
	PeerEntries   *map[string]PeerEntry `json:"peer_entries,omitempty"`
	Servers       *map[string]Server    `json:"servers,omitempty"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int              `json:"shards,omitempty"`
	Tables *map[string]Table `json:"tables,omitempty"`
}

// PeerSectionBase HAProxy peer_section configuration
type PeerSectionBase struct {
	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind   `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer `json:"default_server,omitempty"`
	Disabled      *bool          `json:"disabled,omitempty"`
	Enabled       *bool          `json:"enabled,omitempty"`
	Name          string         `json:"name"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int `json:"shards,omitempty"`
}

// PeerSections HAProxy peer_section array
type PeerSections = []PeerSection

// PerformanceOptions defines model for performance_options.
type PerformanceOptions struct {
	BusyPolling     *bool                              `json:"busy_polling,omitempty"`
	MaxSpreadChecks *int                               `json:"max_spread_checks"`
	Maxcompcpuusage *int                               `json:"maxcompcpuusage,omitempty"`
	Maxcomprate     *int                               `json:"maxcomprate,omitempty"`
	Maxconn         *int                               `json:"maxconn,omitempty"`
	Maxconnrate     *int                               `json:"maxconnrate,omitempty"`
	Maxpipes        *int                               `json:"maxpipes,omitempty"`
	Maxsessrate     *int                               `json:"maxsessrate,omitempty"`
	Maxzlibmem      *int                               `json:"maxzlibmem,omitempty"`
	Noepoll         *bool                              `json:"noepoll,omitempty"`
	Noevports       *bool                              `json:"noevports,omitempty"`
	Nogetaddrinfo   *bool                              `json:"nogetaddrinfo,omitempty"`
	Nokqueue        *bool                              `json:"nokqueue,omitempty"`
	Nopoll          *bool                              `json:"nopoll,omitempty"`
	Noreuseport     *bool                              `json:"noreuseport,omitempty"`
	Nosplice        *bool                              `json:"nosplice,omitempty"`
	ProfilingMemory *PerformanceOptionsProfilingMemory `json:"profiling_memory,omitempty"`
	ProfilingTasks  *PerformanceOptionsProfilingTasks  `json:"profiling_tasks,omitempty"`
	ServerStateBase *string                            `json:"server_state_base,omitempty"`
	ServerStateFile *string                            `json:"server_state_file,omitempty"`
	SpreadChecks    *int                               `json:"spread_checks,omitempty"`
	ThreadHardLimit *int                               `json:"thread_hard_limit"`
}

// PerformanceOptionsProfilingMemory defines model for PerformanceOptions.ProfilingMemory.
type PerformanceOptionsProfilingMemory string

// PerformanceOptionsProfilingTasks defines model for PerformanceOptions.ProfilingTasks.
type PerformanceOptionsProfilingTasks string

// PersistRule defines model for persist_rule.
type PersistRule struct {
	RdpCookieName *string         `json:"rdp_cookie_name,omitempty"`
	Type          PersistRuleType `json:"type"`
}

// PersistRuleType defines model for PersistRule.Type.
type PersistRuleType string

// PgsqlCheckParams defines model for pgsql_check_params.
type PgsqlCheckParams struct {
	Username *string `json:"username,omitempty"`
}

// ProcessInfo General HAProxy process information
type ProcessInfo struct {
	Error      *string          `json:"error,omitempty"`
	Info       *ProcessInfoItem `json:"info,omitempty"`
	RuntimeAPI *string          `json:"runtimeAPI,omitempty"`
}

// ProcessInfoItem defines model for process_info_item.
type ProcessInfoItem struct {
	ActivePeers        *int `json:"active_peers"`
	BusyPolling        *int `json:"busy_polling"`
	BytesOutRate       *int `json:"bytes_out_rate"`
	CompressBpsIn      *int `json:"compress_bps_in"`
	CompressBpsOut     *int `json:"compress_bps_out"`
	CompressBpsRateLim *int `json:"compress_bps_rate_lim"`
	ConnRate           *int `json:"conn_rate"`
	ConnRateLimit      *int `json:"conn_rate_limit"`
	ConnectedPeers     *int `json:"connected_peers"`
	CumConns           *int `json:"cum_conns"`
	CumReq             *int `json:"cum_req"`
	CumSslConns        *int `json:"cum_ssl_conns"`
	CurrConns          *int `json:"curr_conns"`
	CurrSslConns       *int `json:"curr_ssl_conns"`
	DroppedLogs        *int `json:"dropped_logs"`
	FailedResolutions  *int `json:"failed_resolutions"`
	HardMaxConn        *int `json:"hard_max_conn"`
	IdlePct            *int `json:"idle_pct"`
	Jobs               *int `json:"jobs"`
	Listeners          *int `json:"listeners"`
	MaxConn            *int `json:"max_conn"`
	MaxConnRate        *int `json:"max_conn_rate"`
	MaxPipes           *int `json:"max_pipes"`
	MaxSessRate        *int `json:"max_sess_rate"`
	MaxSock            *int `json:"max_sock"`
	MaxSslConns        *int `json:"max_ssl_conns"`
	MaxSslRate         *int `json:"max_ssl_rate"`
	MaxZlibMemUsage    *int `json:"max_zlib_mem_usage"`
	MemMaxMb           *int `json:"mem_max_mb"`

	// Nbthread Number of threads
	Nbthread *int    `json:"nbthread"`
	Node     *string `json:"node,omitempty"`

	// Pid Process id of the replying worker process
	Pid         *int `json:"pid"`
	PipesFree   *int `json:"pipes_free"`
	PipesUsed   *int `json:"pipes_used"`
	PoolAllocMb *int `json:"pool_alloc_mb"`
	PoolFailed  *int `json:"pool_failed"`
	PoolUsedMb  *int `json:"pool_used_mb"`

	// ProcessNum Process number
	ProcessNum *int `json:"process_num"`

	// Processes Number of spawned processes
	Processes *int `json:"processes"`

	// ReleaseDate HAProxy version release date
	ReleaseDate             *openapi_types.Date `json:"release_date,omitempty"`
	RunQueue                *int                `json:"run_queue"`
	SessRate                *int                `json:"sess_rate"`
	SessRateLimit           *int                `json:"sess_rate_limit"`
	SslBackendKeyRate       *int                `json:"ssl_backend_key_rate"`
	SslBackendMaxKeyRate    *int                `json:"ssl_backend_max_key_rate"`
	SslCacheLookups         *int                `json:"ssl_cache_lookups"`
	SslCacheMisses          *int                `json:"ssl_cache_misses"`
	SslFrontendKeyRate      *int                `json:"ssl_frontend_key_rate"`
	SslFrontendMaxKeyRate   *int                `json:"ssl_frontend_max_key_rate"`
	SslFrontendSessionReuse *int                `json:"ssl_frontend_session_reuse"`
	SslRate                 *int                `json:"ssl_rate"`
	SslRateLimit            *int                `json:"ssl_rate_limit"`
	Stopping                *int                `json:"stopping"`
	Tasks                   *int                `json:"tasks"`
	TotalBytesOut           *int                `json:"total_bytes_out"`
	UlimitN                 *int                `json:"ulimit_n"`
	Unstoppable             *int                `json:"unstoppable"`

	// Uptime HAProxy uptime in s
	Uptime *int `json:"uptime"`

	// Version HAProxy version string
	Version      *string `json:"version,omitempty"`
	ZlibMemUsage *int    `json:"zlib_mem_usage"`
}

// Program HAProxy program configuration
type Program struct {
	// Command The command to be run, with flags and options.
	Command string `json:"command"`

	// Group The group to run the command as, if different than the HAProxy group.
	Group *string `json:"group,omitempty"`
	Name  string  `json:"name"`

	// StartOnReload HAProxy stops and recreates child programs at reload.
	StartOnReload *ProgramStartOnReload `json:"start-on-reload,omitempty"`

	// User The user to run the command as, if different than the HAProxy user.
	User *string `json:"user,omitempty"`
}

// ProgramStartOnReload HAProxy stops and recreates child programs at reload.
type ProgramStartOnReload string

// Programs defines model for programs.
type Programs = []Program

// QUICInitialRule QUIC Initial configuration
type QUICInitialRule struct {
	Cond     *QuicInitialRuleCond `json:"cond,omitempty"`
	CondTest *string              `json:"cond_test,omitempty"`
	Type     QuicInitialRuleType  `json:"type"`
}

// QuicInitialRuleCond defines model for QuicInitialRule.Cond.
type QuicInitialRuleCond string

// QuicInitialRuleType defines model for QuicInitialRule.Type.
type QuicInitialRuleType string

// QUICInitialRules defines model for quic_initial_rules.
type QUICInitialRules = []QUICInitialRule

// Redispatch defines model for redispatch.
type Redispatch struct {
	Enabled  RedispatchEnabled `json:"enabled"`
	Interval *int              `json:"interval"`
}

// RedispatchEnabled defines model for Redispatch.Enabled.
type RedispatchEnabled string

// Reload HAProxy reload
type Reload struct {
	Id              *string       `json:"id,omitempty"`
	ReloadTimestamp *int          `json:"reload_timestamp,omitempty"`
	Response        *string       `json:"response,omitempty"`
	Status          *ReloadStatus `json:"status,omitempty"`
}

// ReloadStatus defines model for Reload.Status.
type ReloadStatus string

// Reloads HAProxy reloads array
type Reloads = []Reload

// Resolver defines model for resolver.
type Resolver struct {
	AcceptedPayloadSize *int                   `json:"accepted_payload_size,omitempty"`
	HoldNx              *int                   `json:"hold_nx"`
	HoldObsolete        *int                   `json:"hold_obsolete"`
	HoldOther           *int                   `json:"hold_other"`
	HoldRefused         *int                   `json:"hold_refused"`
	HoldTimeout         *int                   `json:"hold_timeout"`
	HoldValid           *int                   `json:"hold_valid"`
	Name                string                 `json:"name"`
	Nameservers         *map[string]Nameserver `json:"nameservers,omitempty"`
	ParseResolvConf     *bool                  `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int                   `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int                   `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int                   `json:"timeout_retry,omitempty"`
}

// ResolverBase Runtime DNS configuration
type ResolverBase struct {
	AcceptedPayloadSize *int   `json:"accepted_payload_size,omitempty"`
	HoldNx              *int   `json:"hold_nx"`
	HoldObsolete        *int   `json:"hold_obsolete"`
	HoldOther           *int   `json:"hold_other"`
	HoldRefused         *int   `json:"hold_refused"`
	HoldTimeout         *int   `json:"hold_timeout"`
	HoldValid           *int   `json:"hold_valid"`
	Name                string `json:"name"`
	ParseResolvConf     *bool  `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int   `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int   `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int   `json:"timeout_retry,omitempty"`
}

// Resolvers HAProxy resolvers array
type Resolvers = []Resolver

// ReturnHeader defines model for return_header.
type ReturnHeader struct {
	Fmt  string `json:"fmt"`
	Name string `json:"name"`
}

// Ring defines model for ring.
type Ring struct {
	Description    *string            `json:"description,omitempty"`
	Format         *RingFormat        `json:"format,omitempty"`
	Maxlen         *int               `json:"maxlen"`
	Name           string             `json:"name"`
	Servers        *map[string]Server `json:"servers,omitempty"`
	Size           *int               `json:"size"`
	TimeoutConnect *int               `json:"timeout_connect"`
	TimeoutServer  *int               `json:"timeout_server"`
}

// RingFormat defines model for Ring.Format.
type RingFormat string

// RingBase HAProxy ring configuration
type RingBase struct {
	Description    *string         `json:"description,omitempty"`
	Format         *RingBaseFormat `json:"format,omitempty"`
	Maxlen         *int            `json:"maxlen"`
	Name           string          `json:"name"`
	Size           *int            `json:"size"`
	TimeoutConnect *int            `json:"timeout_connect"`
	TimeoutServer  *int            `json:"timeout_server"`
}

// RingBaseFormat defines model for RingBase.Format.
type RingBaseFormat string

// Rings HAProxy rings array
type Rings = []Ring

// RuntimeAddServer Settable properties when adding a new server using HAProxy's runtime.
type RuntimeAddServer struct {
	Address            *string                           `json:"address,omitempty"`
	AgentAddr          *string                           `json:"agent-addr,omitempty"`
	AgentCheck         *RuntimeAddServerAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                              `json:"agent-inter"`
	AgentPort          *int                              `json:"agent-port"`
	AgentSend          *string                           `json:"agent-send,omitempty"`
	Allow0rtt          *bool                             `json:"allow_0rtt,omitempty"`
	Alpn               *string                           `json:"alpn,omitempty"`
	Backup             *RuntimeAddServerBackup           `json:"backup,omitempty"`
	Check              *RuntimeAddServerCheck            `json:"check,omitempty"`
	CheckSendProxy     *RuntimeAddServerCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                           `json:"check-sni,omitempty"`
	CheckSsl           *RuntimeAddServerCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                           `json:"check_alpn,omitempty"`
	CheckProto         *string                           `json:"check_proto,omitempty"`
	CheckViaSocks4     *RuntimeAddServerCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                           `json:"ciphers,omitempty"`
	Ciphersuites       *string                           `json:"ciphersuites,omitempty"`
	CrlFile            *string                           `json:"crl_file,omitempty"`
	Downinter          *int                              `json:"downinter"`
	ErrorLimit         *int                              `json:"error_limit"`
	Fall               *int                              `json:"fall"`
	Fastinter          *int                              `json:"fastinter"`
	ForceSslv3         *RuntimeAddServerForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *RuntimeAddServerForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *RuntimeAddServerForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *RuntimeAddServerForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *RuntimeAddServerForceTlsv13      `json:"force_tlsv13,omitempty"`
	HealthCheckAddress *string                           `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                              `json:"health_check_port"`
	Id                 *string                           `json:"id,omitempty"`
	Inter              *int                              `json:"inter"`
	Maintenance        *RuntimeAddServerMaintenance      `json:"maintenance,omitempty"`
	Maxconn            *int                              `json:"maxconn"`
	Maxqueue           *int                              `json:"maxqueue"`
	Minconn            *int                              `json:"minconn"`
	Name               *string                           `json:"name,omitempty"`
	NoSslv3            *RuntimeAddServerNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *RuntimeAddServerNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *RuntimeAddServerNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *RuntimeAddServerNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *RuntimeAddServerNoTlsv13         `json:"no_tlsv13,omitempty"`
	Npn                *string                           `json:"npn,omitempty"`
	Observe            *RuntimeAddServerObserve          `json:"observe,omitempty"`
	OnError            *RuntimeAddServerOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *RuntimeAddServerOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *RuntimeAddServerOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolLowConn        *int                              `json:"pool_low_conn"`
	PoolMaxConn        *int                              `json:"pool_max_conn"`
	PoolPurgeDelay     *int                              `json:"pool_purge_delay"`
	Port               *int                              `json:"port"`
	Proto              *string                           `json:"proto,omitempty"`
	ProxyV2Options     *[]RuntimeAddServerProxyV2Options `json:"proxy-v2-options,omitempty"`
	Rise               *int                              `json:"rise"`
	SendProxy          *RuntimeAddServerSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *RuntimeAddServerSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *RuntimeAddServerSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *RuntimeAddServerSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	Slowstart          *int                              `json:"slowstart"`
	Sni                *string                           `json:"sni,omitempty"`
	Source             *string                           `json:"source,omitempty"`
	Ssl                *RuntimeAddServerSsl              `json:"ssl,omitempty"`
	SslCafile          *string                           `json:"ssl_cafile,omitempty"`
	SslCertificate     *string                           `json:"ssl_certificate,omitempty"`
	SslMaxVer          *RuntimeAddServerSslMaxVer        `json:"ssl_max_ver,omitempty"`
	SslMinVer          *RuntimeAddServerSslMinVer        `json:"ssl_min_ver,omitempty"`
	SslReuse           *RuntimeAddServerSslReuse         `json:"ssl_reuse,omitempty"`
	Tfo                *RuntimeAddServerTfo              `json:"tfo,omitempty"`
	TlsTickets         *RuntimeAddServerTlsTickets       `json:"tls_tickets,omitempty"`
	Track              *string                           `json:"track,omitempty"`
	Verify             *RuntimeAddServerVerify           `json:"verify,omitempty"`
	Verifyhost         *string                           `json:"verifyhost,omitempty"`
	Weight             *int                              `json:"weight"`
	Ws                 *RuntimeAddServerWs               `json:"ws,omitempty"`
}

// RuntimeAddServerAgentCheck defines model for RuntimeAddServer.AgentCheck.
type RuntimeAddServerAgentCheck string

// RuntimeAddServerBackup defines model for RuntimeAddServer.Backup.
type RuntimeAddServerBackup string

// RuntimeAddServerCheck defines model for RuntimeAddServer.Check.
type RuntimeAddServerCheck string

// RuntimeAddServerCheckSendProxy defines model for RuntimeAddServer.CheckSendProxy.
type RuntimeAddServerCheckSendProxy string

// RuntimeAddServerCheckSsl defines model for RuntimeAddServer.CheckSsl.
type RuntimeAddServerCheckSsl string

// RuntimeAddServerCheckViaSocks4 defines model for RuntimeAddServer.CheckViaSocks4.
type RuntimeAddServerCheckViaSocks4 string

// RuntimeAddServerForceSslv3 defines model for RuntimeAddServer.ForceSslv3.
type RuntimeAddServerForceSslv3 string

// RuntimeAddServerForceTlsv10 defines model for RuntimeAddServer.ForceTlsv10.
type RuntimeAddServerForceTlsv10 string

// RuntimeAddServerForceTlsv11 defines model for RuntimeAddServer.ForceTlsv11.
type RuntimeAddServerForceTlsv11 string

// RuntimeAddServerForceTlsv12 defines model for RuntimeAddServer.ForceTlsv12.
type RuntimeAddServerForceTlsv12 string

// RuntimeAddServerForceTlsv13 defines model for RuntimeAddServer.ForceTlsv13.
type RuntimeAddServerForceTlsv13 string

// RuntimeAddServerMaintenance defines model for RuntimeAddServer.Maintenance.
type RuntimeAddServerMaintenance string

// RuntimeAddServerNoSslv3 defines model for RuntimeAddServer.NoSslv3.
type RuntimeAddServerNoSslv3 string

// RuntimeAddServerNoTlsv10 defines model for RuntimeAddServer.NoTlsv10.
type RuntimeAddServerNoTlsv10 string

// RuntimeAddServerNoTlsv11 defines model for RuntimeAddServer.NoTlsv11.
type RuntimeAddServerNoTlsv11 string

// RuntimeAddServerNoTlsv12 defines model for RuntimeAddServer.NoTlsv12.
type RuntimeAddServerNoTlsv12 string

// RuntimeAddServerNoTlsv13 defines model for RuntimeAddServer.NoTlsv13.
type RuntimeAddServerNoTlsv13 string

// RuntimeAddServerObserve defines model for RuntimeAddServer.Observe.
type RuntimeAddServerObserve string

// RuntimeAddServerOnError defines model for RuntimeAddServer.OnError.
type RuntimeAddServerOnError string

// RuntimeAddServerOnMarkedDown defines model for RuntimeAddServer.OnMarkedDown.
type RuntimeAddServerOnMarkedDown string

// RuntimeAddServerOnMarkedUp defines model for RuntimeAddServer.OnMarkedUp.
type RuntimeAddServerOnMarkedUp string

// RuntimeAddServerProxyV2Options defines model for RuntimeAddServer.ProxyV2Options.
type RuntimeAddServerProxyV2Options string

// RuntimeAddServerSendProxy defines model for RuntimeAddServer.SendProxy.
type RuntimeAddServerSendProxy string

// RuntimeAddServerSendProxyV2 defines model for RuntimeAddServer.SendProxyV2.
type RuntimeAddServerSendProxyV2 string

// RuntimeAddServerSendProxyV2Ssl defines model for RuntimeAddServer.SendProxyV2Ssl.
type RuntimeAddServerSendProxyV2Ssl string

// RuntimeAddServerSendProxyV2SslCn defines model for RuntimeAddServer.SendProxyV2SslCn.
type RuntimeAddServerSendProxyV2SslCn string

// RuntimeAddServerSsl defines model for RuntimeAddServer.Ssl.
type RuntimeAddServerSsl string

// RuntimeAddServerSslMaxVer defines model for RuntimeAddServer.SslMaxVer.
type RuntimeAddServerSslMaxVer string

// RuntimeAddServerSslMinVer defines model for RuntimeAddServer.SslMinVer.
type RuntimeAddServerSslMinVer string

// RuntimeAddServerSslReuse defines model for RuntimeAddServer.SslReuse.
type RuntimeAddServerSslReuse string

// RuntimeAddServerTfo defines model for RuntimeAddServer.Tfo.
type RuntimeAddServerTfo string

// RuntimeAddServerTlsTickets defines model for RuntimeAddServer.TlsTickets.
type RuntimeAddServerTlsTickets string

// RuntimeAddServerVerify defines model for RuntimeAddServer.Verify.
type RuntimeAddServerVerify string

// RuntimeAddServerWs defines model for RuntimeAddServer.Ws.
type RuntimeAddServerWs string

// RuntimeServer Runtime transient server properties
type RuntimeServer struct {
	Address          *string                        `json:"address,omitempty"`
	AdminState       *RuntimeServerAdminState       `json:"admin_state,omitempty"`
	Id               *string                        `json:"id,omitempty"`
	Name             *string                        `json:"name,omitempty"`
	OperationalState *RuntimeServerOperationalState `json:"operational_state,omitempty"`
	Port             *int                           `json:"port"`
}

// RuntimeServerAdminState defines model for RuntimeServer.AdminState.
type RuntimeServerAdminState string

// RuntimeServerOperationalState defines model for RuntimeServer.OperationalState.
type RuntimeServerOperationalState string

// RuntimeServers HAProxy runtime servers array
type RuntimeServers = []RuntimeServer

// Server defines model for server.
type Server struct {
	Address        string                `json:"address"`
	AgentAddr      *string               `json:"agent-addr,omitempty"`
	AgentCheck     *ServerAgentCheck     `json:"agent-check,omitempty"`
	AgentInter     *int                  `json:"agent-inter"`
	AgentPort      *int                  `json:"agent-port"`
	AgentSend      *string               `json:"agent-send,omitempty"`
	Allow0rtt      *bool                 `json:"allow_0rtt,omitempty"`
	Alpn           *string               `json:"alpn,omitempty"`
	Backup         *ServerBackup         `json:"backup,omitempty"`
	Check          *ServerCheck          `json:"check,omitempty"`
	CheckSendProxy *ServerCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni       *string               `json:"check-sni,omitempty"`
	CheckSsl       *ServerCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn      *string               `json:"check_alpn,omitempty"`
	CheckProto     *string               `json:"check_proto,omitempty"`
	CheckViaSocks4 *ServerCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers        *string               `json:"ciphers,omitempty"`
	Ciphersuites   *string               `json:"ciphersuites,omitempty"`
	ClientSigalgs  *string               `json:"client_sigalgs,omitempty"`
	Cookie         *string               `json:"cookie,omitempty"`
	CrlFile        *string               `json:"crl_file,omitempty"`
	Curves         *string               `json:"curves,omitempty"`
	Downinter      *int                  `json:"downinter"`
	ErrorLimit     *int                  `json:"error_limit,omitempty"`
	Fall           *int                  `json:"fall"`
	Fastinter      *int                  `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerForceTlsv13                 `json:"force_tlsv13,omitempty"`
	Guid               *string                            `json:"guid,omitempty"`
	HashKey            *string                            `json:"hash_key,omitempty"`
	HealthCheckAddress *string                            `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                               `json:"health_check_port"`
	Id                 *int                               `json:"id"`
	InitAddr           *string                            `json:"init-addr"`
	InitState          *ServerInitState                   `json:"init-state,omitempty"`
	Inter              *int                               `json:"inter"`
	LogBufsize         *int                               `json:"log-bufsize"`
	LogProto           *ServerLogProto                    `json:"log_proto,omitempty"`
	Maintenance        *ServerMaintenance                 `json:"maintenance,omitempty"`
	MaxReuse           *int                               `json:"max_reuse"`
	Maxconn            *int                               `json:"maxconn"`
	Maxqueue           *int                               `json:"maxqueue"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Minconn            *int                               `json:"minconn"`
	Name               string                             `json:"name"`
	Namespace          *string                            `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                 `json:"npn,omitempty"`
	Observe          *ServerObserve          `json:"observe,omitempty"`
	OnError          *ServerOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                 `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                    `json:"pool_low_conn"`
	PoolMaxConn      *int                    `json:"pool_max_conn"`
	PoolPurgeDelay   *int                    `json:"pool_purge_delay"`
	Port             *int                    `json:"port"`
	Proto            *string                 `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                 `json:"redir,omitempty"`
	ResolveNet       *string                 `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                 `json:"resolve_opts,omitempty"`
	Resolvers        *string                 `json:"resolvers,omitempty"`
	Rise             *int                    `json:"rise"`
	SendProxy        *ServerSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int              `json:"shard,omitempty"`
	Sigalgs        *string           `json:"sigalgs,omitempty"`
	Slowstart      *int              `json:"slowstart"`
	Sni            *string           `json:"sni,omitempty"`
	Socks4         *string           `json:"socks4,omitempty"`
	Source         *string           `json:"source,omitempty"`
	Ssl            *ServerSsl        `json:"ssl,omitempty"`
	SslCafile      *string           `json:"ssl_cafile,omitempty"`
	SslCertificate *string           `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerStick      `json:"stick,omitempty"`
	TcpUt          *int              `json:"tcp_ut"`
	Tfo            *ServerTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerTlsv13     `json:"tlsv13,omitempty"`
	Track          *string           `json:"track,omitempty"`
	Verify         *ServerVerify     `json:"verify,omitempty"`
	Verifyhost     *string           `json:"verifyhost,omitempty"`
	Weight         *int              `json:"weight"`
	Ws             *ServerWs         `json:"ws,omitempty"`
}

// ServerAgentCheck defines model for Server.AgentCheck.
type ServerAgentCheck string

// ServerBackup defines model for Server.Backup.
type ServerBackup string

// ServerCheck defines model for Server.Check.
type ServerCheck string

// ServerCheckSendProxy defines model for Server.CheckSendProxy.
type ServerCheckSendProxy string

// ServerCheckSsl defines model for Server.CheckSsl.
type ServerCheckSsl string

// ServerCheckViaSocks4 defines model for Server.CheckViaSocks4.
type ServerCheckViaSocks4 string

// ServerForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerForceSslv3 string

// ServerForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerForceTlsv10 string

// ServerForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerForceTlsv11 string

// ServerForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerForceTlsv12 string

// ServerForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerForceTlsv13 string

// ServerInitState defines model for Server.InitState.
type ServerInitState string

// ServerLogProto defines model for Server.LogProto.
type ServerLogProto string

// ServerMaintenance defines model for Server.Maintenance.
type ServerMaintenance string

// ServerNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerNoSslv3 string

// ServerNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerNoTlsv10 string

// ServerNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerNoTlsv11 string

// ServerNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerNoTlsv12 string

// ServerNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerNoTlsv13 string

// ServerNoVerifyhost defines model for Server.NoVerifyhost.
type ServerNoVerifyhost string

// ServerObserve defines model for Server.Observe.
type ServerObserve string

// ServerOnError defines model for Server.OnError.
type ServerOnError string

// ServerOnMarkedDown defines model for Server.OnMarkedDown.
type ServerOnMarkedDown string

// ServerOnMarkedUp defines model for Server.OnMarkedUp.
type ServerOnMarkedUp string

// ServerProxyV2Options defines model for Server.ProxyV2Options.
type ServerProxyV2Options string

// ServerResolvePrefer defines model for Server.ResolvePrefer.
type ServerResolvePrefer string

// ServerSendProxy defines model for Server.SendProxy.
type ServerSendProxy string

// ServerSendProxyV2 defines model for Server.SendProxyV2.
type ServerSendProxyV2 string

// ServerSendProxyV2Ssl defines model for Server.SendProxyV2Ssl.
type ServerSendProxyV2Ssl string

// ServerSendProxyV2SslCn defines model for Server.SendProxyV2SslCn.
type ServerSendProxyV2SslCn string

// ServerSsl defines model for Server.Ssl.
type ServerSsl string

// ServerSslMaxVer defines model for Server.SslMaxVer.
type ServerSslMaxVer string

// ServerSslMinVer defines model for Server.SslMinVer.
type ServerSslMinVer string

// ServerSslReuse defines model for Server.SslReuse.
type ServerSslReuse string

// ServerSslv3 defines model for Server.Sslv3.
type ServerSslv3 string

// ServerStick defines model for Server.Stick.
type ServerStick string

// ServerTfo defines model for Server.Tfo.
type ServerTfo string

// ServerTlsTickets defines model for Server.TlsTickets.
type ServerTlsTickets string

// ServerTlsv10 defines model for Server.Tlsv10.
type ServerTlsv10 string

// ServerTlsv11 defines model for Server.Tlsv11.
type ServerTlsv11 string

// ServerTlsv12 defines model for Server.Tlsv12.
type ServerTlsv12 string

// ServerTlsv13 defines model for Server.Tlsv13.
type ServerTlsv13 string

// ServerVerify defines model for Server.Verify.
type ServerVerify string

// ServerWs defines model for Server.Ws.
type ServerWs string

// ServerParams defines model for server_params.
type ServerParams struct {
	AgentAddr      *string                     `json:"agent-addr,omitempty"`
	AgentCheck     *ServerParamsAgentCheck     `json:"agent-check,omitempty"`
	AgentInter     *int                        `json:"agent-inter"`
	AgentPort      *int                        `json:"agent-port"`
	AgentSend      *string                     `json:"agent-send,omitempty"`
	Allow0rtt      *bool                       `json:"allow_0rtt,omitempty"`
	Alpn           *string                     `json:"alpn,omitempty"`
	Backup         *ServerParamsBackup         `json:"backup,omitempty"`
	Check          *ServerParamsCheck          `json:"check,omitempty"`
	CheckSendProxy *ServerParamsCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni       *string                     `json:"check-sni,omitempty"`
	CheckSsl       *ServerParamsCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn      *string                     `json:"check_alpn,omitempty"`
	CheckProto     *string                     `json:"check_proto,omitempty"`
	CheckViaSocks4 *ServerParamsCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers        *string                     `json:"ciphers,omitempty"`
	Ciphersuites   *string                     `json:"ciphersuites,omitempty"`
	ClientSigalgs  *string                     `json:"client_sigalgs,omitempty"`
	Cookie         *string                     `json:"cookie,omitempty"`
	CrlFile        *string                     `json:"crl_file,omitempty"`
	Curves         *string                     `json:"curves,omitempty"`
	Downinter      *int                        `json:"downinter"`
	ErrorLimit     *int                        `json:"error_limit,omitempty"`
	Fall           *int                        `json:"fall"`
	Fastinter      *int                        `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerParamsForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerParamsForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerParamsForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerParamsForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerParamsForceTlsv13 `json:"force_tlsv13,omitempty"`
	Guid               *string                  `json:"guid,omitempty"`
	HashKey            *string                  `json:"hash_key,omitempty"`
	HealthCheckAddress *string                  `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                     `json:"health_check_port"`
	InitAddr           *string                  `json:"init-addr"`
	InitState          *ServerParamsInitState   `json:"init-state,omitempty"`
	Inter              *int                     `json:"inter"`
	LogBufsize         *int                     `json:"log-bufsize"`
	LogProto           *ServerParamsLogProto    `json:"log_proto,omitempty"`
	Maintenance        *ServerParamsMaintenance `json:"maintenance,omitempty"`
	MaxReuse           *int                     `json:"max_reuse"`
	Maxconn            *int                     `json:"maxconn"`
	Maxqueue           *int                     `json:"maxqueue"`
	Minconn            *int                     `json:"minconn"`
	Namespace          *string                  `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerParamsNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerParamsNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerParamsNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerParamsNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerParamsNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerParamsNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                       `json:"npn,omitempty"`
	Observe          *ServerParamsObserve          `json:"observe,omitempty"`
	OnError          *ServerParamsOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerParamsOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerParamsOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                       `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                          `json:"pool_low_conn"`
	PoolMaxConn      *int                          `json:"pool_max_conn"`
	PoolPurgeDelay   *int                          `json:"pool_purge_delay"`
	Proto            *string                       `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerParamsProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                       `json:"redir,omitempty"`
	ResolveNet       *string                       `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerParamsResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                       `json:"resolve_opts,omitempty"`
	Resolvers        *string                       `json:"resolvers,omitempty"`
	Rise             *int                          `json:"rise"`
	SendProxy        *ServerParamsSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerParamsSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerParamsSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerParamsSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                    `json:"shard,omitempty"`
	Sigalgs        *string                 `json:"sigalgs,omitempty"`
	Slowstart      *int                    `json:"slowstart"`
	Sni            *string                 `json:"sni,omitempty"`
	Socks4         *string                 `json:"socks4,omitempty"`
	Source         *string                 `json:"source,omitempty"`
	Ssl            *ServerParamsSsl        `json:"ssl,omitempty"`
	SslCafile      *string                 `json:"ssl_cafile,omitempty"`
	SslCertificate *string                 `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerParamsSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerParamsSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerParamsSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerParamsSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerParamsStick      `json:"stick,omitempty"`
	TcpUt          *int                    `json:"tcp_ut"`
	Tfo            *ServerParamsTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerParamsTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerParamsTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerParamsTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerParamsTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerParamsTlsv13     `json:"tlsv13,omitempty"`
	Track          *string                 `json:"track,omitempty"`
	Verify         *ServerParamsVerify     `json:"verify,omitempty"`
	Verifyhost     *string                 `json:"verifyhost,omitempty"`
	Weight         *int                    `json:"weight"`
	Ws             *ServerParamsWs         `json:"ws,omitempty"`
}

// ServerParamsAgentCheck defines model for ServerParams.AgentCheck.
type ServerParamsAgentCheck string

// ServerParamsBackup defines model for ServerParams.Backup.
type ServerParamsBackup string

// ServerParamsCheck defines model for ServerParams.Check.
type ServerParamsCheck string

// ServerParamsCheckSendProxy defines model for ServerParams.CheckSendProxy.
type ServerParamsCheckSendProxy string

// ServerParamsCheckSsl defines model for ServerParams.CheckSsl.
type ServerParamsCheckSsl string

// ServerParamsCheckViaSocks4 defines model for ServerParams.CheckViaSocks4.
type ServerParamsCheckViaSocks4 string

// ServerParamsForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerParamsForceSslv3 string

// ServerParamsForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerParamsForceTlsv10 string

// ServerParamsForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerParamsForceTlsv11 string

// ServerParamsForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerParamsForceTlsv12 string

// ServerParamsForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerParamsForceTlsv13 string

// ServerParamsInitState defines model for ServerParams.InitState.
type ServerParamsInitState string

// ServerParamsLogProto defines model for ServerParams.LogProto.
type ServerParamsLogProto string

// ServerParamsMaintenance defines model for ServerParams.Maintenance.
type ServerParamsMaintenance string

// ServerParamsNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerParamsNoSslv3 string

// ServerParamsNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerParamsNoTlsv10 string

// ServerParamsNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerParamsNoTlsv11 string

// ServerParamsNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerParamsNoTlsv12 string

// ServerParamsNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerParamsNoTlsv13 string

// ServerParamsNoVerifyhost defines model for ServerParams.NoVerifyhost.
type ServerParamsNoVerifyhost string

// ServerParamsObserve defines model for ServerParams.Observe.
type ServerParamsObserve string

// ServerParamsOnError defines model for ServerParams.OnError.
type ServerParamsOnError string

// ServerParamsOnMarkedDown defines model for ServerParams.OnMarkedDown.
type ServerParamsOnMarkedDown string

// ServerParamsOnMarkedUp defines model for ServerParams.OnMarkedUp.
type ServerParamsOnMarkedUp string

// ServerParamsProxyV2Options defines model for ServerParams.ProxyV2Options.
type ServerParamsProxyV2Options string

// ServerParamsResolvePrefer defines model for ServerParams.ResolvePrefer.
type ServerParamsResolvePrefer string

// ServerParamsSendProxy defines model for ServerParams.SendProxy.
type ServerParamsSendProxy string

// ServerParamsSendProxyV2 defines model for ServerParams.SendProxyV2.
type ServerParamsSendProxyV2 string

// ServerParamsSendProxyV2Ssl defines model for ServerParams.SendProxyV2Ssl.
type ServerParamsSendProxyV2Ssl string

// ServerParamsSendProxyV2SslCn defines model for ServerParams.SendProxyV2SslCn.
type ServerParamsSendProxyV2SslCn string

// ServerParamsSsl defines model for ServerParams.Ssl.
type ServerParamsSsl string

// ServerParamsSslMaxVer defines model for ServerParams.SslMaxVer.
type ServerParamsSslMaxVer string

// ServerParamsSslMinVer defines model for ServerParams.SslMinVer.
type ServerParamsSslMinVer string

// ServerParamsSslReuse defines model for ServerParams.SslReuse.
type ServerParamsSslReuse string

// ServerParamsSslv3 defines model for ServerParams.Sslv3.
type ServerParamsSslv3 string

// ServerParamsStick defines model for ServerParams.Stick.
type ServerParamsStick string

// ServerParamsTfo defines model for ServerParams.Tfo.
type ServerParamsTfo string

// ServerParamsTlsTickets defines model for ServerParams.TlsTickets.
type ServerParamsTlsTickets string

// ServerParamsTlsv10 defines model for ServerParams.Tlsv10.
type ServerParamsTlsv10 string

// ServerParamsTlsv11 defines model for ServerParams.Tlsv11.
type ServerParamsTlsv11 string

// ServerParamsTlsv12 defines model for ServerParams.Tlsv12.
type ServerParamsTlsv12 string

// ServerParamsTlsv13 defines model for ServerParams.Tlsv13.
type ServerParamsTlsv13 string

// ServerParamsVerify defines model for ServerParams.Verify.
type ServerParamsVerify string

// ServerParamsWs defines model for ServerParams.Ws.
type ServerParamsWs string

// ServerSwitchingRule HAProxy server switching rule configuration (corresponds to use-server directive)
type ServerSwitchingRule struct {
	Cond         *ServerSwitchingRuleCond `json:"cond,omitempty"`
	CondTest     *string                  `json:"cond_test,omitempty"`
	TargetServer string                   `json:"target_server"`
}

// ServerSwitchingRuleCond defines model for ServerSwitchingRule.Cond.
type ServerSwitchingRuleCond string

// ServerSwitchingRules HAProxy backend server switching rules array (corresponds to use-server directives)
type ServerSwitchingRules = []ServerSwitchingRule

// ServerTemplate defines model for server_template.
type ServerTemplate struct {
	AgentAddr      *string                       `json:"agent-addr,omitempty"`
	AgentCheck     *ServerTemplateAgentCheck     `json:"agent-check,omitempty"`
	AgentInter     *int                          `json:"agent-inter"`
	AgentPort      *int                          `json:"agent-port"`
	AgentSend      *string                       `json:"agent-send,omitempty"`
	Allow0rtt      *bool                         `json:"allow_0rtt,omitempty"`
	Alpn           *string                       `json:"alpn,omitempty"`
	Backup         *ServerTemplateBackup         `json:"backup,omitempty"`
	Check          *ServerTemplateCheck          `json:"check,omitempty"`
	CheckSendProxy *ServerTemplateCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni       *string                       `json:"check-sni,omitempty"`
	CheckSsl       *ServerTemplateCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn      *string                       `json:"check_alpn,omitempty"`
	CheckProto     *string                       `json:"check_proto,omitempty"`
	CheckViaSocks4 *ServerTemplateCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers        *string                       `json:"ciphers,omitempty"`
	Ciphersuites   *string                       `json:"ciphersuites,omitempty"`
	ClientSigalgs  *string                       `json:"client_sigalgs,omitempty"`
	Cookie         *string                       `json:"cookie,omitempty"`
	CrlFile        *string                       `json:"crl_file,omitempty"`
	Curves         *string                       `json:"curves,omitempty"`
	Downinter      *int                          `json:"downinter"`
	ErrorLimit     *int                          `json:"error_limit,omitempty"`
	Fall           *int                          `json:"fall"`
	Fastinter      *int                          `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerTemplateForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerTemplateForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerTemplateForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerTemplateForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerTemplateForceTlsv13 `json:"force_tlsv13,omitempty"`
	Fqdn               string                     `json:"fqdn"`
	Guid               *string                    `json:"guid,omitempty"`
	HashKey            *string                    `json:"hash_key,omitempty"`
	HealthCheckAddress *string                    `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                       `json:"health_check_port"`
	Id                 *int                       `json:"id"`
	InitAddr           *string                    `json:"init-addr"`
	InitState          *ServerTemplateInitState   `json:"init-state,omitempty"`
	Inter              *int                       `json:"inter"`
	LogBufsize         *int                       `json:"log-bufsize"`
	LogProto           *ServerTemplateLogProto    `json:"log_proto,omitempty"`
	Maintenance        *ServerTemplateMaintenance `json:"maintenance,omitempty"`
	MaxReuse           *int                       `json:"max_reuse"`
	Maxconn            *int                       `json:"maxconn"`
	Maxqueue           *int                       `json:"maxqueue"`
	Minconn            *int                       `json:"minconn"`
	Namespace          *string                    `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerTemplateNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerTemplateNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerTemplateNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerTemplateNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerTemplateNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerTemplateNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                         `json:"npn,omitempty"`
	NumOrRange       string                          `json:"num_or_range"`
	Observe          *ServerTemplateObserve          `json:"observe,omitempty"`
	OnError          *ServerTemplateOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerTemplateOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerTemplateOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                         `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                            `json:"pool_low_conn"`
	PoolMaxConn      *int                            `json:"pool_max_conn"`
	PoolPurgeDelay   *int                            `json:"pool_purge_delay"`
	Port             *int                            `json:"port"`
	Prefix           string                          `json:"prefix"`
	Proto            *string                         `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerTemplateProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                         `json:"redir,omitempty"`
	ResolveNet       *string                         `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerTemplateResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                         `json:"resolve_opts,omitempty"`
	Resolvers        *string                         `json:"resolvers,omitempty"`
	Rise             *int                            `json:"rise"`
	SendProxy        *ServerTemplateSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerTemplateSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerTemplateSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerTemplateSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                      `json:"shard,omitempty"`
	Sigalgs        *string                   `json:"sigalgs,omitempty"`
	Slowstart      *int                      `json:"slowstart"`
	Sni            *string                   `json:"sni,omitempty"`
	Socks4         *string                   `json:"socks4,omitempty"`
	Source         *string                   `json:"source,omitempty"`
	Ssl            *ServerTemplateSsl        `json:"ssl,omitempty"`
	SslCafile      *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerTemplateSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerTemplateSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerTemplateSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerTemplateSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerTemplateStick      `json:"stick,omitempty"`
	TcpUt          *int                      `json:"tcp_ut"`
	Tfo            *ServerTemplateTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTemplateTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerTemplateTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerTemplateTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerTemplateTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerTemplateTlsv13     `json:"tlsv13,omitempty"`
	Track          *string                   `json:"track,omitempty"`
	Verify         *ServerTemplateVerify     `json:"verify,omitempty"`
	Verifyhost     *string                   `json:"verifyhost,omitempty"`
	Weight         *int                      `json:"weight"`
	Ws             *ServerTemplateWs         `json:"ws,omitempty"`
}

// ServerTemplateAgentCheck defines model for ServerTemplate.AgentCheck.
type ServerTemplateAgentCheck string

// ServerTemplateBackup defines model for ServerTemplate.Backup.
type ServerTemplateBackup string

// ServerTemplateCheck defines model for ServerTemplate.Check.
type ServerTemplateCheck string

// ServerTemplateCheckSendProxy defines model for ServerTemplate.CheckSendProxy.
type ServerTemplateCheckSendProxy string

// ServerTemplateCheckSsl defines model for ServerTemplate.CheckSsl.
type ServerTemplateCheckSsl string

// ServerTemplateCheckViaSocks4 defines model for ServerTemplate.CheckViaSocks4.
type ServerTemplateCheckViaSocks4 string

// ServerTemplateForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerTemplateForceSslv3 string

// ServerTemplateForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerTemplateForceTlsv10 string

// ServerTemplateForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerTemplateForceTlsv11 string

// ServerTemplateForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerTemplateForceTlsv12 string

// ServerTemplateForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerTemplateForceTlsv13 string

// ServerTemplateInitState defines model for ServerTemplate.InitState.
type ServerTemplateInitState string

// ServerTemplateLogProto defines model for ServerTemplate.LogProto.
type ServerTemplateLogProto string

// ServerTemplateMaintenance defines model for ServerTemplate.Maintenance.
type ServerTemplateMaintenance string

// ServerTemplateNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerTemplateNoSslv3 string

// ServerTemplateNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerTemplateNoTlsv10 string

// ServerTemplateNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerTemplateNoTlsv11 string

// ServerTemplateNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerTemplateNoTlsv12 string

// ServerTemplateNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerTemplateNoTlsv13 string

// ServerTemplateNoVerifyhost defines model for ServerTemplate.NoVerifyhost.
type ServerTemplateNoVerifyhost string

// ServerTemplateObserve defines model for ServerTemplate.Observe.
type ServerTemplateObserve string

// ServerTemplateOnError defines model for ServerTemplate.OnError.
type ServerTemplateOnError string

// ServerTemplateOnMarkedDown defines model for ServerTemplate.OnMarkedDown.
type ServerTemplateOnMarkedDown string

// ServerTemplateOnMarkedUp defines model for ServerTemplate.OnMarkedUp.
type ServerTemplateOnMarkedUp string

// ServerTemplateProxyV2Options defines model for ServerTemplate.ProxyV2Options.
type ServerTemplateProxyV2Options string

// ServerTemplateResolvePrefer defines model for ServerTemplate.ResolvePrefer.
type ServerTemplateResolvePrefer string

// ServerTemplateSendProxy defines model for ServerTemplate.SendProxy.
type ServerTemplateSendProxy string

// ServerTemplateSendProxyV2 defines model for ServerTemplate.SendProxyV2.
type ServerTemplateSendProxyV2 string

// ServerTemplateSendProxyV2Ssl defines model for ServerTemplate.SendProxyV2Ssl.
type ServerTemplateSendProxyV2Ssl string

// ServerTemplateSendProxyV2SslCn defines model for ServerTemplate.SendProxyV2SslCn.
type ServerTemplateSendProxyV2SslCn string

// ServerTemplateSsl defines model for ServerTemplate.Ssl.
type ServerTemplateSsl string

// ServerTemplateSslMaxVer defines model for ServerTemplate.SslMaxVer.
type ServerTemplateSslMaxVer string

// ServerTemplateSslMinVer defines model for ServerTemplate.SslMinVer.
type ServerTemplateSslMinVer string

// ServerTemplateSslReuse defines model for ServerTemplate.SslReuse.
type ServerTemplateSslReuse string

// ServerTemplateSslv3 defines model for ServerTemplate.Sslv3.
type ServerTemplateSslv3 string

// ServerTemplateStick defines model for ServerTemplate.Stick.
type ServerTemplateStick string

// ServerTemplateTfo defines model for ServerTemplate.Tfo.
type ServerTemplateTfo string

// ServerTemplateTlsTickets defines model for ServerTemplate.TlsTickets.
type ServerTemplateTlsTickets string

// ServerTemplateTlsv10 defines model for ServerTemplate.Tlsv10.
type ServerTemplateTlsv10 string

// ServerTemplateTlsv11 defines model for ServerTemplate.Tlsv11.
type ServerTemplateTlsv11 string

// ServerTemplateTlsv12 defines model for ServerTemplate.Tlsv12.
type ServerTemplateTlsv12 string

// ServerTemplateTlsv13 defines model for ServerTemplate.Tlsv13.
type ServerTemplateTlsv13 string

// ServerTemplateVerify defines model for ServerTemplate.Verify.
type ServerTemplateVerify string

// ServerTemplateWs defines model for ServerTemplate.Ws.
type ServerTemplateWs string

// ServerTemplates HAProxy backend server templates array
type ServerTemplates = []ServerTemplate

// Servers HAProxy backend servers array
type Servers = []Server

// Site Site configuration. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Site struct {
	Farms *[]struct {
		Balance    *Balance       `json:"balance,omitempty"`
		Cond       *SiteFarmsCond `json:"cond,omitempty"`
		CondTest   *string        `json:"cond_test,omitempty"`
		Forwardfor *Forwardfor    `json:"forwardfor,omitempty"`
		Mode       *SiteFarmsMode `json:"mode,omitempty"`
		Name       string         `json:"name"`
		Servers    *[]Server      `json:"servers,omitempty"`
		UseAs      SiteFarmsUseAs `json:"use_as"`
	} `json:"farms,omitempty"`
	Name    string `json:"name"`
	Service *struct {
		HttpConnectionMode *SiteServiceHttpConnectionMode `json:"http_connection_mode,omitempty"`
		Listeners          *[]Bind                        `json:"listeners,omitempty"`
		Maxconn            *int                           `json:"maxconn"`
		Mode               *SiteServiceMode               `json:"mode,omitempty"`
	} `json:"service,omitempty"`
}

// SiteFarmsCond defines model for Site.Farms.Cond.
type SiteFarmsCond string

// SiteFarmsMode defines model for Site.Farms.Mode.
type SiteFarmsMode string

// SiteFarmsUseAs defines model for Site.Farms.UseAs.
type SiteFarmsUseAs string

// SiteServiceHttpConnectionMode defines model for Site.Service.HttpConnectionMode.
type SiteServiceHttpConnectionMode string

// SiteServiceMode defines model for Site.Service.Mode.
type SiteServiceMode string

// Sites Sites array. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Sites = []Site

// SmtpchkParams defines model for smtpchk_params.
type SmtpchkParams struct {
	Domain *string `json:"domain,omitempty"`
	Hello  *string `json:"hello,omitempty"`
}

// Source defines model for source.
type Source struct {
	Address       string        `json:"address"`
	AddressSecond *string       `json:"address_second,omitempty"`
	Hdr           *string       `json:"hdr,omitempty"`
	Interface     *string       `json:"interface,omitempty"`
	Occ           *string       `json:"occ,omitempty"`
	Port          *int          `json:"port,omitempty"`
	PortSecond    *int          `json:"port_second,omitempty"`
	Usesrc        *SourceUsesrc `json:"usesrc,omitempty"`
}

// SourceUsesrc defines model for Source.Usesrc.
type SourceUsesrc string

// SpoeAgent SPOE agent configuration
type SpoeAgent struct {
	Async           *SpoeAgentAsync           `json:"async,omitempty"`
	ContinueOnError *SpoeAgentContinueOnError `json:"continue-on-error,omitempty"`
	DontlogNormal   *SpoeAgentDontlogNormal   `json:"dontlog-normal,omitempty"`
	EngineName      *string                   `json:"engine-name,omitempty"`
	ForceSetVar     *SpoeAgentForceSetVar     `json:"force-set-var,omitempty"`
	Groups          *string                   `json:"groups,omitempty"`
	HelloTimeout    *int                      `json:"hello_timeout,omitempty"`
	IdleTimeout     *int                      `json:"idle_timeout,omitempty"`

	// Log HAProxy log target array (corresponds to log directives)
	Log                  *LogTargets               `json:"log,omitempty"`
	MaxFrameSize         *int                      `json:"max-frame-size,omitempty"`
	MaxWaitingFrames     *int                      `json:"max-waiting-frames,omitempty"`
	Maxconnrate          *int                      `json:"maxconnrate,omitempty"`
	Maxerrrate           *int                      `json:"maxerrrate,omitempty"`
	Messages             *string                   `json:"messages,omitempty"`
	Name                 string                    `json:"name"`
	OptionSetOnError     *string                   `json:"option_set-on-error,omitempty"`
	OptionSetProcessTime *string                   `json:"option_set-process-time,omitempty"`
	OptionSetTotalTime   *string                   `json:"option_set-total-time,omitempty"`
	OptionVarPrefix      *string                   `json:"option_var-prefix,omitempty"`
	Pipelining           *SpoeAgentPipelining      `json:"pipelining,omitempty"`
	ProcessingTimeout    *int                      `json:"processing_timeout,omitempty"`
	RegisterVarNames     *string                   `json:"register-var-names,omitempty"`
	SendFragPayload      *SpoeAgentSendFragPayload `json:"send-frag-payload,omitempty"`
	UseBackend           *string                   `json:"use-backend,omitempty"`
}

// SpoeAgentAsync defines model for SpoeAgent.Async.
type SpoeAgentAsync string

// SpoeAgentContinueOnError defines model for SpoeAgent.ContinueOnError.
type SpoeAgentContinueOnError string

// SpoeAgentDontlogNormal defines model for SpoeAgent.DontlogNormal.
type SpoeAgentDontlogNormal string

// SpoeAgentForceSetVar defines model for SpoeAgent.ForceSetVar.
type SpoeAgentForceSetVar string

// SpoeAgentPipelining defines model for SpoeAgent.Pipelining.
type SpoeAgentPipelining string

// SpoeAgentSendFragPayload defines model for SpoeAgent.SendFragPayload.
type SpoeAgentSendFragPayload string

// SpoeAgents SPOE Agents of one scope in SPOE file
type SpoeAgents = []SpoeAgent

// SpoeFiles SPOE files
type SpoeFiles = []string

// SpoeGroup SPOE group section configuration
type SpoeGroup struct {
	Messages *string `json:"messages,omitempty"`
	Name     string  `json:"name"`
}

// SpoeGroups SPOE Groups of one scope in SPOE file
type SpoeGroups = []SpoeGroup

// SpoeMessage SPOE message section configuration
type SpoeMessage struct {
	// Acl HAProxy ACL lines array (corresponds to acl directives)
	Acl   *Acls   `json:"acl,omitempty"`
	Args  *string `json:"args,omitempty"`
	Event *struct {
		Cond     *SpoeMessageEventCond `json:"cond,omitempty"`
		CondTest *string               `json:"cond_test,omitempty"`
		Name     SpoeMessageEventName  `json:"name"`
	} `json:"event,omitempty"`
	Name string `json:"name"`
}

// SpoeMessageEventCond defines model for SpoeMessage.Event.Cond.
type SpoeMessageEventCond string

// SpoeMessageEventName defines model for SpoeMessage.Event.Name.
type SpoeMessageEventName string

// SpoeMessages SPOE Messages of one scope in SPOE file
type SpoeMessages = []SpoeMessage

// SpoeScope SPOE scope name
type SpoeScope = string

// SpoeScopes All SPOE Scopes
type SpoeScopes = []SpoeScope

// SpoeTransaction SPOE configuration transaction
type SpoeTransaction struct {
	UnderscoreVersion *int                   `json:"_version,omitempty"`
	Id                *string                `json:"id,omitempty"`
	Status            *SpoeTransactionStatus `json:"status,omitempty"`
}

// SpoeTransactionStatus defines model for SpoeTransaction.Status.
type SpoeTransactionStatus string

// SpoeTransactions SPOE Configuration transactions array
type SpoeTransactions = []SpoeTransaction

// SslCertificate A file containing one or more SSL/TLS certificates and keys
type SslCertificate struct {
	Algorithm         *string    `json:"algorithm,omitempty"`
	AuthorityKeyId    *string    `json:"authority_key_id,omitempty"`
	Description       *string    `json:"description,omitempty"`
	Domains           *string    `json:"domains,omitempty"`
	File              *string    `json:"file,omitempty"`
	IpAddresses       *string    `json:"ip_addresses,omitempty"`
	Issuers           *string    `json:"issuers,omitempty"`
	NotAfter          *time.Time `json:"not_after"`
	NotBefore         *time.Time `json:"not_before"`
	Serial            *string    `json:"serial,omitempty"`
	Sha1FingerPrint   *string    `json:"sha1_finger_print,omitempty"`
	Sha256FingerPrint *string    `json:"sha256_finger_print,omitempty"`

	// Size File size in bytes.
	Size                    *int    `json:"size"`
	StorageName             *string `json:"storage_name,omitempty"`
	Subject                 *string `json:"subject,omitempty"`
	SubjectAlternativeNames *string `json:"subject_alternative_names,omitempty"`
	SubjectKeyId            *string `json:"subject_key_id,omitempty"`
}

// SslCertificates Array of ssl certificate files
type SslCertificates = []SslCertificate

// SslOptions defines model for ssl_options.
type SslOptions struct {
	CaBase                     *string `json:"ca_base,omitempty"`
	CrtBase                    *string `json:"crt_base,omitempty"`
	DefaultBindCiphers         *string `json:"default_bind_ciphers,omitempty"`
	DefaultBindCiphersuites    *string `json:"default_bind_ciphersuites,omitempty"`
	DefaultBindClientSigalgs   *string `json:"default_bind_client_sigalgs,omitempty"`
	DefaultBindCurves          *string `json:"default_bind_curves,omitempty"`
	DefaultBindOptions         *string `json:"default_bind_options,omitempty"`
	DefaultBindSigalgs         *string `json:"default_bind_sigalgs,omitempty"`
	DefaultServerCiphers       *string `json:"default_server_ciphers,omitempty"`
	DefaultServerCiphersuites  *string `json:"default_server_ciphersuites,omitempty"`
	DefaultServerClientSigalgs *string `json:"default_server_client_sigalgs,omitempty"`
	DefaultServerCurves        *string `json:"default_server_curves,omitempty"`
	DefaultServerOptions       *string `json:"default_server_options,omitempty"`
	DefaultServerSigalgs       *string `json:"default_server_sigalgs,omitempty"`
	DhParamFile                *string `json:"dh_param_file,omitempty"`
	SslEngines                 *[]struct {
		Algorithms *string `json:"algorithms"`
		Name       string  `json:"name"`
	} `json:"engines,omitempty"`
	IssuersChainPath *string                 `json:"issuers_chain_path,omitempty"`
	LoadExtraFiles   *string                 `json:"load_extra_files,omitempty"`
	Maxsslconn       *int                    `json:"maxsslconn,omitempty"`
	Maxsslrate       *int                    `json:"maxsslrate,omitempty"`
	ModeAsync        *SslOptionsModeAsync    `json:"mode_async,omitempty"`
	Propquery        *string                 `json:"propquery,omitempty"`
	Provider         *string                 `json:"provider,omitempty"`
	ProviderPath     *string                 `json:"provider_path,omitempty"`
	SecurityLevel    *int                    `json:"security_level"`
	ServerVerify     *SslOptionsServerVerify `json:"server_verify,omitempty"`
	SkipSelfIssuedCa *bool                   `json:"skip_self_issued_ca,omitempty"`
}

// SslOptionsModeAsync defines model for SslOptions.ModeAsync.
type SslOptionsModeAsync string

// SslOptionsServerVerify defines model for SslOptions.ServerVerify.
type SslOptionsServerVerify string

// StatsAuth defines model for stats_auth.
type StatsAuth struct {
	Passwd string `json:"passwd"`
	User   string `json:"user"`
}

// StatsHttpRequest defines model for stats_http_request.
type StatsHttpRequest struct {
	Cond     *string              `json:"cond,omitempty"`
	CondTest *string              `json:"cond_test,omitempty"`
	Realm    *string              `json:"realm,omitempty"`
	Type     StatsHttpRequestType `json:"type"`
}

// StatsHttpRequestType defines model for StatsHttpRequest.Type.
type StatsHttpRequestType string

// StatsOptions defines model for stats_options.
type StatsOptions struct {
	StatsAdmin         *bool                       `json:"stats_admin,omitempty"`
	StatsAdminCond     *StatsOptionsStatsAdminCond `json:"stats_admin_cond,omitempty"`
	StatsAdminCondTest *string                     `json:"stats_admin_cond_test,omitempty"`
	StatsAuths         *[]StatsAuth                `json:"stats_auths,omitempty"`
	StatsEnable        *bool                       `json:"stats_enable,omitempty"`
	StatsHideVersion   *bool                       `json:"stats_hide_version,omitempty"`
	StatsHttpRequests  *[]StatsHttpRequest         `json:"stats_http_requests,omitempty"`
	StatsMaxconn       *int                        `json:"stats_maxconn,omitempty"`
	StatsRealm         *bool                       `json:"stats_realm,omitempty"`
	StatsRealmRealm    *string                     `json:"stats_realm_realm"`
	StatsRefreshDelay  *int                        `json:"stats_refresh_delay"`
	StatsShowDesc      *string                     `json:"stats_show_desc"`
	StatsShowLegends   *bool                       `json:"stats_show_legends,omitempty"`
	StatsShowModules   *bool                       `json:"stats_show_modules,omitempty"`
	StatsShowNodeName  *string                     `json:"stats_show_node_name"`
	StatsUriPrefix     *string                     `json:"stats_uri_prefix,omitempty"`
}

// StatsOptionsStatsAdminCond defines model for StatsOptions.StatsAdminCond.
type StatsOptionsStatsAdminCond string

// StickRule Define a pattern used to create an entry in a stickiness table or matching condition or associate a user to a server.
type StickRule struct {
	Cond     *StickRuleCond `json:"cond,omitempty"`
	CondTest *string        `json:"cond_test,omitempty"`
	Pattern  string         `json:"pattern"`
	Table    *string        `json:"table,omitempty"`
	Type     StickRuleType  `json:"type"`
}

// StickRuleCond defines model for StickRule.Cond.
type StickRuleCond string

// StickRuleType defines model for StickRule.Type.
type StickRuleType string

// StickRules HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
type StickRules = []StickRule

// StickTable Stick Table Information
type StickTable struct {
	Fields *[]struct {
		Field  *StickTableFieldsField `json:"field,omitempty"`
		Idx    *int                   `json:"idx,omitempty"`
		Period *int                   `json:"period,omitempty"`
		Type   *StickTableFieldsType  `json:"type,omitempty"`
	} `json:"fields,omitempty"`
	Name *string         `json:"name,omitempty"`
	Size *int            `json:"size"`
	Type *StickTableType `json:"type,omitempty"`
	Used *int            `json:"used"`
}

// StickTableFieldsField defines model for StickTable.Fields.Field.
type StickTableFieldsField string

// StickTableFieldsType defines model for StickTable.Fields.Type.
type StickTableFieldsType string

// StickTableType defines model for StickTable.Type.
type StickTableType string

// StickTableEntries Entries of one runtime stick table
type StickTableEntries = []StickTableEntry

// StickTableEntry One entry in stick table
type StickTableEntry struct {
	BytesInCnt   *int `json:"bytes_in_cnt"`
	BytesInRate  *int `json:"bytes_in_rate"`
	BytesOutCnt  *int `json:"bytes_out_cnt"`
	BytesOutRate *int `json:"bytes_out_rate"`
	ConnCnt      *int `json:"conn_cnt"`
	ConnCur      *int `json:"conn_cur"`
	ConnRate     *int `json:"conn_rate"`
	Exp          *int `json:"exp"`
	GlitchCnt    *int `json:"glitch_cnt"`
	GlitchRate   *int `json:"glitch_rate"`
	Gpc          *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc,omitempty"`
	Gpc0     *int `json:"gpc0"`
	Gpc0Rate *int `json:"gpc0_rate"`
	Gpc1     *int `json:"gpc1"`
	Gpc1Rate *int `json:"gpc1_rate"`
	GpcRate  *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc_rate,omitempty"`
	Gpt *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpt,omitempty"`
	Gpt0         *int    `json:"gpt0"`
	HttpErrCnt   *int    `json:"http_err_cnt"`
	HttpErrRate  *int    `json:"http_err_rate"`
	HttpFailCnt  *int    `json:"http_fail_cnt"`
	HttpFailRate *int    `json:"http_fail_rate"`
	HttpReqCnt   *int    `json:"http_req_cnt"`
	HttpReqRate  *int    `json:"http_req_rate"`
	Id           *string `json:"id,omitempty"`
	Key          *string `json:"key,omitempty"`
	ServerId     *int    `json:"server_id"`
	SessCnt      *int    `json:"sess_cnt"`
	SessRate     *int    `json:"sess_rate"`
	Use          *bool   `json:"use,omitempty"`
}

// StickTables Array of runtime stick tables
type StickTables = []StickTable

// Table defines model for table.
type Table struct {
	Expire  *string    `json:"expire"`
	Name    *string    `json:"name,omitempty"`
	NoPurge *bool      `json:"no_purge,omitempty"`
	Size    *string    `json:"size,omitempty"`
	Store   *string    `json:"store,omitempty"`
	Type    *TableType `json:"type,omitempty"`
	TypeLen *int       `json:"type_len"`
	WriteTo *string    `json:"write_to"`
}

// TableType defines model for Table.Type.
type TableType string

// Tables HAProxy table array
type Tables = []Table

// TcpCheck defines model for tcp_check.
type TcpCheck struct {
	Action          TcpCheckAction       `json:"action"`
	Addr            *string              `json:"addr,omitempty"`
	Alpn            *string              `json:"alpn,omitempty"`
	CheckComment    *string              `json:"check_comment,omitempty"`
	Data            *string              `json:"data,omitempty"`
	Default         *bool                `json:"default,omitempty"`
	ErrorStatus     *TcpCheckErrorStatus `json:"error_status,omitempty"`
	ExclamationMark *bool                `json:"exclamation_mark,omitempty"`
	Fmt             *string              `json:"fmt,omitempty"`
	HexFmt          *string              `json:"hex_fmt,omitempty"`
	HexString       *string              `json:"hex_string,omitempty"`
	Linger          *bool                `json:"linger,omitempty"`
	Match           *TcpCheckMatch       `json:"match,omitempty"`
	MinRecv         *int                 `json:"min_recv,omitempty"`
	OkStatus        *TcpCheckOkStatus    `json:"ok_status,omitempty"`
	OnError         *string              `json:"on_error,omitempty"`
	OnSuccess       *string              `json:"on_success,omitempty"`
	Pattern         *string              `json:"pattern,omitempty"`
	Port            *int                 `json:"port"`
	PortString      *string              `json:"port_string,omitempty"`
	Proto           *string              `json:"proto,omitempty"`
	SendProxy       *bool                `json:"send_proxy,omitempty"`
	Sni             *string              `json:"sni,omitempty"`
	Ssl             *bool                `json:"ssl,omitempty"`
	StatusCode      *string              `json:"status-code,omitempty"`
	ToutStatus      *TcpCheckToutStatus  `json:"tout_status,omitempty"`
	VarExpr         *string              `json:"var_expr,omitempty"`
	VarFmt          *string              `json:"var_fmt,omitempty"`
	VarName         *string              `json:"var_name,omitempty"`
	VarScope        *string              `json:"var_scope,omitempty"`
	ViaSocks4       *bool                `json:"via_socks4,omitempty"`
}

// TcpCheckAction defines model for TcpCheck.Action.
type TcpCheckAction string

// TcpCheckErrorStatus defines model for TcpCheck.ErrorStatus.
type TcpCheckErrorStatus string

// TcpCheckMatch defines model for TcpCheck.Match.
type TcpCheckMatch string

// TcpCheckOkStatus defines model for TcpCheck.OkStatus.
type TcpCheckOkStatus string

// TcpCheckToutStatus defines model for TcpCheck.ToutStatus.
type TcpCheckToutStatus string

// TcpChecks defines model for tcp_checks.
type TcpChecks = []TcpCheck

// TcpRequestRule HAProxy TCP Request Rule configuration (corresponds to tcp-request)
type TcpRequestRule struct {
	Action               *TcpRequestRuleAction          `json:"action,omitempty"`
	BandwidthLimitLimit  *string                        `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                        `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                        `json:"bandwidth_limit_period,omitempty"`
	CaptureLen           *int                           `json:"capture_len,omitempty"`
	CaptureSample        *string                        `json:"capture_sample,omitempty"`
	Cond                 *TcpRequestRuleCond            `json:"cond,omitempty"`
	CondTest             *string                        `json:"cond_test,omitempty"`
	Expr                 *string                        `json:"expr,omitempty"`
	GptValue             *string                        `json:"gpt_value,omitempty"`
	LogLevel             *TcpRequestRuleLogLevel        `json:"log_level,omitempty"`
	LuaAction            *string                        `json:"lua_action,omitempty"`
	LuaParams            *string                        `json:"lua_params,omitempty"`
	MarkValue            *string                        `json:"mark_value,omitempty"`
	NiceValue            *int                           `json:"nice_value,omitempty"`
	ResolveProtocol      *TcpRequestRuleResolveProtocol `json:"resolve_protocol,omitempty"`
	ResolveResolvers     *string                        `json:"resolve_resolvers,omitempty"`
	ResolveVar           *string                        `json:"resolve_var,omitempty"`
	RstTtl               *int                           `json:"rst_ttl,omitempty"`
	ScIdx                *string                        `json:"sc_idx,omitempty"`
	ScIncId              *string                        `json:"sc_inc_id,omitempty"`
	ScInt                *int                           `json:"sc_int"`
	ServerName           *string                        `json:"server_name,omitempty"`
	ServiceName          *string                        `json:"service_name,omitempty"`
	SpoeEngineName       *string                        `json:"spoe_engine_name,omitempty"`
	SpoeGroupName        *string                        `json:"spoe_group_name,omitempty"`
	SwitchModeProto      *string                        `json:"switch_mode_proto,omitempty"`
	Timeout              *int                           `json:"timeout"`
	TosValue             *string                        `json:"tos_value,omitempty"`
	TrackKey             *string                        `json:"track_key,omitempty"`
	TrackStickCounter    *int                           `json:"track_stick_counter"`
	TrackTable           *string                        `json:"track_table,omitempty"`
	Type                 TcpRequestRuleType             `json:"type"`
	VarFormat            *string                        `json:"var_format,omitempty"`
	VarName              *string                        `json:"var_name,omitempty"`
	VarScope             *string                        `json:"var_scope,omitempty"`
}

// TcpRequestRuleAction defines model for TcpRequestRule.Action.
type TcpRequestRuleAction string

// TcpRequestRuleCond defines model for TcpRequestRule.Cond.
type TcpRequestRuleCond string

// TcpRequestRuleLogLevel defines model for TcpRequestRule.LogLevel.
type TcpRequestRuleLogLevel string

// TcpRequestRuleResolveProtocol defines model for TcpRequestRule.ResolveProtocol.
type TcpRequestRuleResolveProtocol string

// TcpRequestRuleType defines model for TcpRequestRule.Type.
type TcpRequestRuleType string

// TcpRequestRules HAProxy TCP request rules array (corresponds to tcp-request directive)
type TcpRequestRules = []TcpRequestRule

// TcpResponseRule HAProxy TCP Response Rule configuration (corresponds to tcp-response)
type TcpResponseRule struct {
	Action               *TcpResponseRuleAction   `json:"action,omitempty"`
	BandwidthLimitLimit  *string                  `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                  `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                  `json:"bandwidth_limit_period,omitempty"`
	Cond                 *TcpResponseRuleCond     `json:"cond,omitempty"`
	CondTest             *string                  `json:"cond_test,omitempty"`
	Expr                 *string                  `json:"expr,omitempty"`
	LogLevel             *TcpResponseRuleLogLevel `json:"log_level,omitempty"`
	LuaAction            *string                  `json:"lua_action,omitempty"`
	LuaParams            *string                  `json:"lua_params,omitempty"`
	MarkValue            *string                  `json:"mark_value,omitempty"`
	NiceValue            *int                     `json:"nice_value,omitempty"`
	RstTtl               *int                     `json:"rst_ttl,omitempty"`
	ScExpr               *string                  `json:"sc_expr,omitempty"`
	ScId                 *int                     `json:"sc_id,omitempty"`
	ScIdx                *int                     `json:"sc_idx,omitempty"`
	ScInt                *int                     `json:"sc_int"`
	SpoeEngine           *string                  `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                  `json:"spoe_group,omitempty"`
	Timeout              *int                     `json:"timeout"`
	TosValue             *string                  `json:"tos_value,omitempty"`
	Type                 TcpResponseRuleType      `json:"type"`
	VarFormat            *string                  `json:"var_format,omitempty"`
	VarName              *string                  `json:"var_name,omitempty"`
	VarScope             *string                  `json:"var_scope,omitempty"`
}

// TcpResponseRuleAction defines model for TcpResponseRule.Action.
type TcpResponseRuleAction string

// TcpResponseRuleCond defines model for TcpResponseRule.Cond.
type TcpResponseRuleCond string

// TcpResponseRuleLogLevel defines model for TcpResponseRule.LogLevel.
type TcpResponseRuleLogLevel string

// TcpResponseRuleType defines model for TcpResponseRule.Type.
type TcpResponseRuleType string

// TcpResponseRules HAProxy TCP response rules array (corresponds to tcp-response directive)
type TcpResponseRules = []TcpResponseRule

// TraceEntries list of entries in a traces section
type TraceEntries = []TraceEntry

// TraceEntry Configure a trace event
type TraceEntry struct {
	// Trace Trace parameters
	Trace string `json:"trace"`
}

// Traces Trace events configuration
type Traces struct {
	// Entries list of entries in a traces section
	Entries *TraceEntries `json:"entries,omitempty"`
}

// Transaction HAProxy configuration transaction
type Transaction struct {
	UnderscoreVersion *int               `json:"_version,omitempty"`
	Id                *string            `json:"id,omitempty"`
	Status            *TransactionStatus `json:"status,omitempty"`
}

// TransactionStatus defines model for Transaction.Status.
type TransactionStatus string

// Transactions Configuration transactions array
type Transactions = []Transaction

// TuneBufferOptions defines model for tune_buffer_options.
type TuneBufferOptions struct {
	BuffersLimit   *int `json:"buffers_limit"`
	BuffersReserve *int `json:"buffers_reserve,omitempty"`
	Bufsize        *int `json:"bufsize,omitempty"`
	BufsizeSmall   *int `json:"bufsize_small"`
	Pipesize       *int `json:"pipesize,omitempty"`
	RcvbufBackend  *int `json:"rcvbuf_backend"`
	RcvbufClient   *int `json:"rcvbuf_client"`
	RcvbufFrontend *int `json:"rcvbuf_frontend"`
	RcvbufServer   *int `json:"rcvbuf_server"`
	RecvEnough     *int `json:"recv_enough,omitempty"`
	SndbufBackend  *int `json:"sndbuf_backend"`
	SndbufClient   *int `json:"sndbuf_client"`
	SndbufFrontend *int `json:"sndbuf_frontend"`
	SndbufServer   *int `json:"sndbuf_server"`
}

// TuneLuaOptions defines model for tune_lua_options.
type TuneLuaOptions struct {
	BurstTimeout   *int                      `json:"burst_timeout"`
	ForcedYield    *int                      `json:"forced_yield,omitempty"`
	LogLoggers     *TuneLuaOptionsLogLoggers `json:"log_loggers,omitempty"`
	LogStderr      *TuneLuaOptionsLogStderr  `json:"log_stderr,omitempty"`
	Maxmem         *int                      `json:"maxmem"`
	ServiceTimeout *int                      `json:"service_timeout"`
	SessionTimeout *int                      `json:"session_timeout"`
	TaskTimeout    *int                      `json:"task_timeout"`
}

// TuneLuaOptionsLogLoggers defines model for TuneLuaOptions.LogLoggers.
type TuneLuaOptionsLogLoggers string

// TuneLuaOptionsLogStderr defines model for TuneLuaOptions.LogStderr.
type TuneLuaOptionsLogStderr string

// TuneOptions defines model for tune_options.
type TuneOptions struct {
	AppletZeroCopyForwarding  *TuneOptionsAppletZeroCopyForwarding `json:"applet_zero_copy_forwarding,omitempty"`
	CompMaxlevel              *int                                 `json:"comp_maxlevel,omitempty"`
	DisableFastForward        *bool                                `json:"disable_fast_forward,omitempty"`
	DisableZeroCopyForwarding *bool                                `json:"disable_zero_copy_forwarding,omitempty"`
	EventsMaxEventsAtOnce     *int                                 `json:"events_max_events_at_once,omitempty"`
	FailAlloc                 *bool                                `json:"fail_alloc,omitempty"`
	FdEdgeTriggered           *TuneOptionsFdEdgeTriggered          `json:"fd_edge_triggered,omitempty"`
	H1ZeroCopyFwdRecv         *TuneOptionsH1ZeroCopyFwdRecv        `json:"h1_zero_copy_fwd_recv,omitempty"`
	H1ZeroCopyFwdSend         *TuneOptionsH1ZeroCopyFwdSend        `json:"h1_zero_copy_fwd_send,omitempty"`
	H2BeGlitchesThreshold     *int                                 `json:"h2_be_glitches_threshold"`
	H2BeInitialWindowSize     *int                                 `json:"h2_be_initial_window_size,omitempty"`
	H2BeMaxConcurrentStreams  *int                                 `json:"h2_be_max_concurrent_streams,omitempty"`
	H2BeRxbuf                 *int                                 `json:"h2_be_rxbuf"`
	H2FeGlitchesThreshold     *int                                 `json:"h2_fe_glitches_threshold"`
	H2FeInitialWindowSize     *int                                 `json:"h2_fe_initial_window_size,omitempty"`
	H2FeMaxConcurrentStreams  *int                                 `json:"h2_fe_max_concurrent_streams,omitempty"`
	H2FeMaxTotalStreams       *int                                 `json:"h2_fe_max_total_streams"`
	H2FeRxbuf                 *int                                 `json:"h2_fe_rxbuf"`
	H2HeaderTableSize         *int                                 `json:"h2_header_table_size,omitempty"`
	H2InitialWindowSize       *int                                 `json:"h2_initial_window_size"`
	H2MaxConcurrentStreams    *int                                 `json:"h2_max_concurrent_streams,omitempty"`
	H2MaxFrameSize            *int                                 `json:"h2_max_frame_size,omitempty"`
	H2ZeroCopyFwdSend         *TuneOptionsH2ZeroCopyFwdSend        `json:"h2_zero_copy_fwd_send,omitempty"`
	HttpCookielen             *int                                 `json:"http_cookielen,omitempty"`
	HttpLogurilen             *int                                 `json:"http_logurilen,omitempty"`
	HttpMaxhdr                *int                                 `json:"http_maxhdr,omitempty"`
	IdlePoolShared            *TuneOptionsIdlePoolShared           `json:"idle_pool_shared,omitempty"`
	Idletimer                 *int                                 `json:"idletimer"`
	ListenerDefaultShards     *TuneOptionsListenerDefaultShards    `json:"listener_default_shards,omitempty"`
	ListenerMultiQueue        *TuneOptionsListenerMultiQueue       `json:"listener_multi_queue,omitempty"`
	MaxChecksPerThread        *int                                 `json:"max_checks_per_thread"`
	Maxaccept                 *int                                 `json:"maxaccept,omitempty"`
	Maxpollevents             *int                                 `json:"maxpollevents,omitempty"`
	Maxrewrite                *int                                 `json:"maxrewrite,omitempty"`
	MemoryHotSize             *int                                 `json:"memory_hot_size"`
	PatternCacheSize          *int                                 `json:"pattern_cache_size"`
	PeersMaxUpdatesAtOnce     *int                                 `json:"peers_max_updates_at_once,omitempty"`
	PoolHighFdRatio           *int                                 `json:"pool_high_fd_ratio,omitempty"`
	PoolLowFdRatio            *int                                 `json:"pool_low_fd_ratio,omitempty"`
	PtZeroCopyForwarding      *TuneOptionsPtZeroCopyForwarding     `json:"pt_zero_copy_forwarding,omitempty"`
	ReniceRuntime             *int                                 `json:"renice_runtime"`
	ReniceStartup             *int                                 `json:"renice_startup"`
	RingQueues                *int                                 `json:"ring_queues"`
	RunqueueDepth             *int                                 `json:"runqueue_depth,omitempty"`
	SchedLowLatency           *TuneOptionsSchedLowLatency          `json:"sched_low_latency,omitempty"`
	StickCounters             *int                                 `json:"stick_counters"`
}

// TuneOptionsAppletZeroCopyForwarding defines model for TuneOptions.AppletZeroCopyForwarding.
type TuneOptionsAppletZeroCopyForwarding string

// TuneOptionsFdEdgeTriggered defines model for TuneOptions.FdEdgeTriggered.
type TuneOptionsFdEdgeTriggered string

// TuneOptionsH1ZeroCopyFwdRecv defines model for TuneOptions.H1ZeroCopyFwdRecv.
type TuneOptionsH1ZeroCopyFwdRecv string

// TuneOptionsH1ZeroCopyFwdSend defines model for TuneOptions.H1ZeroCopyFwdSend.
type TuneOptionsH1ZeroCopyFwdSend string

// TuneOptionsH2ZeroCopyFwdSend defines model for TuneOptions.H2ZeroCopyFwdSend.
type TuneOptionsH2ZeroCopyFwdSend string

// TuneOptionsIdlePoolShared defines model for TuneOptions.IdlePoolShared.
type TuneOptionsIdlePoolShared string

// TuneOptionsListenerDefaultShards defines model for TuneOptions.ListenerDefaultShards.
type TuneOptionsListenerDefaultShards string

// TuneOptionsListenerMultiQueue defines model for TuneOptions.ListenerMultiQueue.
type TuneOptionsListenerMultiQueue string

// TuneOptionsPtZeroCopyForwarding defines model for TuneOptions.PtZeroCopyForwarding.
type TuneOptionsPtZeroCopyForwarding string

// TuneOptionsSchedLowLatency defines model for TuneOptions.SchedLowLatency.
type TuneOptionsSchedLowLatency string

// TuneQuicOptions defines model for tune_quic_options.
type TuneQuicOptions struct {
	FrontendConnTxBuffersLimit *int                            `json:"frontend_conn_tx_buffers_limit"`
	FrontendMaxIdleTimeout     *int                            `json:"frontend_max_idle_timeout"`
	FrontendMaxStreamsBidi     *int                            `json:"frontend_max_streams_bidi"`
	MaxFrameLoss               *int                            `json:"max_frame_loss"`
	ReorderRatio               *int                            `json:"reorder_ratio"`
	RetryThreshold             *int                            `json:"retry_threshold"`
	SocketOwner                *TuneQuicOptionsSocketOwner     `json:"socket_owner,omitempty"`
	ZeroCopyFwdSend            *TuneQuicOptionsZeroCopyFwdSend `json:"zero_copy_fwd_send,omitempty"`
}

// TuneQuicOptionsSocketOwner defines model for TuneQuicOptions.SocketOwner.
type TuneQuicOptionsSocketOwner string

// TuneQuicOptionsZeroCopyFwdSend defines model for TuneQuicOptions.ZeroCopyFwdSend.
type TuneQuicOptionsZeroCopyFwdSend string

// TuneSslOptions defines model for tune_ssl_options.
type TuneSslOptions struct {
	Cachesize          *int                  `json:"cachesize"`
	CaptureBufferSize  *int                  `json:"capture_buffer_size"`
	CtxCacheSize       *int                  `json:"ctx_cache_size,omitempty"`
	DefaultDhParam     *int                  `json:"default_dh_param,omitempty"`
	ForcePrivateCache  *bool                 `json:"force_private_cache,omitempty"`
	Keylog             *TuneSslOptionsKeylog `json:"keylog,omitempty"`
	Lifetime           *int                  `json:"lifetime"`
	Maxrecord          *int                  `json:"maxrecord"`
	OcspUpdateMaxDelay *int                  `json:"ocsp_update_max_delay"`
	OcspUpdateMinDelay *int                  `json:"ocsp_update_min_delay"`
}

// TuneSslOptionsKeylog defines model for TuneSslOptions.Keylog.
type TuneSslOptionsKeylog string

// TuneVarsOptions defines model for tune_vars_options.
type TuneVarsOptions struct {
	GlobalMaxSize *int `json:"global_max_size"`
	ProcMaxSize   *int `json:"proc_max_size"`
	ReqresMaxSize *int `json:"reqres_max_size"`
	SessMaxSize   *int `json:"sess_max_size"`
	TxnMaxSize    *int `json:"txn_max_size"`
}

// TuneZlibOptions defines model for tune_zlib_options.
type TuneZlibOptions struct {
	Memlevel   *int `json:"memlevel,omitempty"`
	Windowsize *int `json:"windowsize,omitempty"`
}

// User HAProxy userlist user
type User struct {
	Groups         *string `json:"groups,omitempty"`
	Password       string  `json:"password"`
	SecurePassword bool    `json:"secure_password"`
	Username       string  `json:"username"`
}

// Userlist defines model for userlist.
type Userlist struct {
	Groups *map[string]Group `json:"groups,omitempty"`
	Name   string            `json:"name"`
	Users  *map[string]User  `json:"users,omitempty"`
}

// UserlistBase HAProxy configuration of access control
type UserlistBase struct {
	Name string `json:"name"`
}

// Userlists HAProxy userlists array
type Userlists = []Userlist

// Users HAProxy userlist users array
type Users = []User

// WurflOptions defines model for wurfl_options.
type WurflOptions struct {
	CacheSize                *int    `json:"cache_size,omitempty"`
	DataFile                 *string `json:"data_file,omitempty"`
	InformationList          *string `json:"information_list,omitempty"`
	InformationListSeparator *string `json:"information_list_separator,omitempty"`
	PatchFile                *string `json:"patch_file,omitempty"`
}

// ForceReload defines model for force_reload.
type ForceReload = bool

// FullSection defines model for full_section.
type FullSection = bool

// ParentName defines model for parent_name.
type ParentName = string

// SkipReload defines model for skip_reload.
type SkipReload = bool

// TransactionId defines model for transaction_id.
type TransactionId = string

// Version defines model for version.
type Version = int

// AlreadyExists API Error
type AlreadyExists = Error

// BadRequest API Error
type BadRequest = Error

// DefaultError API Error
type DefaultError = Error

// NotAcceptable API Error
type NotAcceptable = Error

// NotFound API Error
type NotFound = Error

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *DeleteClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteClusterParamsConfiguration defines parameters for DeleteCluster.
type DeleteClusterParamsConfiguration string

// PostClusterParams defines parameters for PostCluster.
type PostClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *PostClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// AdvertisedAddress Force the advertised address when joining a cluster
	AdvertisedAddress *string `form:"advertised_address,omitempty" json:"advertised_address,omitempty"`

	// AdvertisedPort Force the advertised port when joining a cluster
	AdvertisedPort *int `form:"advertised_port,omitempty" json:"advertised_port,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostClusterParamsConfiguration defines parameters for PostCluster.
type PostClusterParamsConfiguration string

// EditClusterParams defines parameters for EditCluster.
type EditClusterParams struct {
	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetBackendsParams defines parameters for GetBackends.
type GetBackendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateBackendParams defines parameters for CreateBackend.
type CreateBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteBackendParams defines parameters for DeleteBackend.
type DeleteBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendParams defines parameters for GetBackend.
type GetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceBackendParams defines parameters for ReplaceBackend.
type ReplaceBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclBackendParams defines parameters for GetAllAclBackend.
type GetAllAclBackendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclBackendParams defines parameters for ReplaceAllAclBackend.
type ReplaceAllAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclBackendParams defines parameters for DeleteAclBackend.
type DeleteAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclBackendParams defines parameters for GetAclBackend.
type GetAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclBackendParams defines parameters for CreateAclBackend.
type CreateAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclBackendParams defines parameters for ReplaceAclBackend.
type ReplaceAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterBackendParams defines parameters for GetAllFilterBackend.
type GetAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterBackendParams defines parameters for ReplaceAllFilterBackend.
type ReplaceAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterBackendParams defines parameters for DeleteFilterBackend.
type DeleteFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterBackendParams defines parameters for GetFilterBackend.
type GetFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterBackendParams defines parameters for CreateFilterBackend.
type CreateFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterBackendParams defines parameters for ReplaceFilterBackend.
type ReplaceFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleBackendParams defines parameters for GetAllHTTPAfterResponseRuleBackend.
type GetAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleBackendParams defines parameters for ReplaceAllHTTPAfterResponseRuleBackend.
type ReplaceAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleBackendParams defines parameters for DeleteHTTPAfterResponseRuleBackend.
type DeleteHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleBackendParams defines parameters for GetHTTPAfterResponseRuleBackend.
type GetHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleBackendParams defines parameters for CreateHTTPAfterResponseRuleBackend.
type CreateHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleBackendParams defines parameters for ReplaceHTTPAfterResponseRuleBackend.
type ReplaceHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPCheckBackendParams defines parameters for GetAllHTTPCheckBackend.
type GetAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckBackendParams defines parameters for ReplaceAllHTTPCheckBackend.
type ReplaceAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckBackendParams defines parameters for DeleteHTTPCheckBackend.
type DeleteHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckBackendParams defines parameters for GetHTTPCheckBackend.
type GetHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckBackendParams defines parameters for CreateHTTPCheckBackend.
type CreateHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckBackendParams defines parameters for ReplaceHTTPCheckBackend.
type ReplaceHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleBackendParams defines parameters for GetAllHTTPErrorRuleBackend.
type GetAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleBackendParams defines parameters for ReplaceAllHTTPErrorRuleBackend.
type ReplaceAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleBackendParams defines parameters for DeleteHTTPErrorRuleBackend.
type DeleteHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleBackendParams defines parameters for GetHTTPErrorRuleBackend.
type GetHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleBackendParams defines parameters for CreateHTTPErrorRuleBackend.
type CreateHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleBackendParams defines parameters for ReplaceHTTPErrorRuleBackend.
type ReplaceHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleBackendParams defines parameters for GetAllHTTPRequestRuleBackend.
type GetAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleBackendParams defines parameters for ReplaceAllHTTPRequestRuleBackend.
type ReplaceAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleBackendParams defines parameters for DeleteHTTPRequestRuleBackend.
type DeleteHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleBackendParams defines parameters for GetHTTPRequestRuleBackend.
type GetHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleBackendParams defines parameters for CreateHTTPRequestRuleBackend.
type CreateHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleBackendParams defines parameters for ReplaceHTTPRequestRuleBackend.
type ReplaceHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleBackendParams defines parameters for GetAllHTTPResponseRuleBackend.
type GetAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleBackendParams defines parameters for ReplaceAllHTTPResponseRuleBackend.
type ReplaceAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleBackendParams defines parameters for DeleteHTTPResponseRuleBackend.
type DeleteHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleBackendParams defines parameters for GetHTTPResponseRuleBackend.
type GetHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleBackendParams defines parameters for CreateHTTPResponseRuleBackend.
type CreateHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleBackendParams defines parameters for ReplaceHTTPResponseRuleBackend.
type ReplaceHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetBackendParams defines parameters for GetAllLogTargetBackend.
type GetAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetBackendParams defines parameters for ReplaceAllLogTargetBackend.
type ReplaceAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetBackendParams defines parameters for DeleteLogTargetBackend.
type DeleteLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetBackendParams defines parameters for GetLogTargetBackend.
type GetLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetBackendParams defines parameters for CreateLogTargetBackend.
type CreateLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetBackendParams defines parameters for ReplaceLogTargetBackend.
type ReplaceLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRulesParams defines parameters for GetServerSwitchingRules.
type GetServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerSwitchingRulesParams defines parameters for ReplaceServerSwitchingRules.
type ReplaceServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerSwitchingRuleParams defines parameters for DeleteServerSwitchingRule.
type DeleteServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRuleParams defines parameters for GetServerSwitchingRule.
type GetServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerSwitchingRuleParams defines parameters for CreateServerSwitchingRule.
type CreateServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceServerSwitchingRuleParams defines parameters for ReplaceServerSwitchingRule.
type ReplaceServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplatesParams defines parameters for GetServerTemplates.
type GetServerTemplatesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerTemplateParams defines parameters for CreateServerTemplate.
type CreateServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerTemplateParams defines parameters for DeleteServerTemplate.
type DeleteServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplateParams defines parameters for GetServerTemplate.
type GetServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerTemplateParams defines parameters for ReplaceServerTemplate.
type ReplaceServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerBackendParams defines parameters for GetAllServerBackend.
type GetAllServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerBackendParams defines parameters for CreateServerBackend.
type CreateServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerBackendParams defines parameters for DeleteServerBackend.
type DeleteServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerBackendParams defines parameters for GetServerBackend.
type GetServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerBackendParams defines parameters for ReplaceServerBackend.
type ReplaceServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRulesParams defines parameters for GetStickRules.
type GetStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceStickRulesParams defines parameters for ReplaceStickRules.
type ReplaceStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStickRuleParams defines parameters for DeleteStickRule.
type DeleteStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRuleParams defines parameters for GetStickRule.
type GetStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateStickRuleParams defines parameters for CreateStickRule.
type CreateStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStickRuleParams defines parameters for ReplaceStickRule.
type ReplaceStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckBackendParams defines parameters for GetAllTCPCheckBackend.
type GetAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckBackendParams defines parameters for ReplaceAllTCPCheckBackend.
type ReplaceAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckBackendParams defines parameters for DeleteTCPCheckBackend.
type DeleteTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckBackendParams defines parameters for GetTCPCheckBackend.
type GetTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckBackendParams defines parameters for CreateTCPCheckBackend.
type CreateTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckBackendParams defines parameters for ReplaceTCPCheckBackend.
type ReplaceTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleBackendParams defines parameters for GetAllTCPRequestRuleBackend.
type GetAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleBackendParams defines parameters for ReplaceAllTCPRequestRuleBackend.
type ReplaceAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleBackendParams defines parameters for DeleteTCPRequestRuleBackend.
type DeleteTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleBackendParams defines parameters for GetTCPRequestRuleBackend.
type GetTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleBackendParams defines parameters for CreateTCPRequestRuleBackend.
type CreateTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleBackendParams defines parameters for ReplaceTCPRequestRuleBackend.
type ReplaceTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPResponseRuleBackendParams defines parameters for GetAllTCPResponseRuleBackend.
type GetAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPResponseRuleBackendParams defines parameters for ReplaceAllTCPResponseRuleBackend.
type ReplaceAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPResponseRuleBackendParams defines parameters for DeleteTCPResponseRuleBackend.
type DeleteTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPResponseRuleBackendParams defines parameters for GetTCPResponseRuleBackend.
type GetTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPResponseRuleBackendParams defines parameters for CreateTCPResponseRuleBackend.
type CreateTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPResponseRuleBackendParams defines parameters for ReplaceTCPResponseRuleBackend.
type ReplaceTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCachesParams defines parameters for GetCaches.
type GetCachesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCacheParams defines parameters for CreateCache.
type CreateCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCacheParams defines parameters for DeleteCache.
type DeleteCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCacheParams defines parameters for GetCache.
type GetCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCacheParams defines parameters for ReplaceCache.
type ReplaceCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtLoadsParams defines parameters for GetCrtLoads.
type GetCrtLoadsParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtLoadParams defines parameters for CreateCrtLoad.
type CreateCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtLoadParams defines parameters for DeleteCrtLoad.
type DeleteCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtLoadParams defines parameters for GetCrtLoad.
type GetCrtLoadParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCrtLoadParams defines parameters for ReplaceCrtLoad.
type ReplaceCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoresParams defines parameters for GetCrtStores.
type GetCrtStoresParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtStoreParams defines parameters for CreateCrtStore.
type CreateCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtStoreParams defines parameters for DeleteCrtStore.
type DeleteCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoreParams defines parameters for GetCrtStore.
type GetCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditCrtStoreParams defines parameters for EditCrtStore.
type EditCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDefaultsSectionsParams defines parameters for GetDefaultsSections.
type GetDefaultsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// AddDefaultsSectionParams defines parameters for AddDefaultsSection.
type AddDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateDefaultsSectionParams defines parameters for CreateDefaultsSection.
type CreateDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteDefaultsSectionParams defines parameters for DeleteDefaultsSection.
type DeleteDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetDefaultsSectionParams defines parameters for GetDefaultsSection.
type GetDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceDefaultsSectionParams defines parameters for ReplaceDefaultsSection.
type ReplaceDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllHTTPCheckDefaultsParams defines parameters for GetAllHTTPCheckDefaults.
type GetAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckDefaultsParams defines parameters for ReplaceAllHTTPCheckDefaults.
type ReplaceAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckDefaultsParams defines parameters for DeleteHTTPCheckDefaults.
type DeleteHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckDefaultsParams defines parameters for GetHTTPCheckDefaults.
type GetHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckDefaultsParams defines parameters for CreateHTTPCheckDefaults.
type CreateHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckDefaultsParams defines parameters for ReplaceHTTPCheckDefaults.
type ReplaceHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleDefaultsParams defines parameters for GetAllHTTPErrorRuleDefaults.
type GetAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleDefaultsParams defines parameters for ReplaceAllHTTPErrorRuleDefaults.
type ReplaceAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleDefaultsParams defines parameters for DeleteHTTPErrorRuleDefaults.
type DeleteHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleDefaultsParams defines parameters for GetHTTPErrorRuleDefaults.
type GetHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleDefaultsParams defines parameters for CreateHTTPErrorRuleDefaults.
type CreateHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleDefaultsParams defines parameters for ReplaceHTTPErrorRuleDefaults.
type ReplaceHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetDefaultsParams defines parameters for GetAllLogTargetDefaults.
type GetAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetDefaultsParams defines parameters for ReplaceAllLogTargetDefaults.
type ReplaceAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetDefaultsParams defines parameters for DeleteLogTargetDefaults.
type DeleteLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetDefaultsParams defines parameters for GetLogTargetDefaults.
type GetLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetDefaultsParams defines parameters for CreateLogTargetDefaults.
type CreateLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetDefaultsParams defines parameters for ReplaceLogTargetDefaults.
type ReplaceLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllQUICInitialRuleDefaultsParams defines parameters for GetAllQUICInitialRuleDefaults.
type GetAllQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllQUICInitialRuleDefaultsParams defines parameters for ReplaceAllQUICInitialRuleDefaults.
type ReplaceAllQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteQUICInitialRuleDefaultsParams defines parameters for DeleteQUICInitialRuleDefaults.
type DeleteQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetQUICInitialRuleDefaultsParams defines parameters for GetQUICInitialRuleDefaults.
type GetQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateQUICInitialRuleDefaultsParams defines parameters for CreateQUICInitialRuleDefaults.
type CreateQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceQUICInitialRuleDefaultsParams defines parameters for ReplaceQUICInitialRuleDefaults.
type ReplaceQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckDefaultsParams defines parameters for GetAllTCPCheckDefaults.
type GetAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckDefaultsParams defines parameters for ReplaceAllTCPCheckDefaults.
type ReplaceAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckDefaultsParams defines parameters for DeleteTCPCheckDefaults.
type DeleteTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckDefaultsParams defines parameters for GetTCPCheckDefaults.
type GetTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckDefaultsParams defines parameters for CreateTCPCheckDefaults.
type CreateTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckDefaultsParams defines parameters for ReplaceTCPCheckDefaults.
type ReplaceTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppsParams defines parameters for GetFCGIApps.
type GetFCGIAppsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFCGIAppParams defines parameters for CreateFCGIApp.
type CreateFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFCGIAppParams defines parameters for DeleteFCGIApp.
type DeleteFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppParams defines parameters for GetFCGIApp.
type GetFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFCGIAppParams defines parameters for ReplaceFCGIApp.
type ReplaceFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFCGIAppParams defines parameters for GetAllAclFCGIApp.
type GetAllAclFCGIAppParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFCGIAppParams defines parameters for ReplaceAllAclFCGIApp.
type ReplaceAllAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFCGIAppParams defines parameters for DeleteAclFCGIApp.
type DeleteAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFCGIAppParams defines parameters for GetAclFCGIApp.
type GetAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFCGIAppParams defines parameters for CreateAclFCGIApp.
type CreateAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFCGIAppParams defines parameters for ReplaceAclFCGIApp.
type ReplaceAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendsParams defines parameters for GetFrontends.
type GetFrontendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFrontendParams defines parameters for CreateFrontend.
type CreateFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFrontendParams defines parameters for DeleteFrontend.
type DeleteFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendParams defines parameters for GetFrontend.
type GetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFrontendParams defines parameters for ReplaceFrontend.
type ReplaceFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFrontendParams defines parameters for GetAllAclFrontend.
type GetAllAclFrontendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFrontendParams defines parameters for ReplaceAllAclFrontend.
type ReplaceAllAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFrontendParams defines parameters for DeleteAclFrontend.
type DeleteAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFrontendParams defines parameters for GetAclFrontend.
type GetAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFrontendParams defines parameters for CreateAclFrontend.
type CreateAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFrontendParams defines parameters for ReplaceAclFrontend.
type ReplaceAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRulesParams defines parameters for GetBackendSwitchingRules.
type GetBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBackendSwitchingRulesParams defines parameters for ReplaceBackendSwitchingRules.
type ReplaceBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBackendSwitchingRuleParams defines parameters for DeleteBackendSwitchingRule.
type DeleteBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRuleParams defines parameters for GetBackendSwitchingRule.
type GetBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBackendSwitchingRuleParams defines parameters for CreateBackendSwitchingRule.
type CreateBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceBackendSwitchingRuleParams defines parameters for ReplaceBackendSwitchingRule.
type ReplaceBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllBindFrontendParams defines parameters for GetAllBindFrontend.
type GetAllBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindFrontendParams defines parameters for CreateBindFrontend.
type CreateBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindFrontendParams defines parameters for DeleteBindFrontend.
type DeleteBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindFrontendParams defines parameters for GetBindFrontend.
type GetBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindFrontendParams defines parameters for ReplaceBindFrontend.
type ReplaceBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCapturesParams defines parameters for GetDeclareCaptures.
type GetDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDeclareCapturesParams defines parameters for ReplaceDeclareCaptures.
type ReplaceDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDeclareCaptureParams defines parameters for DeleteDeclareCapture.
type DeleteDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCaptureParams defines parameters for GetDeclareCapture.
type GetDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDeclareCaptureParams defines parameters for CreateDeclareCapture.
type CreateDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceDeclareCaptureParams defines parameters for ReplaceDeclareCapture.
type ReplaceDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterFrontendParams defines parameters for GetAllFilterFrontend.
type GetAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterFrontendParams defines parameters for ReplaceAllFilterFrontend.
type ReplaceAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterFrontendParams defines parameters for DeleteFilterFrontend.
type DeleteFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterFrontendParams defines parameters for GetFilterFrontend.
type GetFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterFrontendParams defines parameters for CreateFilterFrontend.
type CreateFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterFrontendParams defines parameters for ReplaceFilterFrontend.
type ReplaceFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleFrontendParams defines parameters for GetAllHTTPAfterResponseRuleFrontend.
type GetAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceAllHTTPAfterResponseRuleFrontend.
type ReplaceAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleFrontendParams defines parameters for DeleteHTTPAfterResponseRuleFrontend.
type DeleteHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleFrontendParams defines parameters for GetHTTPAfterResponseRuleFrontend.
type GetHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleFrontendParams defines parameters for CreateHTTPAfterResponseRuleFrontend.
type CreateHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceHTTPAfterResponseRuleFrontend.
type ReplaceHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleFrontendParams defines parameters for GetAllHTTPErrorRuleFrontend.
type GetAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleFrontendParams defines parameters for ReplaceAllHTTPErrorRuleFrontend.
type ReplaceAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleFrontendParams defines parameters for DeleteHTTPErrorRuleFrontend.
type DeleteHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleFrontendParams defines parameters for GetHTTPErrorRuleFrontend.
type GetHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleFrontendParams defines parameters for CreateHTTPErrorRuleFrontend.
type CreateHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleFrontendParams defines parameters for ReplaceHTTPErrorRuleFrontend.
type ReplaceHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleFrontendParams defines parameters for GetAllHTTPRequestRuleFrontend.
type GetAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleFrontendParams defines parameters for ReplaceAllHTTPRequestRuleFrontend.
type ReplaceAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleFrontendParams defines parameters for DeleteHTTPRequestRuleFrontend.
type DeleteHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleFrontendParams defines parameters for GetHTTPRequestRuleFrontend.
type GetHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleFrontendParams defines parameters for CreateHTTPRequestRuleFrontend.
type CreateHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleFrontendParams defines parameters for ReplaceHTTPRequestRuleFrontend.
type ReplaceHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleFrontendParams defines parameters for GetAllHTTPResponseRuleFrontend.
type GetAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleFrontendParams defines parameters for ReplaceAllHTTPResponseRuleFrontend.
type ReplaceAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleFrontendParams defines parameters for DeleteHTTPResponseRuleFrontend.
type DeleteHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleFrontendParams defines parameters for GetHTTPResponseRuleFrontend.
type GetHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleFrontendParams defines parameters for CreateHTTPResponseRuleFrontend.
type CreateHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleFrontendParams defines parameters for ReplaceHTTPResponseRuleFrontend.
type ReplaceHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetFrontendParams defines parameters for GetAllLogTargetFrontend.
type GetAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetFrontendParams defines parameters for ReplaceAllLogTargetFrontend.
type ReplaceAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetFrontendParams defines parameters for DeleteLogTargetFrontend.
type DeleteLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetFrontendParams defines parameters for GetLogTargetFrontend.
type GetLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetFrontendParams defines parameters for CreateLogTargetFrontend.
type CreateLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetFrontendParams defines parameters for ReplaceLogTargetFrontend.
type ReplaceLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllQUICInitialRuleFrontendParams defines parameters for GetAllQUICInitialRuleFrontend.
type GetAllQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllQUICInitialRuleFrontendParams defines parameters for ReplaceAllQUICInitialRuleFrontend.
type ReplaceAllQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteQUICInitialRuleFrontendParams defines parameters for DeleteQUICInitialRuleFrontend.
type DeleteQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetQUICInitialRuleFrontendParams defines parameters for GetQUICInitialRuleFrontend.
type GetQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateQUICInitialRuleFrontendParams defines parameters for CreateQUICInitialRuleFrontend.
type CreateQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceQUICInitialRuleFrontendParams defines parameters for ReplaceQUICInitialRuleFrontend.
type ReplaceQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleFrontendParams defines parameters for GetAllTCPRequestRuleFrontend.
type GetAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleFrontendParams defines parameters for ReplaceAllTCPRequestRuleFrontend.
type ReplaceAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleFrontendParams defines parameters for DeleteTCPRequestRuleFrontend.
type DeleteTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleFrontendParams defines parameters for GetTCPRequestRuleFrontend.
type GetTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleFrontendParams defines parameters for CreateTCPRequestRuleFrontend.
type CreateTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleFrontendParams defines parameters for ReplaceTCPRequestRuleFrontend.
type ReplaceTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGlobalParams defines parameters for GetGlobal.
type GetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceGlobalParams defines parameters for ReplaceGlobal.
type ReplaceGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllLogTargetGlobalParams defines parameters for GetAllLogTargetGlobal.
type GetAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetGlobalParams defines parameters for ReplaceAllLogTargetGlobal.
type ReplaceAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetGlobalParams defines parameters for DeleteLogTargetGlobal.
type DeleteLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetGlobalParams defines parameters for GetLogTargetGlobal.
type GetLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetGlobalParams defines parameters for CreateLogTargetGlobal.
type CreateLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetGlobalParams defines parameters for ReplaceLogTargetGlobal.
type ReplaceLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateGroupParams defines parameters for CreateGroup.
type CreateGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteGroupParams defines parameters for DeleteGroup.
type DeleteGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupParams defines parameters for GetGroup.
type GetGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceGroupParams defines parameters for ReplaceGroup.
type ReplaceGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionsParams defines parameters for GetHTTPErrorsSections.
type GetHTTPErrorsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorsSectionParams defines parameters for CreateHTTPErrorsSection.
type CreateHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorsSectionParams defines parameters for DeleteHTTPErrorsSection.
type DeleteHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionParams defines parameters for GetHTTPErrorsSection.
type GetHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceHTTPErrorsSectionParams defines parameters for ReplaceHTTPErrorsSection.
type ReplaceHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardsParams defines parameters for GetLogForwards.
type GetLogForwardsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateLogForwardParams defines parameters for CreateLogForward.
type CreateLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteLogForwardParams defines parameters for DeleteLogForward.
type DeleteLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardParams defines parameters for GetLogForward.
type GetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceLogForwardParams defines parameters for ReplaceLogForward.
type ReplaceLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindLogForwardParams defines parameters for GetAllBindLogForward.
type GetAllBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindLogForwardParams defines parameters for CreateBindLogForward.
type CreateBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindLogForwardParams defines parameters for DeleteBindLogForward.
type DeleteBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindLogForwardParams defines parameters for GetBindLogForward.
type GetBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindLogForwardParams defines parameters for ReplaceBindLogForward.
type ReplaceBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindsParams defines parameters for GetDgramBinds.
type GetDgramBindsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDgramBindParams defines parameters for CreateDgramBind.
type CreateDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDgramBindParams defines parameters for DeleteDgramBind.
type DeleteDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindParams defines parameters for GetDgramBind.
type GetDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDgramBindParams defines parameters for ReplaceDgramBind.
type ReplaceDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetLogForwardParams defines parameters for GetAllLogTargetLogForward.
type GetAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetLogForwardParams defines parameters for ReplaceAllLogTargetLogForward.
type ReplaceAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetLogForwardParams defines parameters for DeleteLogTargetLogForward.
type DeleteLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetLogForwardParams defines parameters for GetLogTargetLogForward.
type GetLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetLogForwardParams defines parameters for CreateLogTargetLogForward.
type CreateLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetLogForwardParams defines parameters for ReplaceLogTargetLogForward.
type ReplaceLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogProfilesParams defines parameters for GetLogProfiles.
type GetLogProfilesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogProfileParams defines parameters for CreateLogProfile.
type CreateLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogProfileParams defines parameters for DeleteLogProfile.
type DeleteLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogProfileParams defines parameters for GetLogProfile.
type GetLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditLogProfileParams defines parameters for EditLogProfile.
type EditLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntriesParams defines parameters for GetMailerEntries.
type GetMailerEntriesParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateMailerEntryParams defines parameters for CreateMailerEntry.
type CreateMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteMailerEntryParams defines parameters for DeleteMailerEntry.
type DeleteMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntryParams defines parameters for GetMailerEntry.
type GetMailerEntryParams struct {
	// MailersSection Parent mailers name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceMailerEntryParams defines parameters for ReplaceMailerEntry.
type ReplaceMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionsParams defines parameters for GetMailersSections.
type GetMailersSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateMailersSectionParams defines parameters for CreateMailersSection.
type CreateMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteMailersSectionParams defines parameters for DeleteMailersSection.
type DeleteMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionParams defines parameters for GetMailersSection.
type GetMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// EditMailersSectionParams defines parameters for EditMailersSection.
type EditMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetNameserversParams defines parameters for GetNameservers.
type GetNameserversParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateNameserverParams defines parameters for CreateNameserver.
type CreateNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteNameserverParams defines parameters for DeleteNameserver.
type DeleteNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetNameserverParams defines parameters for GetNameserver.
type GetNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceNameserverParams defines parameters for ReplaceNameserver.
type ReplaceNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntriesParams defines parameters for GetPeerEntries.
type GetPeerEntriesParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreatePeerEntryParams defines parameters for CreatePeerEntry.
type CreatePeerEntryParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeletePeerEntryParams defines parameters for DeletePeerEntry.
type DeletePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntryParams defines parameters for GetPeerEntry.
type GetPeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplacePeerEntryParams defines parameters for ReplacePeerEntry.
type ReplacePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionsParams defines parameters for GetPeerSections.
type GetPeerSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreatePeerParams defines parameters for CreatePeer.
type CreatePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeletePeerParams defines parameters for DeletePeer.
type DeletePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionParams defines parameters for GetPeerSection.
type GetPeerSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindPeerParams defines parameters for GetAllBindPeer.
type GetAllBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindPeerParams defines parameters for CreateBindPeer.
type CreateBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindPeerParams defines parameters for DeleteBindPeer.
type DeleteBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindPeerParams defines parameters for GetBindPeer.
type GetBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindPeerParams defines parameters for ReplaceBindPeer.
type ReplaceBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetPeerParams defines parameters for GetAllLogTargetPeer.
type GetAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetPeerParams defines parameters for ReplaceAllLogTargetPeer.
type ReplaceAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetPeerParams defines parameters for DeleteLogTargetPeer.
type DeleteLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetPeerParams defines parameters for GetLogTargetPeer.
type GetLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetPeerParams defines parameters for CreateLogTargetPeer.
type CreateLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetPeerParams defines parameters for ReplaceLogTargetPeer.
type ReplaceLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerPeerParams defines parameters for GetAllServerPeer.
type GetAllServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerPeerParams defines parameters for CreateServerPeer.
type CreateServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerPeerParams defines parameters for DeleteServerPeer.
type DeleteServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerPeerParams defines parameters for GetServerPeer.
type GetServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerPeerParams defines parameters for ReplaceServerPeer.
type ReplaceServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTablesParams defines parameters for GetTables.
type GetTablesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceTableParams defines parameters for ReplaceTable.
type ReplaceTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramsParams defines parameters for GetPrograms.
type GetProgramsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateProgramParams defines parameters for CreateProgram.
type CreateProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteProgramParams defines parameters for DeleteProgram.
type DeleteProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramParams defines parameters for GetProgram.
type GetProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceProgramParams defines parameters for ReplaceProgram.
type ReplaceProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHAProxyConfigurationParams defines parameters for GetHAProxyConfiguration.
type GetHAProxyConfigurationParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostHAProxyConfigurationTextBody defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationTextBody = string

// PostHAProxyConfigurationParams defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationParams struct {
	// SkipVersion If set, no version check will be done and the pushed config will be enforced
	SkipVersion *bool `form:"skip_version,omitempty" json:"skip_version,omitempty"`

	// SkipReload If set, no reload will be initiated and runtime actions from X-Runtime-Actions will be applied
	SkipReload *bool `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// OnlyValidate If set, only validates configuration, without applying it
	OnlyValidate *bool `form:"only_validate,omitempty" json:"only_validate,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// XRuntimeActions List of Runtime API commands with parameters separated by ';'
	XRuntimeActions *string `json:"X-Runtime-Actions,omitempty"`
}

// GetResolversParams defines parameters for GetResolvers.
type GetResolversParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateResolverParams defines parameters for CreateResolver.
type CreateResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteResolverParams defines parameters for DeleteResolver.
type DeleteResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetResolverParams defines parameters for GetResolver.
type GetResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceResolverParams defines parameters for ReplaceResolver.
type ReplaceResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetRingsParams defines parameters for GetRings.
type GetRingsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateRingParams defines parameters for CreateRing.
type CreateRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteRingParams defines parameters for DeleteRing.
type DeleteRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetRingParams defines parameters for GetRing.
type GetRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceRingParams defines parameters for ReplaceRing.
type ReplaceRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllServerRingParams defines parameters for GetAllServerRing.
type GetAllServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerRingParams defines parameters for CreateServerRing.
type CreateServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerRingParams defines parameters for DeleteServerRing.
type DeleteServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerRingParams defines parameters for GetServerRing.
type GetServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerRingParams defines parameters for ReplaceServerRing.
type ReplaceServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTracesParams defines parameters for DeleteTraces.
type DeleteTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTracesParams defines parameters for GetTraces.
type GetTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateTracesParams defines parameters for CreateTraces.
type CreateTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTracesParams defines parameters for ReplaceTraces.
type ReplaceTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteTraceEntryParams defines parameters for DeleteTraceEntry.
type DeleteTraceEntryParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateTraceEntryParams defines parameters for CreateTraceEntry.
type CreateTraceEntryParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistsParams defines parameters for GetUserlists.
type GetUserlistsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateUserlistParams defines parameters for CreateUserlist.
type CreateUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteUserlistParams defines parameters for DeleteUserlist.
type DeleteUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistParams defines parameters for GetUserlist.
type GetUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceUserParams defines parameters for ReplaceUser.
type ReplaceUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetConfigurationVersionParams defines parameters for GetConfigurationVersion.
type GetConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetAllRuntimeMapFilesParams defines parameters for GetAllRuntimeMapFiles.
type GetAllRuntimeMapFilesParams struct {
	// IncludeUnmanaged If true, also show unmanaged map files loaded in haproxy
	IncludeUnmanaged *bool `form:"include_unmanaged,omitempty" json:"include_unmanaged,omitempty"`
}

// ClearRuntimeMapParams defines parameters for ClearRuntimeMap.
type ClearRuntimeMapParams struct {
	// ForceDelete If true, deletes file from disk
	ForceDelete *bool `form:"forceDelete,omitempty" json:"forceDelete,omitempty"`

	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddPayloadRuntimeMapParams defines parameters for AddPayloadRuntimeMap.
type AddPayloadRuntimeMapParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddMapEntryParams defines parameters for AddMapEntry.
type AddMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// DeleteRuntimeMapEntryParams defines parameters for DeleteRuntimeMapEntry.
type DeleteRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// ReplaceRuntimeMapEntryJSONBody defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryJSONBody struct {
	// Value Map value
	Value string `json:"value"`
}

// ReplaceRuntimeMapEntryParams defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// GetStickTableEntriesParams defines parameters for GetStickTableEntries.
type GetStickTableEntriesParams struct {
	// Filter A list of filters in format data.<type> <operator> <value> separated by comma
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Key Key which we want the entries for
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Count Max number of entries to be returned for pagination
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Offset which indicates how many items we skip in pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SetStickTableEntriesJSONBody defines parameters for SetStickTableEntries.
type SetStickTableEntriesJSONBody struct {
	// DataType One entry in stick table
	DataType StickTableEntry `json:"data_type"`
	Key      string          `json:"key"`
}

// GetSitesParams defines parameters for GetSites.
type GetSitesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSiteParams defines parameters for CreateSite.
type CreateSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteSiteParams defines parameters for DeleteSite.
type DeleteSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSiteParams defines parameters for GetSite.
type GetSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSiteParams defines parameters for ReplaceSite.
type ReplaceSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateSpoeMultipartBody defines parameters for CreateSpoe.
type CreateSpoeMultipartBody struct {
	// FileUpload The spoe file to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// GetAllSpoeScopeParams defines parameters for GetAllSpoeScope.
type GetAllSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeScopeParams defines parameters for CreateSpoeScope.
type CreateSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeScopeParams defines parameters for DeleteSpoeScope.
type DeleteSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeScopeParams defines parameters for GetSpoeScope.
type GetSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetAllSpoeAgentParams defines parameters for GetAllSpoeAgent.
type GetAllSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeAgentParams defines parameters for CreateSpoeAgent.
type CreateSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeAgentParams defines parameters for DeleteSpoeAgent.
type DeleteSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeAgentParams defines parameters for GetSpoeAgent.
type GetSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeAgentParams defines parameters for ReplaceSpoeAgent.
type ReplaceSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeGroupParams defines parameters for GetAllSpoeGroup.
type GetAllSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeGroupParams defines parameters for CreateSpoeGroup.
type CreateSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeGroupParams defines parameters for DeleteSpoeGroup.
type DeleteSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeGroupParams defines parameters for GetSpoeGroup.
type GetSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeGroupParams defines parameters for ReplaceSpoeGroup.
type ReplaceSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeMessageParams defines parameters for GetAllSpoeMessage.
type GetAllSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeMessageParams defines parameters for CreateSpoeMessage.
type CreateSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeMessageParams defines parameters for DeleteSpoeMessage.
type DeleteSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeMessageParams defines parameters for GetSpoeMessage.
type GetSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeMessageParams defines parameters for ReplaceSpoeMessage.
type ReplaceSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeTransactionParams defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParams struct {
	// Status Filter by transaction status
	Status *GetAllSpoeTransactionParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetAllSpoeTransactionParamsStatus defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParamsStatus string

// StartSpoeTransactionParams defines parameters for StartSpoeTransaction.
type StartSpoeTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitSpoeTransactionParams defines parameters for CommitSpoeTransaction.
type CommitSpoeTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSpoeConfigurationVersionParams defines parameters for GetSpoeConfigurationVersion.
type GetSpoeConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Type Object type to get stats for (one of frontend, backend, server)
	Type *GetStatsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Name Object name to get stats for
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Parent Object parent name to get stats for, in case the object is a server
	Parent *string `form:"parent,omitempty" json:"parent,omitempty"`
}

// GetStatsParamsType defines parameters for GetStats.
type GetStatsParamsType string

// CreateStorageGeneralFileMultipartBody defines parameters for CreateStorageGeneralFile.
type CreateStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileMultipartBody defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileParams defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageMapFileMultipartBody defines parameters for CreateStorageMapFile.
type CreateStorageMapFileMultipartBody struct {
	// FileUpload The map file contents
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageMapFileTextBody defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileTextBody = string

// ReplaceStorageMapFileParams defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageSSLCertificateMultipartBody defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateMultipartBody struct {
	// FileUpload The SSL certificate to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// CreateStorageSSLCertificateParams defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStorageSSLCertificateParams defines parameters for DeleteStorageSSLCertificate.
type DeleteStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStorageSSLCertificateTextBody defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateTextBody = string

// ReplaceStorageSSLCertificateParams defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// Status Filter by transaction status
	Status *GetTransactionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetTransactionsParamsStatus defines parameters for GetTransactions.
type GetTransactionsParamsStatus string

// StartTransactionParams defines parameters for StartTransaction.
type StartTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitTransactionParams defines parameters for CommitTransaction.
type CommitTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// PostClusterJSONRequestBody defines body for PostCluster for application/json ContentType.
type PostClusterJSONRequestBody = ClusterSettings

// EditClusterJSONRequestBody defines body for EditCluster for application/json ContentType.
type EditClusterJSONRequestBody = ClusterSettings

// CreateAWSRegionJSONRequestBody defines body for CreateAWSRegion for application/json ContentType.
type CreateAWSRegionJSONRequestBody = AwsRegion

// ReplaceAWSRegionJSONRequestBody defines body for ReplaceAWSRegion for application/json ContentType.
type ReplaceAWSRegionJSONRequestBody = AwsRegion

// CreateConsulJSONRequestBody defines body for CreateConsul for application/json ContentType.
type CreateConsulJSONRequestBody = Consul

// ReplaceConsulJSONRequestBody defines body for ReplaceConsul for application/json ContentType.
type ReplaceConsulJSONRequestBody = Consul

// CreateBackendJSONRequestBody defines body for CreateBackend for application/json ContentType.
type CreateBackendJSONRequestBody = Backend

// ReplaceBackendJSONRequestBody defines body for ReplaceBackend for application/json ContentType.
type ReplaceBackendJSONRequestBody = Backend

// ReplaceAllAclBackendJSONRequestBody defines body for ReplaceAllAclBackend for application/json ContentType.
type ReplaceAllAclBackendJSONRequestBody = Acls

// CreateAclBackendJSONRequestBody defines body for CreateAclBackend for application/json ContentType.
type CreateAclBackendJSONRequestBody = Acl

// ReplaceAclBackendJSONRequestBody defines body for ReplaceAclBackend for application/json ContentType.
type ReplaceAclBackendJSONRequestBody = Acl

// ReplaceAllFilterBackendJSONRequestBody defines body for ReplaceAllFilterBackend for application/json ContentType.
type ReplaceAllFilterBackendJSONRequestBody = Filters

// CreateFilterBackendJSONRequestBody defines body for CreateFilterBackend for application/json ContentType.
type CreateFilterBackendJSONRequestBody = Filter

// ReplaceFilterBackendJSONRequestBody defines body for ReplaceFilterBackend for application/json ContentType.
type ReplaceFilterBackendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleBackendJSONRequestBody defines body for CreateHTTPAfterResponseRuleBackend for application/json ContentType.
type CreateHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPCheckBackendJSONRequestBody defines body for ReplaceAllHTTPCheckBackend for application/json ContentType.
type ReplaceAllHTTPCheckBackendJSONRequestBody = HttpChecks

// CreateHTTPCheckBackendJSONRequestBody defines body for CreateHTTPCheckBackend for application/json ContentType.
type CreateHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceHTTPCheckBackendJSONRequestBody defines body for ReplaceHTTPCheckBackend for application/json ContentType.
type ReplaceHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleBackend for application/json ContentType.
type ReplaceAllHTTPErrorRuleBackendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleBackendJSONRequestBody defines body for CreateHTTPErrorRuleBackend for application/json ContentType.
type CreateHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceHTTPErrorRuleBackend for application/json ContentType.
type ReplaceHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleBackend for application/json ContentType.
type ReplaceAllHTTPRequestRuleBackendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleBackendJSONRequestBody defines body for CreateHTTPRequestRuleBackend for application/json ContentType.
type CreateHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceHTTPRequestRuleBackend for application/json ContentType.
type ReplaceHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPResponseRuleBackendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleBackendJSONRequestBody defines body for CreateHTTPResponseRuleBackend for application/json ContentType.
type CreateHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPResponseRuleBackend for application/json ContentType.
type ReplaceHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetBackendJSONRequestBody defines body for ReplaceAllLogTargetBackend for application/json ContentType.
type ReplaceAllLogTargetBackendJSONRequestBody = LogTargets

// CreateLogTargetBackendJSONRequestBody defines body for CreateLogTargetBackend for application/json ContentType.
type CreateLogTargetBackendJSONRequestBody = LogTarget

// ReplaceLogTargetBackendJSONRequestBody defines body for ReplaceLogTargetBackend for application/json ContentType.
type ReplaceLogTargetBackendJSONRequestBody = LogTarget

// ReplaceServerSwitchingRulesJSONRequestBody defines body for ReplaceServerSwitchingRules for application/json ContentType.
type ReplaceServerSwitchingRulesJSONRequestBody = ServerSwitchingRules

// CreateServerSwitchingRuleJSONRequestBody defines body for CreateServerSwitchingRule for application/json ContentType.
type CreateServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// ReplaceServerSwitchingRuleJSONRequestBody defines body for ReplaceServerSwitchingRule for application/json ContentType.
type ReplaceServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// CreateServerTemplateJSONRequestBody defines body for CreateServerTemplate for application/json ContentType.
type CreateServerTemplateJSONRequestBody = ServerTemplate

// ReplaceServerTemplateJSONRequestBody defines body for ReplaceServerTemplate for application/json ContentType.
type ReplaceServerTemplateJSONRequestBody = ServerTemplate

// CreateServerBackendJSONRequestBody defines body for CreateServerBackend for application/json ContentType.
type CreateServerBackendJSONRequestBody = Server

// ReplaceServerBackendJSONRequestBody defines body for ReplaceServerBackend for application/json ContentType.
type ReplaceServerBackendJSONRequestBody = Server

// ReplaceStickRulesJSONRequestBody defines body for ReplaceStickRules for application/json ContentType.
type ReplaceStickRulesJSONRequestBody = StickRules

// CreateStickRuleJSONRequestBody defines body for CreateStickRule for application/json ContentType.
type CreateStickRuleJSONRequestBody = StickRule

// ReplaceStickRuleJSONRequestBody defines body for ReplaceStickRule for application/json ContentType.
type ReplaceStickRuleJSONRequestBody = StickRule

// ReplaceAllTCPCheckBackendJSONRequestBody defines body for ReplaceAllTCPCheckBackend for application/json ContentType.
type ReplaceAllTCPCheckBackendJSONRequestBody = TcpChecks

// CreateTCPCheckBackendJSONRequestBody defines body for CreateTCPCheckBackend for application/json ContentType.
type CreateTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceTCPCheckBackendJSONRequestBody defines body for ReplaceTCPCheckBackend for application/json ContentType.
type ReplaceTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceAllTCPRequestRuleBackendJSONRequestBody defines body for ReplaceAllTCPRequestRuleBackend for application/json ContentType.
type ReplaceAllTCPRequestRuleBackendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleBackendJSONRequestBody defines body for CreateTCPRequestRuleBackend for application/json ContentType.
type CreateTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleBackendJSONRequestBody defines body for ReplaceTCPRequestRuleBackend for application/json ContentType.
type ReplaceTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceAllTCPResponseRuleBackendJSONRequestBody defines body for ReplaceAllTCPResponseRuleBackend for application/json ContentType.
type ReplaceAllTCPResponseRuleBackendJSONRequestBody = TcpResponseRules

// CreateTCPResponseRuleBackendJSONRequestBody defines body for CreateTCPResponseRuleBackend for application/json ContentType.
type CreateTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// ReplaceTCPResponseRuleBackendJSONRequestBody defines body for ReplaceTCPResponseRuleBackend for application/json ContentType.
type ReplaceTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// CreateCacheJSONRequestBody defines body for CreateCache for application/json ContentType.
type CreateCacheJSONRequestBody = Cache

// ReplaceCacheJSONRequestBody defines body for ReplaceCache for application/json ContentType.
type ReplaceCacheJSONRequestBody = Cache

// CreateCrtLoadJSONRequestBody defines body for CreateCrtLoad for application/json ContentType.
type CreateCrtLoadJSONRequestBody = CrtLoad

// ReplaceCrtLoadJSONRequestBody defines body for ReplaceCrtLoad for application/json ContentType.
type ReplaceCrtLoadJSONRequestBody = CrtLoad

// CreateCrtStoreJSONRequestBody defines body for CreateCrtStore for application/json ContentType.
type CreateCrtStoreJSONRequestBody = CrtStore

// EditCrtStoreJSONRequestBody defines body for EditCrtStore for application/json ContentType.
type EditCrtStoreJSONRequestBody = CrtStore

// AddDefaultsSectionJSONRequestBody defines body for AddDefaultsSection for application/json ContentType.
type AddDefaultsSectionJSONRequestBody = Defaults

// CreateDefaultsSectionJSONRequestBody defines body for CreateDefaultsSection for application/json ContentType.
type CreateDefaultsSectionJSONRequestBody = Defaults

// ReplaceDefaultsSectionJSONRequestBody defines body for ReplaceDefaultsSection for application/json ContentType.
type ReplaceDefaultsSectionJSONRequestBody = Defaults

// ReplaceAllHTTPCheckDefaultsJSONRequestBody defines body for ReplaceAllHTTPCheckDefaults for application/json ContentType.
type ReplaceAllHTTPCheckDefaultsJSONRequestBody = HttpChecks

// CreateHTTPCheckDefaultsJSONRequestBody defines body for CreateHTTPCheckDefaults for application/json ContentType.
type CreateHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceHTTPCheckDefaultsJSONRequestBody defines body for ReplaceHTTPCheckDefaults for application/json ContentType.
type ReplaceHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleDefaultsJSONRequestBody defines body for CreateHTTPErrorRuleDefaults for application/json ContentType.
type CreateHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceAllLogTargetDefaultsJSONRequestBody defines body for ReplaceAllLogTargetDefaults for application/json ContentType.
type ReplaceAllLogTargetDefaultsJSONRequestBody = LogTargets

// CreateLogTargetDefaultsJSONRequestBody defines body for CreateLogTargetDefaults for application/json ContentType.
type CreateLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceLogTargetDefaultsJSONRequestBody defines body for ReplaceLogTargetDefaults for application/json ContentType.
type ReplaceLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceAllQUICInitialRuleDefaultsJSONRequestBody defines body for ReplaceAllQUICInitialRuleDefaults for application/json ContentType.
type ReplaceAllQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRules

// CreateQUICInitialRuleDefaultsJSONRequestBody defines body for CreateQUICInitialRuleDefaults for application/json ContentType.
type CreateQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRule

// ReplaceQUICInitialRuleDefaultsJSONRequestBody defines body for ReplaceQUICInitialRuleDefaults for application/json ContentType.
type ReplaceQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRule

// ReplaceAllTCPCheckDefaultsJSONRequestBody defines body for ReplaceAllTCPCheckDefaults for application/json ContentType.
type ReplaceAllTCPCheckDefaultsJSONRequestBody = TcpChecks

// CreateTCPCheckDefaultsJSONRequestBody defines body for CreateTCPCheckDefaults for application/json ContentType.
type CreateTCPCheckDefaultsJSONRequestBody = TcpCheck

// ReplaceTCPCheckDefaultsJSONRequestBody defines body for ReplaceTCPCheckDefaults for application/json ContentType.
type ReplaceTCPCheckDefaultsJSONRequestBody = TcpCheck

// CreateFCGIAppJSONRequestBody defines body for CreateFCGIApp for application/json ContentType.
type CreateFCGIAppJSONRequestBody = FCGIApp

// ReplaceFCGIAppJSONRequestBody defines body for ReplaceFCGIApp for application/json ContentType.
type ReplaceFCGIAppJSONRequestBody = FCGIApp

// ReplaceAllAclFCGIAppJSONRequestBody defines body for ReplaceAllAclFCGIApp for application/json ContentType.
type ReplaceAllAclFCGIAppJSONRequestBody = Acls

// CreateAclFCGIAppJSONRequestBody defines body for CreateAclFCGIApp for application/json ContentType.
type CreateAclFCGIAppJSONRequestBody = Acl

// ReplaceAclFCGIAppJSONRequestBody defines body for ReplaceAclFCGIApp for application/json ContentType.
type ReplaceAclFCGIAppJSONRequestBody = Acl

// CreateFrontendJSONRequestBody defines body for CreateFrontend for application/json ContentType.
type CreateFrontendJSONRequestBody = Frontend

// ReplaceFrontendJSONRequestBody defines body for ReplaceFrontend for application/json ContentType.
type ReplaceFrontendJSONRequestBody = Frontend

// ReplaceAllAclFrontendJSONRequestBody defines body for ReplaceAllAclFrontend for application/json ContentType.
type ReplaceAllAclFrontendJSONRequestBody = Acls

// CreateAclFrontendJSONRequestBody defines body for CreateAclFrontend for application/json ContentType.
type CreateAclFrontendJSONRequestBody = Acl

// ReplaceAclFrontendJSONRequestBody defines body for ReplaceAclFrontend for application/json ContentType.
type ReplaceAclFrontendJSONRequestBody = Acl

// ReplaceBackendSwitchingRulesJSONRequestBody defines body for ReplaceBackendSwitchingRules for application/json ContentType.
type ReplaceBackendSwitchingRulesJSONRequestBody = BackendSwitchingRules

// CreateBackendSwitchingRuleJSONRequestBody defines body for CreateBackendSwitchingRule for application/json ContentType.
type CreateBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// ReplaceBackendSwitchingRuleJSONRequestBody defines body for ReplaceBackendSwitchingRule for application/json ContentType.
type ReplaceBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// CreateBindFrontendJSONRequestBody defines body for CreateBindFrontend for application/json ContentType.
type CreateBindFrontendJSONRequestBody = Bind

// ReplaceBindFrontendJSONRequestBody defines body for ReplaceBindFrontend for application/json ContentType.
type ReplaceBindFrontendJSONRequestBody = Bind

// ReplaceDeclareCapturesJSONRequestBody defines body for ReplaceDeclareCaptures for application/json ContentType.
type ReplaceDeclareCapturesJSONRequestBody = Captures

// CreateDeclareCaptureJSONRequestBody defines body for CreateDeclareCapture for application/json ContentType.
type CreateDeclareCaptureJSONRequestBody = Capture

// ReplaceDeclareCaptureJSONRequestBody defines body for ReplaceDeclareCapture for application/json ContentType.
type ReplaceDeclareCaptureJSONRequestBody = Capture

// ReplaceAllFilterFrontendJSONRequestBody defines body for ReplaceAllFilterFrontend for application/json ContentType.
type ReplaceAllFilterFrontendJSONRequestBody = Filters

// CreateFilterFrontendJSONRequestBody defines body for CreateFilterFrontend for application/json ContentType.
type CreateFilterFrontendJSONRequestBody = Filter

// ReplaceFilterFrontendJSONRequestBody defines body for ReplaceFilterFrontend for application/json ContentType.
type ReplaceFilterFrontendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleFrontendJSONRequestBody defines body for CreateHTTPAfterResponseRuleFrontend for application/json ContentType.
type CreateHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceAllHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleFrontendJSONRequestBody defines body for CreateHTTPErrorRuleFrontend for application/json ContentType.
type CreateHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceAllHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleFrontendJSONRequestBody defines body for CreateHTTPRequestRuleFrontend for application/json ContentType.
type CreateHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleFrontendJSONRequestBody defines body for CreateHTTPResponseRuleFrontend for application/json ContentType.
type CreateHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetFrontendJSONRequestBody defines body for ReplaceAllLogTargetFrontend for application/json ContentType.
type ReplaceAllLogTargetFrontendJSONRequestBody = LogTargets

// CreateLogTargetFrontendJSONRequestBody defines body for CreateLogTargetFrontend for application/json ContentType.
type CreateLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceLogTargetFrontendJSONRequestBody defines body for ReplaceLogTargetFrontend for application/json ContentType.
type ReplaceLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceAllQUICInitialRuleFrontendJSONRequestBody defines body for ReplaceAllQUICInitialRuleFrontend for application/json ContentType.
type ReplaceAllQUICInitialRuleFrontendJSONRequestBody = QUICInitialRules

// CreateQUICInitialRuleFrontendJSONRequestBody defines body for CreateQUICInitialRuleFrontend for application/json ContentType.
type CreateQUICInitialRuleFrontendJSONRequestBody = QUICInitialRule

// ReplaceQUICInitialRuleFrontendJSONRequestBody defines body for ReplaceQUICInitialRuleFrontend for application/json ContentType.
type ReplaceQUICInitialRuleFrontendJSONRequestBody = QUICInitialRule

// ReplaceAllTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllTCPRequestRuleFrontend for application/json ContentType.
type ReplaceAllTCPRequestRuleFrontendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleFrontendJSONRequestBody defines body for CreateTCPRequestRuleFrontend for application/json ContentType.
type CreateTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceTCPRequestRuleFrontend for application/json ContentType.
type ReplaceTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceGlobalJSONRequestBody defines body for ReplaceGlobal for application/json ContentType.
type ReplaceGlobalJSONRequestBody = Global

// ReplaceAllLogTargetGlobalJSONRequestBody defines body for ReplaceAllLogTargetGlobal for application/json ContentType.
type ReplaceAllLogTargetGlobalJSONRequestBody = LogTargets

// CreateLogTargetGlobalJSONRequestBody defines body for CreateLogTargetGlobal for application/json ContentType.
type CreateLogTargetGlobalJSONRequestBody = LogTarget

// ReplaceLogTargetGlobalJSONRequestBody defines body for ReplaceLogTargetGlobal for application/json ContentType.
type ReplaceLogTargetGlobalJSONRequestBody = LogTarget

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = Group

// ReplaceGroupJSONRequestBody defines body for ReplaceGroup for application/json ContentType.
type ReplaceGroupJSONRequestBody = Group

// CreateHTTPErrorsSectionJSONRequestBody defines body for CreateHTTPErrorsSection for application/json ContentType.
type CreateHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// ReplaceHTTPErrorsSectionJSONRequestBody defines body for ReplaceHTTPErrorsSection for application/json ContentType.
type ReplaceHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// CreateLogForwardJSONRequestBody defines body for CreateLogForward for application/json ContentType.
type CreateLogForwardJSONRequestBody = LogForward

// ReplaceLogForwardJSONRequestBody defines body for ReplaceLogForward for application/json ContentType.
type ReplaceLogForwardJSONRequestBody = LogForward

// CreateBindLogForwardJSONRequestBody defines body for CreateBindLogForward for application/json ContentType.
type CreateBindLogForwardJSONRequestBody = Bind

// ReplaceBindLogForwardJSONRequestBody defines body for ReplaceBindLogForward for application/json ContentType.
type ReplaceBindLogForwardJSONRequestBody = Bind

// CreateDgramBindJSONRequestBody defines body for CreateDgramBind for application/json ContentType.
type CreateDgramBindJSONRequestBody = DgramBind

// ReplaceDgramBindJSONRequestBody defines body for ReplaceDgramBind for application/json ContentType.
type ReplaceDgramBindJSONRequestBody = DgramBind

// ReplaceAllLogTargetLogForwardJSONRequestBody defines body for ReplaceAllLogTargetLogForward for application/json ContentType.
type ReplaceAllLogTargetLogForwardJSONRequestBody = LogTargets

// CreateLogTargetLogForwardJSONRequestBody defines body for CreateLogTargetLogForward for application/json ContentType.
type CreateLogTargetLogForwardJSONRequestBody = LogTarget

// ReplaceLogTargetLogForwardJSONRequestBody defines body for ReplaceLogTargetLogForward for application/json ContentType.
type ReplaceLogTargetLogForwardJSONRequestBody = LogTarget

// CreateLogProfileJSONRequestBody defines body for CreateLogProfile for application/json ContentType.
type CreateLogProfileJSONRequestBody = LogProfile

// EditLogProfileJSONRequestBody defines body for EditLogProfile for application/json ContentType.
type EditLogProfileJSONRequestBody = LogProfile

// CreateMailerEntryJSONRequestBody defines body for CreateMailerEntry for application/json ContentType.
type CreateMailerEntryJSONRequestBody = MailerEntry

// ReplaceMailerEntryJSONRequestBody defines body for ReplaceMailerEntry for application/json ContentType.
type ReplaceMailerEntryJSONRequestBody = MailerEntry

// CreateMailersSectionJSONRequestBody defines body for CreateMailersSection for application/json ContentType.
type CreateMailersSectionJSONRequestBody = MailersSection

// EditMailersSectionJSONRequestBody defines body for EditMailersSection for application/json ContentType.
type EditMailersSectionJSONRequestBody = MailersSection

// CreateNameserverJSONRequestBody defines body for CreateNameserver for application/json ContentType.
type CreateNameserverJSONRequestBody = Nameserver

// ReplaceNameserverJSONRequestBody defines body for ReplaceNameserver for application/json ContentType.
type ReplaceNameserverJSONRequestBody = Nameserver

// CreatePeerEntryJSONRequestBody defines body for CreatePeerEntry for application/json ContentType.
type CreatePeerEntryJSONRequestBody = PeerEntry

// ReplacePeerEntryJSONRequestBody defines body for ReplacePeerEntry for application/json ContentType.
type ReplacePeerEntryJSONRequestBody = PeerEntry

// CreatePeerJSONRequestBody defines body for CreatePeer for application/json ContentType.
type CreatePeerJSONRequestBody = PeerSection

// CreateBindPeerJSONRequestBody defines body for CreateBindPeer for application/json ContentType.
type CreateBindPeerJSONRequestBody = Bind

// ReplaceBindPeerJSONRequestBody defines body for ReplaceBindPeer for application/json ContentType.
type ReplaceBindPeerJSONRequestBody = Bind

// ReplaceAllLogTargetPeerJSONRequestBody defines body for ReplaceAllLogTargetPeer for application/json ContentType.
type ReplaceAllLogTargetPeerJSONRequestBody = LogTargets

// CreateLogTargetPeerJSONRequestBody defines body for CreateLogTargetPeer for application/json ContentType.
type CreateLogTargetPeerJSONRequestBody = LogTarget

// ReplaceLogTargetPeerJSONRequestBody defines body for ReplaceLogTargetPeer for application/json ContentType.
type ReplaceLogTargetPeerJSONRequestBody = LogTarget

// CreateServerPeerJSONRequestBody defines body for CreateServerPeer for application/json ContentType.
type CreateServerPeerJSONRequestBody = Server

// ReplaceServerPeerJSONRequestBody defines body for ReplaceServerPeer for application/json ContentType.
type ReplaceServerPeerJSONRequestBody = Server

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = Table

// ReplaceTableJSONRequestBody defines body for ReplaceTable for application/json ContentType.
type ReplaceTableJSONRequestBody = Table

// CreateProgramJSONRequestBody defines body for CreateProgram for application/json ContentType.
type CreateProgramJSONRequestBody = Program

// ReplaceProgramJSONRequestBody defines body for ReplaceProgram for application/json ContentType.
type ReplaceProgramJSONRequestBody = Program

// PostHAProxyConfigurationTextRequestBody defines body for PostHAProxyConfiguration for text/plain ContentType.
type PostHAProxyConfigurationTextRequestBody = PostHAProxyConfigurationTextBody

// CreateResolverJSONRequestBody defines body for CreateResolver for application/json ContentType.
type CreateResolverJSONRequestBody = Resolver

// ReplaceResolverJSONRequestBody defines body for ReplaceResolver for application/json ContentType.
type ReplaceResolverJSONRequestBody = Resolver

// CreateRingJSONRequestBody defines body for CreateRing for application/json ContentType.
type CreateRingJSONRequestBody = Ring

// ReplaceRingJSONRequestBody defines body for ReplaceRing for application/json ContentType.
type ReplaceRingJSONRequestBody = Ring

// CreateServerRingJSONRequestBody defines body for CreateServerRing for application/json ContentType.
type CreateServerRingJSONRequestBody = Server

// ReplaceServerRingJSONRequestBody defines body for ReplaceServerRing for application/json ContentType.
type ReplaceServerRingJSONRequestBody = Server

// CreateTracesJSONRequestBody defines body for CreateTraces for application/json ContentType.
type CreateTracesJSONRequestBody = Traces

// ReplaceTracesJSONRequestBody defines body for ReplaceTraces for application/json ContentType.
type ReplaceTracesJSONRequestBody = Traces

// DeleteTraceEntryJSONRequestBody defines body for DeleteTraceEntry for application/json ContentType.
type DeleteTraceEntryJSONRequestBody = TraceEntry

// CreateTraceEntryJSONRequestBody defines body for CreateTraceEntry for application/json ContentType.
type CreateTraceEntryJSONRequestBody = TraceEntry

// CreateUserlistJSONRequestBody defines body for CreateUserlist for application/json ContentType.
type CreateUserlistJSONRequestBody = Userlist

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = User

// ReplaceUserJSONRequestBody defines body for ReplaceUser for application/json ContentType.
type ReplaceUserJSONRequestBody = User

// PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody defines body for PostServicesHaproxyRuntimeAclsParentNameEntries for application/json ContentType.
type PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody = AclFileEntry

// AddPayloadRuntimeACLJSONRequestBody defines body for AddPayloadRuntimeACL for application/json ContentType.
type AddPayloadRuntimeACLJSONRequestBody = AclFilesEntries

// AddRuntimeServerJSONRequestBody defines body for AddRuntimeServer for application/json ContentType.
type AddRuntimeServerJSONRequestBody = RuntimeAddServer

// ReplaceRuntimeServerJSONRequestBody defines body for ReplaceRuntimeServer for application/json ContentType.
type ReplaceRuntimeServerJSONRequestBody = RuntimeServer

// AddPayloadRuntimeMapJSONRequestBody defines body for AddPayloadRuntimeMap for application/json ContentType.
type AddPayloadRuntimeMapJSONRequestBody = MapEntries

// AddMapEntryJSONRequestBody defines body for AddMapEntry for application/json ContentType.
type AddMapEntryJSONRequestBody = MapEntry

// ReplaceRuntimeMapEntryJSONRequestBody defines body for ReplaceRuntimeMapEntry for application/json ContentType.
type ReplaceRuntimeMapEntryJSONRequestBody ReplaceRuntimeMapEntryJSONBody

// SetStickTableEntriesJSONRequestBody defines body for SetStickTableEntries for application/json ContentType.
type SetStickTableEntriesJSONRequestBody SetStickTableEntriesJSONBody

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = Site

// ReplaceSiteJSONRequestBody defines body for ReplaceSite for application/json ContentType.
type ReplaceSiteJSONRequestBody = Site

// CreateSpoeMultipartRequestBody defines body for CreateSpoe for multipart/form-data ContentType.
type CreateSpoeMultipartRequestBody CreateSpoeMultipartBody

// CreateSpoeScopeJSONRequestBody defines body for CreateSpoeScope for application/json ContentType.
type CreateSpoeScopeJSONRequestBody = SpoeScope

// CreateSpoeAgentJSONRequestBody defines body for CreateSpoeAgent for application/json ContentType.
type CreateSpoeAgentJSONRequestBody = SpoeAgent

// ReplaceSpoeAgentJSONRequestBody defines body for ReplaceSpoeAgent for application/json ContentType.
type ReplaceSpoeAgentJSONRequestBody = SpoeAgent

// CreateSpoeGroupJSONRequestBody defines body for CreateSpoeGroup for application/json ContentType.
type CreateSpoeGroupJSONRequestBody = SpoeGroup

// ReplaceSpoeGroupJSONRequestBody defines body for ReplaceSpoeGroup for application/json ContentType.
type ReplaceSpoeGroupJSONRequestBody = SpoeGroup

// CreateSpoeMessageJSONRequestBody defines body for CreateSpoeMessage for application/json ContentType.
type CreateSpoeMessageJSONRequestBody = SpoeMessage

// ReplaceSpoeMessageJSONRequestBody defines body for ReplaceSpoeMessage for application/json ContentType.
type ReplaceSpoeMessageJSONRequestBody = SpoeMessage

// CreateStorageGeneralFileMultipartRequestBody defines body for CreateStorageGeneralFile for multipart/form-data ContentType.
type CreateStorageGeneralFileMultipartRequestBody CreateStorageGeneralFileMultipartBody

// ReplaceStorageGeneralFileMultipartRequestBody defines body for ReplaceStorageGeneralFile for multipart/form-data ContentType.
type ReplaceStorageGeneralFileMultipartRequestBody ReplaceStorageGeneralFileMultipartBody

// CreateStorageMapFileMultipartRequestBody defines body for CreateStorageMapFile for multipart/form-data ContentType.
type CreateStorageMapFileMultipartRequestBody CreateStorageMapFileMultipartBody

// ReplaceStorageMapFileTextRequestBody defines body for ReplaceStorageMapFile for text/plain ContentType.
type ReplaceStorageMapFileTextRequestBody = ReplaceStorageMapFileTextBody

// CreateStorageSSLCertificateMultipartRequestBody defines body for CreateStorageSSLCertificate for multipart/form-data ContentType.
type CreateStorageSSLCertificateMultipartRequestBody CreateStorageSSLCertificateMultipartBody

// ReplaceStorageSSLCertificateTextRequestBody defines body for ReplaceStorageSSLCertificate for text/plain ContentType.
type ReplaceStorageSSLCertificateTextRequestBody = ReplaceStorageSSLCertificateTextBody

// Getter for additional properties for Error. Returns the specified
// element and whether it was found
func (a Error) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Error
func (a *Error) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a *Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["code"], err = json.Marshal(a.Code)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'code': %w", err)
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAPIEndpoints request
	GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClusterWithBody request with any body
	PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditClusterWithBody request with any body
	EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCertificateRefresh request
	InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfo request
	GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegions request
	GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAWSRegionWithBody request with any body
	CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAWSRegion request
	DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegion request
	GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAWSRegionWithBody request with any body
	ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsuls request
	GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConsulWithBody request with any body
	CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConsul request
	DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsul request
	GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceConsulWithBody request with any body
	ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesEndpoints request
	GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyEndpoints request
	GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationEndpoints request
	GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackends request
	GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendWithBody request with any body
	CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackend request
	DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackend request
	GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendWithBody request with any body
	ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclBackend request
	GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclBackendWithBody request with any body
	ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclBackend request
	DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclBackend request
	GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclBackendWithBody request with any body
	CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclBackendWithBody request with any body
	ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterBackend request
	GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterBackendWithBody request with any body
	ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterBackend request
	DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterBackend request
	GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterBackendWithBody request with any body
	CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterBackendWithBody request with any body
	ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleBackend request
	GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleBackend request
	DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleBackend request
	GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleBackendWithBody request with any body
	CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckBackend request
	GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckBackendWithBody request with any body
	ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckBackend request
	DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckBackend request
	GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckBackendWithBody request with any body
	CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckBackendWithBody request with any body
	ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleBackend request
	GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleBackendWithBody request with any body
	ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleBackend request
	DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleBackend request
	GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleBackendWithBody request with any body
	CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleBackendWithBody request with any body
	ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleBackend request
	GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleBackendWithBody request with any body
	ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleBackend request
	DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleBackend request
	GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleBackendWithBody request with any body
	CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleBackendWithBody request with any body
	ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleBackend request
	GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleBackend request
	DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleBackend request
	GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleBackendWithBody request with any body
	CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleBackendWithBody request with any body
	ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetBackend request
	GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetBackendWithBody request with any body
	ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetBackend request
	DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetBackend request
	GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetBackendWithBody request with any body
	CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetBackendWithBody request with any body
	ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRules request
	GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRulesWithBody request with any body
	ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerSwitchingRule request
	DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRule request
	GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerSwitchingRuleWithBody request with any body
	CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRuleWithBody request with any body
	ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplates request
	GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerTemplateWithBody request with any body
	CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerTemplate request
	DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplate request
	GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerTemplateWithBody request with any body
	ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerBackend request
	GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerBackendWithBody request with any body
	CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerBackend request
	DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerBackend request
	GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerBackendWithBody request with any body
	ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRules request
	GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRulesWithBody request with any body
	ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStickRule request
	DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRule request
	GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStickRuleWithBody request with any body
	CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRuleWithBody request with any body
	ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckBackend request
	GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckBackendWithBody request with any body
	ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckBackend request
	DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckBackend request
	GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckBackendWithBody request with any body
	CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckBackendWithBody request with any body
	ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleBackend request
	GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleBackendWithBody request with any body
	ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleBackend request
	DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleBackend request
	GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleBackendWithBody request with any body
	CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleBackendWithBody request with any body
	ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPResponseRuleBackend request
	GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPResponseRuleBackendWithBody request with any body
	ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPResponseRuleBackend request
	DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPResponseRuleBackend request
	GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPResponseRuleBackendWithBody request with any body
	CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPResponseRuleBackendWithBody request with any body
	ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaches request
	GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCacheWithBody request with any body
	CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCache request
	DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCache request
	GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCacheWithBody request with any body
	ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoads request
	GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtLoadWithBody request with any body
	CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtLoad request
	DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoad request
	GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCrtLoadWithBody request with any body
	ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStores request
	GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtStoreWithBody request with any body
	CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtStore request
	DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStore request
	GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCrtStoreWithBody request with any body
	EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSections request
	GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDefaultsSectionWithBody request with any body
	AddDefaultsSectionWithBody(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDefaultsSection(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDefaultsSectionWithBody request with any body
	CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDefaultsSection request
	DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSection request
	GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDefaultsSectionWithBody request with any body
	ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckDefaults request
	GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckDefaultsWithBody request with any body
	ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckDefaults request
	DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckDefaults request
	GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckDefaultsWithBody request with any body
	CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckDefaultsWithBody request with any body
	ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleDefaults request
	GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleDefaults request
	DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleDefaults request
	GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleDefaultsWithBody request with any body
	CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetDefaults request
	GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetDefaultsWithBody request with any body
	ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetDefaults request
	DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetDefaults request
	GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetDefaultsWithBody request with any body
	CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetDefaultsWithBody request with any body
	ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllQUICInitialRuleDefaults request
	GetAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllQUICInitialRuleDefaultsWithBody request with any body
	ReplaceAllQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQUICInitialRuleDefaults request
	DeleteQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQUICInitialRuleDefaults request
	GetQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQUICInitialRuleDefaultsWithBody request with any body
	CreateQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceQUICInitialRuleDefaultsWithBody request with any body
	ReplaceQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckDefaults request
	GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckDefaultsWithBody request with any body
	ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckDefaults request
	DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckDefaults request
	GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckDefaultsWithBody request with any body
	CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckDefaultsWithBody request with any body
	ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApps request
	GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFCGIAppWithBody request with any body
	CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFCGIApp request
	DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApp request
	GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFCGIAppWithBody request with any body
	ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFCGIApp request
	GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFCGIAppWithBody request with any body
	ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFCGIApp request
	DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFCGIApp request
	GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFCGIAppWithBody request with any body
	CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFCGIAppWithBody request with any body
	ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontends request
	GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFrontendWithBody request with any body
	CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFrontend request
	DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontend request
	GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFrontendWithBody request with any body
	ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFrontend request
	GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFrontendWithBody request with any body
	ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFrontend request
	DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFrontend request
	GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFrontendWithBody request with any body
	CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFrontendWithBody request with any body
	ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRules request
	GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRulesWithBody request with any body
	ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackendSwitchingRule request
	DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRule request
	GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendSwitchingRuleWithBody request with any body
	CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRuleWithBody request with any body
	ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindFrontend request
	GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindFrontendWithBody request with any body
	CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindFrontend request
	DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindFrontend request
	GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindFrontendWithBody request with any body
	ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCaptures request
	GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCapturesWithBody request with any body
	ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeclareCapture request
	DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCapture request
	GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeclareCaptureWithBody request with any body
	CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCaptureWithBody request with any body
	ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterFrontend request
	GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterFrontendWithBody request with any body
	ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterFrontend request
	DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterFrontend request
	GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterFrontendWithBody request with any body
	CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterFrontendWithBody request with any body
	ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleFrontend request
	GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleFrontend request
	DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleFrontend request
	GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleFrontendWithBody request with any body
	CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleFrontend request
	GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBody request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleFrontend request
	DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleFrontend request
	GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleFrontendWithBody request with any body
	CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleFrontendWithBody request with any body
	ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleFrontend request
	GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBody request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleFrontend request
	DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleFrontend request
	GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleFrontendWithBody request with any body
	CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleFrontendWithBody request with any body
	ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleFrontend request
	GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleFrontend request
	DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleFrontend request
	GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleFrontendWithBody request with any body
	CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleFrontendWithBody request with any body
	ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetFrontend request
	GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetFrontendWithBody request with any body
	ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetFrontend request
	DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetFrontend request
	GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetFrontendWithBody request with any body
	CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetFrontendWithBody request with any body
	ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllQUICInitialRuleFrontend request
	GetAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllQUICInitialRuleFrontendWithBody request with any body
	ReplaceAllQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQUICInitialRuleFrontend request
	DeleteQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQUICInitialRuleFrontend request
	GetQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQUICInitialRuleFrontendWithBody request with any body
	CreateQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceQUICInitialRuleFrontendWithBody request with any body
	ReplaceQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleFrontend request
	GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleFrontendWithBody request with any body
	ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleFrontend request
	DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleFrontend request
	GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleFrontendWithBody request with any body
	CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleFrontendWithBody request with any body
	ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGlobalWithBody request with any body
	ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetGlobal request
	GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetGlobalWithBody request with any body
	ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetGlobal request
	DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetGlobal request
	GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetGlobalWithBody request with any body
	CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetGlobalWithBody request with any body
	ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGroupWithBody request with any body
	ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSections request
	GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorsSectionWithBody request with any body
	CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorsSection request
	DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSection request
	GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorsSectionWithBody request with any body
	ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForwards request
	GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogForwardWithBody request with any body
	CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogForward request
	DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForward request
	GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogForwardWithBody request with any body
	ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindLogForward request
	GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindLogForwardWithBody request with any body
	CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindLogForward request
	DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindLogForward request
	GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindLogForwardWithBody request with any body
	ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBinds request
	GetDgramBinds(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDgramBindWithBody request with any body
	CreateDgramBindWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDgramBind(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDgramBind request
	DeleteDgramBind(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBind request
	GetDgramBind(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDgramBindWithBody request with any body
	ReplaceDgramBindWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDgramBind(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetLogForward request
	GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetLogForwardWithBody request with any body
	ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetLogForward request
	DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetLogForward request
	GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetLogForwardWithBody request with any body
	CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetLogForwardWithBody request with any body
	ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogProfiles request
	GetLogProfiles(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogProfileWithBody request with any body
	CreateLogProfileWithBody(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogProfile(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogProfile request
	DeleteLogProfile(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogProfile request
	GetLogProfile(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditLogProfileWithBody request with any body
	EditLogProfileWithBody(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditLogProfile(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntries request
	GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailerEntryWithBody request with any body
	CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailerEntry request
	DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntry request
	GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceMailerEntryWithBody request with any body
	ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSections request
	GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailersSectionWithBody request with any body
	CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailersSection request
	DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSection request
	GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMailersSectionWithBody request with any body
	EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameservers request
	GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNameserverWithBody request with any body
	CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNameserver request
	DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameserver request
	GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceNameserverWithBody request with any body
	ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntries request
	GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerEntryWithBody request with any body
	CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeerEntry request
	DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntry request
	GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplacePeerEntryWithBody request with any body
	ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSections request
	GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerWithBody request with any body
	CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeer request
	DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSection request
	GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindPeer request
	GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindPeerWithBody request with any body
	CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindPeer request
	DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindPeer request
	GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindPeerWithBody request with any body
	ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetPeer request
	GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetPeerWithBody request with any body
	ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetPeer request
	DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetPeer request
	GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetPeerWithBody request with any body
	CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetPeerWithBody request with any body
	ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerPeer request
	GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerPeerWithBody request with any body
	CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerPeer request
	DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerPeer request
	GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerPeerWithBody request with any body
	ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTableWithBody request with any body
	ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrograms request
	GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramWithBody request with any body
	CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceProgramWithBody request with any body
	ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHAProxyConfiguration request
	GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHAProxyConfigurationWithBody request with any body
	PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolvers request
	GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResolverWithBody request with any body
	CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResolver request
	DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolver request
	GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceResolverWithBody request with any body
	ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRings request
	GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRingWithBody request with any body
	CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRing request
	DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRing request
	GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRingWithBody request with any body
	ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerRing request
	GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerRingWithBody request with any body
	CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerRing request
	DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerRing request
	GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerRingWithBody request with any body
	ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTraces request
	DeleteTraces(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTraces request
	GetTraces(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTracesWithBody request with any body
	CreateTracesWithBody(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTraces(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTracesWithBody request with any body
	ReplaceTracesWithBody(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTraces(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTraceEntryWithBody request with any body
	DeleteTraceEntryWithBody(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTraceEntry(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTraceEntryWithBody request with any body
	CreateTraceEntryWithBody(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTraceEntry(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlists request
	GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserlistWithBody request with any body
	CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserlist request
	DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlist request
	GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceUserWithBody request with any body
	ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationVersion request
	GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReloads request
	GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReload request
	GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeEndpoints request
	GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAcls request
	GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsId request
	GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntries request
	GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeACLWithBody request with any body
	AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesId request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesId request
	GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeServer request
	GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRuntimeServerWithBody request with any body
	AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeServer request
	DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeServer request
	GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeServerWithBody request with any body
	ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyProcessInfo request
	GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeMapFiles request
	GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearRuntimeMap request
	ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneRuntimeMap request
	GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeMapWithBody request with any body
	AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRuntimeMap request
	ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMapEntryWithBody request with any body
	AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeMapEntry request
	DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeMapEntry request
	GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeMapEntryWithBody request with any body
	ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTables request
	GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTable request
	GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTableEntries request
	GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetStickTableEntriesWithBody request with any body
	SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSites request
	GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSite request
	DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSiteWithBody request with any body
	ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeEndpoints request
	GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeFiles request
	GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeWithBody request with any body
	CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeFile request
	DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneSpoeFile request
	GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeScope request
	GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeScopeWithBody request with any body
	CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeScope request
	DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeScope request
	GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeAgent request
	GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeAgentWithBody request with any body
	CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeAgent request
	DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeAgent request
	GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeAgentWithBody request with any body
	ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeGroup request
	GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeGroupWithBody request with any body
	CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeGroup request
	DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeGroup request
	GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeGroupWithBody request with any body
	ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeMessage request
	GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeMessageWithBody request with any body
	CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeMessage request
	DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeMessage request
	GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeMessageWithBody request with any body
	ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeTransaction request
	GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartSpoeTransaction request
	StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeTransaction request
	DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeTransaction request
	GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitSpoeTransaction request
	CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeConfigurationVersion request
	GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsEndpoints request
	GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageEndpoints request
	GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageGeneralFiles request
	GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageGeneralFileWithBody request with any body
	CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageGeneralFile request
	DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageGeneralFile request
	GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageGeneralFileWithBody request with any body
	ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageMapFiles request
	GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageMapFileWithBody request with any body
	CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageMap request
	DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageMap request
	GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageMapFileWithBody request with any body
	ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageSSLCertificates request
	GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageSSLCertificateWithBody request with any body
	CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageSSLCertificate request
	DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageSSLCertificate request
	GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageSSLCertificateWithBody request with any body
	ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTransaction request
	StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransaction request
	CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpecification request
	GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiv3Specification request
	GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCertificateRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplatesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequestWithBody(c.Server, parentName, prefix, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequest(c.Server, parentName, prefix, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCachesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequestWithBody(c.Server, certificate, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequest(c.Server, certificate, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultsSectionWithBody(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultsSection(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllQUICInitialRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFCGIAppRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCapturesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllQUICInitialRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQUICInitialRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQUICInitialRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBinds(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBind(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDgramBind(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDgramBindRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBind(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBind(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogProfiles(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogProfileWithBody(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogProfileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogProfile(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogProfileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogProfile(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogProfile(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLogProfileWithBody(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLogProfileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLogProfile(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLogProfileRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHAProxyConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerRingRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraces(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTracesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTraces(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTracesWithBody(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTracesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraces(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTracesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTracesWithBody(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTracesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTraces(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTracesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraceEntryWithBody(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTraceEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraceEntry(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTraceEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraceEntryWithBody(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTraceEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraceEntry(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTraceEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequestWithBody(c.Server, username, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequest(c.Server, username, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeServerRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequestWithBody(c.Server, parentName, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequest(c.Server, parentName, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyProcessInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeMapFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearRuntimeMapRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneRuntimeMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRuntimeMapRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeMapEntryRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeMapEntryRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequestWithBody(c.Server, parentName, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequest(c.Server, parentName, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTablesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableEntriesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeScopeRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeAgentRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeGroupRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeMessageRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitSpoeTransactionRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeConfigurationVersionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageGeneralFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageGeneralFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageGeneralFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageMapFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageMapFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageSSLCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCertificateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageSSLCertificateRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageSSLCertificateRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiv3SpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAPIEndpointsRequest generates requests for GetAPIEndpoints
func NewGetAPIEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClusterRequest calls the generic PostCluster builder with application/json body
func NewPostClusterRequest(server string, params *PostClusterParams, body PostClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostClusterRequestWithBody generates requests for PostCluster with any type of body
func NewPostClusterRequestWithBody(server string, params *PostClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_address", runtime.ParamLocationQuery, *params.AdvertisedAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedPort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_port", runtime.ParamLocationQuery, *params.AdvertisedPort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditClusterRequest calls the generic EditCluster builder with application/json body
func NewEditClusterRequest(server string, params *EditClusterParams, body EditClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewEditClusterRequestWithBody generates requests for EditCluster with any type of body
func NewEditClusterRequestWithBody(server string, params *EditClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCertificateRefreshRequest generates requests for InitiateCertificateRefresh
func NewInitiateCertificateRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/certificate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionsRequest generates requests for GetAWSRegions
func NewGetAWSRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAWSRegionRequest calls the generic CreateAWSRegion builder with application/json body
func NewCreateAWSRegionRequest(server string, body CreateAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAWSRegionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAWSRegionRequestWithBody generates requests for CreateAWSRegion with any type of body
func NewCreateAWSRegionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAWSRegionRequest generates requests for DeleteAWSRegion
func NewDeleteAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionRequest generates requests for GetAWSRegion
func NewGetAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAWSRegionRequest calls the generic ReplaceAWSRegion builder with application/json body
func NewReplaceAWSRegionRequest(server string, id string, body ReplaceAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAWSRegionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceAWSRegionRequestWithBody generates requests for ReplaceAWSRegion with any type of body
func NewReplaceAWSRegionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConsulsRequest generates requests for GetConsuls
func NewGetConsulsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConsulRequest calls the generic CreateConsul builder with application/json body
func NewCreateConsulRequest(server string, body CreateConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsulRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsulRequestWithBody generates requests for CreateConsul with any type of body
func NewCreateConsulRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConsulRequest generates requests for DeleteConsul
func NewDeleteConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsulRequest generates requests for GetConsul
func NewGetConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceConsulRequest calls the generic ReplaceConsul builder with application/json body
func NewReplaceConsulRequest(server string, id string, body ReplaceConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceConsulRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceConsulRequestWithBody generates requests for ReplaceConsul with any type of body
func NewReplaceConsulRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesEndpointsRequest generates requests for GetServicesEndpoints
func NewGetServicesEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHaproxyEndpointsRequest generates requests for GetHaproxyEndpoints
func NewGetHaproxyEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationEndpointsRequest generates requests for GetConfigurationEndpoints
func NewGetConfigurationEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendsRequest generates requests for GetBackends
func NewGetBackendsRequest(server string, params *GetBackendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendRequest calls the generic CreateBackend builder with application/json body
func NewCreateBackendRequest(server string, params *CreateBackendParams, body CreateBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBackendRequestWithBody generates requests for CreateBackend with any type of body
func NewCreateBackendRequestWithBody(server string, params *CreateBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendRequest generates requests for DeleteBackend
func NewDeleteBackendRequest(server string, name string, params *DeleteBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendRequest generates requests for GetBackend
func NewGetBackendRequest(server string, name string, params *GetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendRequest calls the generic ReplaceBackend builder with application/json body
func NewReplaceBackendRequest(server string, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceBackendRequestWithBody generates requests for ReplaceBackend with any type of body
func NewReplaceBackendRequestWithBody(server string, name string, params *ReplaceBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclBackendRequest generates requests for GetAllAclBackend
func NewGetAllAclBackendRequest(server string, parentName ParentName, params *GetAllAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclBackendRequest calls the generic ReplaceAllAclBackend builder with application/json body
func NewReplaceAllAclBackendRequest(server string, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclBackendRequestWithBody generates requests for ReplaceAllAclBackend with any type of body
func NewReplaceAllAclBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclBackendRequest generates requests for DeleteAclBackend
func NewDeleteAclBackendRequest(server string, parentName ParentName, index int, params *DeleteAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclBackendRequest generates requests for GetAclBackend
func NewGetAclBackendRequest(server string, parentName ParentName, index int, params *GetAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclBackendRequest calls the generic CreateAclBackend builder with application/json body
func NewCreateAclBackendRequest(server string, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclBackendRequestWithBody generates requests for CreateAclBackend with any type of body
func NewCreateAclBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclBackendRequest calls the generic ReplaceAclBackend builder with application/json body
func NewReplaceAclBackendRequest(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclBackendRequestWithBody generates requests for ReplaceAclBackend with any type of body
func NewReplaceAclBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterBackendRequest generates requests for GetAllFilterBackend
func NewGetAllFilterBackendRequest(server string, parentName ParentName, params *GetAllFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterBackendRequest calls the generic ReplaceAllFilterBackend builder with application/json body
func NewReplaceAllFilterBackendRequest(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterBackendRequestWithBody generates requests for ReplaceAllFilterBackend with any type of body
func NewReplaceAllFilterBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterBackendRequest generates requests for DeleteFilterBackend
func NewDeleteFilterBackendRequest(server string, parentName ParentName, index int, params *DeleteFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterBackendRequest generates requests for GetFilterBackend
func NewGetFilterBackendRequest(server string, parentName ParentName, index int, params *GetFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterBackendRequest calls the generic CreateFilterBackend builder with application/json body
func NewCreateFilterBackendRequest(server string, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterBackendRequestWithBody generates requests for CreateFilterBackend with any type of body
func NewCreateFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterBackendRequest calls the generic ReplaceFilterBackend builder with application/json body
func NewReplaceFilterBackendRequest(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterBackendRequestWithBody generates requests for ReplaceFilterBackend with any type of body
func NewReplaceFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleBackendRequest generates requests for GetAllHTTPAfterResponseRuleBackend
func NewGetAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequest calls the generic ReplaceAllHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleBackend with any type of body
func NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleBackendRequest generates requests for DeleteHTTPAfterResponseRuleBackend
func NewDeleteHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleBackendRequest generates requests for GetHTTPAfterResponseRuleBackend
func NewGetHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleBackendRequest calls the generic CreateHTTPAfterResponseRuleBackend builder with application/json body
func NewCreateHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleBackendRequestWithBody generates requests for CreateHTTPAfterResponseRuleBackend with any type of body
func NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleBackendRequest calls the generic ReplaceHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleBackend with any type of body
func NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckBackendRequest generates requests for GetAllHTTPCheckBackend
func NewGetAllHTTPCheckBackendRequest(server string, parentName ParentName, params *GetAllHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckBackendRequest calls the generic ReplaceAllHTTPCheckBackend builder with application/json body
func NewReplaceAllHTTPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckBackendRequestWithBody generates requests for ReplaceAllHTTPCheckBackend with any type of body
func NewReplaceAllHTTPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckBackendRequest generates requests for DeleteHTTPCheckBackend
func NewDeleteHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckBackendRequest generates requests for GetHTTPCheckBackend
func NewGetHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *GetHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckBackendRequest calls the generic CreateHTTPCheckBackend builder with application/json body
func NewCreateHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckBackendRequestWithBody generates requests for CreateHTTPCheckBackend with any type of body
func NewCreateHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckBackendRequest calls the generic ReplaceHTTPCheckBackend builder with application/json body
func NewReplaceHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckBackendRequestWithBody generates requests for ReplaceHTTPCheckBackend with any type of body
func NewReplaceHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleBackendRequest generates requests for GetAllHTTPErrorRuleBackend
func NewGetAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleBackendRequest calls the generic ReplaceAllHTTPErrorRuleBackend builder with application/json body
func NewReplaceAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleBackend with any type of body
func NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleBackendRequest generates requests for DeleteHTTPErrorRuleBackend
func NewDeleteHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleBackendRequest generates requests for GetHTTPErrorRuleBackend
func NewGetHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleBackendRequest calls the generic CreateHTTPErrorRuleBackend builder with application/json body
func NewCreateHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleBackendRequestWithBody generates requests for CreateHTTPErrorRuleBackend with any type of body
func NewCreateHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleBackendRequest calls the generic ReplaceHTTPErrorRuleBackend builder with application/json body
func NewReplaceHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceHTTPErrorRuleBackend with any type of body
func NewReplaceHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleBackendRequest generates requests for GetAllHTTPRequestRuleBackend
func NewGetAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleBackendRequest calls the generic ReplaceAllHTTPRequestRuleBackend builder with application/json body
func NewReplaceAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleBackend with any type of body
func NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleBackendRequest generates requests for DeleteHTTPRequestRuleBackend
func NewDeleteHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleBackendRequest generates requests for GetHTTPRequestRuleBackend
func NewGetHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleBackendRequest calls the generic CreateHTTPRequestRuleBackend builder with application/json body
func NewCreateHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleBackendRequestWithBody generates requests for CreateHTTPRequestRuleBackend with any type of body
func NewCreateHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleBackendRequest calls the generic ReplaceHTTPRequestRuleBackend builder with application/json body
func NewReplaceHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceHTTPRequestRuleBackend with any type of body
func NewReplaceHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleBackendRequest generates requests for GetAllHTTPResponseRuleBackend
func NewGetAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleBackendRequest calls the generic ReplaceAllHTTPResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleBackend with any type of body
func NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleBackendRequest generates requests for DeleteHTTPResponseRuleBackend
func NewDeleteHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleBackendRequest generates requests for GetHTTPResponseRuleBackend
func NewGetHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleBackendRequest calls the generic CreateHTTPResponseRuleBackend builder with application/json body
func NewCreateHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleBackendRequestWithBody generates requests for CreateHTTPResponseRuleBackend with any type of body
func NewCreateHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleBackendRequest calls the generic ReplaceHTTPResponseRuleBackend builder with application/json body
func NewReplaceHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPResponseRuleBackend with any type of body
func NewReplaceHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetBackendRequest generates requests for GetAllLogTargetBackend
func NewGetAllLogTargetBackendRequest(server string, parentName ParentName, params *GetAllLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetBackendRequest calls the generic ReplaceAllLogTargetBackend builder with application/json body
func NewReplaceAllLogTargetBackendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetBackendRequestWithBody generates requests for ReplaceAllLogTargetBackend with any type of body
func NewReplaceAllLogTargetBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetBackendRequest generates requests for DeleteLogTargetBackend
func NewDeleteLogTargetBackendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetBackendRequest generates requests for GetLogTargetBackend
func NewGetLogTargetBackendRequest(server string, parentName ParentName, index int, params *GetLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetBackendRequest calls the generic CreateLogTargetBackend builder with application/json body
func NewCreateLogTargetBackendRequest(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetBackendRequestWithBody generates requests for CreateLogTargetBackend with any type of body
func NewCreateLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetBackendRequest calls the generic ReplaceLogTargetBackend builder with application/json body
func NewReplaceLogTargetBackendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetBackendRequestWithBody generates requests for ReplaceLogTargetBackend with any type of body
func NewReplaceLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerSwitchingRulesRequest generates requests for GetServerSwitchingRules
func NewGetServerSwitchingRulesRequest(server string, parentName ParentName, params *GetServerSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerSwitchingRulesRequest calls the generic ReplaceServerSwitchingRules builder with application/json body
func NewReplaceServerSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRulesRequestWithBody generates requests for ReplaceServerSwitchingRules with any type of body
func NewReplaceServerSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerSwitchingRuleRequest generates requests for DeleteServerSwitchingRule
func NewDeleteServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerSwitchingRuleRequest generates requests for GetServerSwitchingRule
func NewGetServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerSwitchingRuleRequest calls the generic CreateServerSwitchingRule builder with application/json body
func NewCreateServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateServerSwitchingRuleRequestWithBody generates requests for CreateServerSwitchingRule with any type of body
func NewCreateServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceServerSwitchingRuleRequest calls the generic ReplaceServerSwitchingRule builder with application/json body
func NewReplaceServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRuleRequestWithBody generates requests for ReplaceServerSwitchingRule with any type of body
func NewReplaceServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerTemplatesRequest generates requests for GetServerTemplates
func NewGetServerTemplatesRequest(server string, parentName ParentName, params *GetServerTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerTemplateRequest calls the generic CreateServerTemplate builder with application/json body
func NewCreateServerTemplateRequest(server string, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerTemplateRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerTemplateRequestWithBody generates requests for CreateServerTemplate with any type of body
func NewCreateServerTemplateRequestWithBody(server string, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerTemplateRequest generates requests for DeleteServerTemplate
func NewDeleteServerTemplateRequest(server string, parentName ParentName, prefix string, params *DeleteServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerTemplateRequest generates requests for GetServerTemplate
func NewGetServerTemplateRequest(server string, parentName ParentName, prefix string, params *GetServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerTemplateRequest calls the generic ReplaceServerTemplate builder with application/json body
func NewReplaceServerTemplateRequest(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerTemplateRequestWithBody(server, parentName, prefix, params, "application/json", bodyReader)
}

// NewReplaceServerTemplateRequestWithBody generates requests for ReplaceServerTemplate with any type of body
func NewReplaceServerTemplateRequestWithBody(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerBackendRequest generates requests for GetAllServerBackend
func NewGetAllServerBackendRequest(server string, parentName ParentName, params *GetAllServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerBackendRequest calls the generic CreateServerBackend builder with application/json body
func NewCreateServerBackendRequest(server string, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerBackendRequestWithBody generates requests for CreateServerBackend with any type of body
func NewCreateServerBackendRequestWithBody(server string, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerBackendRequest generates requests for DeleteServerBackend
func NewDeleteServerBackendRequest(server string, parentName ParentName, name string, params *DeleteServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerBackendRequest generates requests for GetServerBackend
func NewGetServerBackendRequest(server string, parentName ParentName, name string, params *GetServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerBackendRequest calls the generic ReplaceServerBackend builder with application/json body
func NewReplaceServerBackendRequest(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerBackendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerBackendRequestWithBody generates requests for ReplaceServerBackend with any type of body
func NewReplaceServerBackendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickRulesRequest generates requests for GetStickRules
func NewGetStickRulesRequest(server string, parentName ParentName, params *GetStickRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStickRulesRequest calls the generic ReplaceStickRules builder with application/json body
func NewReplaceStickRulesRequest(server string, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceStickRulesRequestWithBody generates requests for ReplaceStickRules with any type of body
func NewReplaceStickRulesRequestWithBody(server string, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStickRuleRequest generates requests for DeleteStickRule
func NewDeleteStickRuleRequest(server string, parentName ParentName, index int, params *DeleteStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickRuleRequest generates requests for GetStickRule
func NewGetStickRuleRequest(server string, parentName ParentName, index int, params *GetStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStickRuleRequest calls the generic CreateStickRule builder with application/json body
func NewCreateStickRuleRequest(server string, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateStickRuleRequestWithBody generates requests for CreateStickRule with any type of body
func NewCreateStickRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceStickRuleRequest calls the generic ReplaceStickRule builder with application/json body
func NewReplaceStickRuleRequest(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceStickRuleRequestWithBody generates requests for ReplaceStickRule with any type of body
func NewReplaceStickRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckBackendRequest generates requests for GetAllTCPCheckBackend
func NewGetAllTCPCheckBackendRequest(server string, parentName ParentName, params *GetAllTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckBackendRequest calls the generic ReplaceAllTCPCheckBackend builder with application/json body
func NewReplaceAllTCPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckBackendRequestWithBody generates requests for ReplaceAllTCPCheckBackend with any type of body
func NewReplaceAllTCPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckBackendRequest generates requests for DeleteTCPCheckBackend
func NewDeleteTCPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckBackendRequest generates requests for GetTCPCheckBackend
func NewGetTCPCheckBackendRequest(server string, parentName ParentName, index int, params *GetTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckBackendRequest calls the generic CreateTCPCheckBackend builder with application/json body
func NewCreateTCPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckBackendRequestWithBody generates requests for CreateTCPCheckBackend with any type of body
func NewCreateTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckBackendRequest calls the generic ReplaceTCPCheckBackend builder with application/json body
func NewReplaceTCPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckBackendRequestWithBody generates requests for ReplaceTCPCheckBackend with any type of body
func NewReplaceTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleBackendRequest generates requests for GetAllTCPRequestRuleBackend
func NewGetAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleBackendRequest calls the generic ReplaceAllTCPRequestRuleBackend builder with application/json body
func NewReplaceAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleBackendRequestWithBody generates requests for ReplaceAllTCPRequestRuleBackend with any type of body
func NewReplaceAllTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleBackendRequest generates requests for DeleteTCPRequestRuleBackend
func NewDeleteTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleBackendRequest generates requests for GetTCPRequestRuleBackend
func NewGetTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleBackendRequest calls the generic CreateTCPRequestRuleBackend builder with application/json body
func NewCreateTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleBackendRequestWithBody generates requests for CreateTCPRequestRuleBackend with any type of body
func NewCreateTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleBackendRequest calls the generic ReplaceTCPRequestRuleBackend builder with application/json body
func NewReplaceTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleBackendRequestWithBody generates requests for ReplaceTCPRequestRuleBackend with any type of body
func NewReplaceTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPResponseRuleBackendRequest generates requests for GetAllTCPResponseRuleBackend
func NewGetAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPResponseRuleBackendRequest calls the generic ReplaceAllTCPResponseRuleBackend builder with application/json body
func NewReplaceAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPResponseRuleBackendRequestWithBody generates requests for ReplaceAllTCPResponseRuleBackend with any type of body
func NewReplaceAllTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPResponseRuleBackendRequest generates requests for DeleteTCPResponseRuleBackend
func NewDeleteTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPResponseRuleBackendRequest generates requests for GetTCPResponseRuleBackend
func NewGetTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPResponseRuleBackendRequest calls the generic CreateTCPResponseRuleBackend builder with application/json body
func NewCreateTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPResponseRuleBackendRequestWithBody generates requests for CreateTCPResponseRuleBackend with any type of body
func NewCreateTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPResponseRuleBackendRequest calls the generic ReplaceTCPResponseRuleBackend builder with application/json body
func NewReplaceTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPResponseRuleBackendRequestWithBody generates requests for ReplaceTCPResponseRuleBackend with any type of body
func NewReplaceTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCachesRequest generates requests for GetCaches
func NewGetCachesRequest(server string, params *GetCachesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCacheRequest calls the generic CreateCache builder with application/json body
func NewCreateCacheRequest(server string, params *CreateCacheParams, body CreateCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCacheRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCacheRequestWithBody generates requests for CreateCache with any type of body
func NewCreateCacheRequestWithBody(server string, params *CreateCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCacheRequest generates requests for DeleteCache
func NewDeleteCacheRequest(server string, name string, params *DeleteCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCacheRequest generates requests for GetCache
func NewGetCacheRequest(server string, name string, params *GetCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCacheRequest calls the generic ReplaceCache builder with application/json body
func NewReplaceCacheRequest(server string, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCacheRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceCacheRequestWithBody generates requests for ReplaceCache with any type of body
func NewReplaceCacheRequestWithBody(server string, name string, params *ReplaceCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCrtLoadsRequest generates requests for GetCrtLoads
func NewGetCrtLoadsRequest(server string, params *GetCrtLoadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtLoadRequest calls the generic CreateCrtLoad builder with application/json body
func NewCreateCrtLoadRequest(server string, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtLoadRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtLoadRequestWithBody generates requests for CreateCrtLoad with any type of body
func NewCreateCrtLoadRequestWithBody(server string, params *CreateCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtLoadRequest generates requests for DeleteCrtLoad
func NewDeleteCrtLoadRequest(server string, certificate string, params *DeleteCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtLoadRequest generates requests for GetCrtLoad
func NewGetCrtLoadRequest(server string, certificate string, params *GetCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCrtLoadRequest calls the generic ReplaceCrtLoad builder with application/json body
func NewReplaceCrtLoadRequest(server string, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCrtLoadRequestWithBody(server, certificate, params, "application/json", bodyReader)
}

// NewReplaceCrtLoadRequestWithBody generates requests for ReplaceCrtLoad with any type of body
func NewReplaceCrtLoadRequestWithBody(server string, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCrtStoresRequest generates requests for GetCrtStores
func NewGetCrtStoresRequest(server string, params *GetCrtStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtStoreRequest calls the generic CreateCrtStore builder with application/json body
func NewCreateCrtStoreRequest(server string, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtStoreRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtStoreRequestWithBody generates requests for CreateCrtStore with any type of body
func NewCreateCrtStoreRequestWithBody(server string, params *CreateCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtStoreRequest generates requests for DeleteCrtStore
func NewDeleteCrtStoreRequest(server string, name string, params *DeleteCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtStoreRequest generates requests for GetCrtStore
func NewGetCrtStoreRequest(server string, name string, params *GetCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditCrtStoreRequest calls the generic EditCrtStore builder with application/json body
func NewEditCrtStoreRequest(server string, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCrtStoreRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditCrtStoreRequestWithBody generates requests for EditCrtStore with any type of body
func NewEditCrtStoreRequestWithBody(server string, name string, params *EditCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultsSectionsRequest generates requests for GetDefaultsSections
func NewGetDefaultsSectionsRequest(server string, params *GetDefaultsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDefaultsSectionRequest calls the generic AddDefaultsSection builder with application/json body
func NewAddDefaultsSectionRequest(server string, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDefaultsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddDefaultsSectionRequestWithBody generates requests for AddDefaultsSection with any type of body
func NewAddDefaultsSectionRequestWithBody(server string, params *AddDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDefaultsSectionRequest calls the generic CreateDefaultsSection builder with application/json body
func NewCreateDefaultsSectionRequest(server string, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDefaultsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateDefaultsSectionRequestWithBody generates requests for CreateDefaultsSection with any type of body
func NewCreateDefaultsSectionRequestWithBody(server string, params *CreateDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDefaultsSectionRequest generates requests for DeleteDefaultsSection
func NewDeleteDefaultsSectionRequest(server string, name string, params *DeleteDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultsSectionRequest generates requests for GetDefaultsSection
func NewGetDefaultsSectionRequest(server string, name string, params *GetDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDefaultsSectionRequest calls the generic ReplaceDefaultsSection builder with application/json body
func NewReplaceDefaultsSectionRequest(server string, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDefaultsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceDefaultsSectionRequestWithBody generates requests for ReplaceDefaultsSection with any type of body
func NewReplaceDefaultsSectionRequestWithBody(server string, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckDefaultsRequest generates requests for GetAllHTTPCheckDefaults
func NewGetAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckDefaultsRequest calls the generic ReplaceAllHTTPCheckDefaults builder with application/json body
func NewReplaceAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckDefaultsRequestWithBody generates requests for ReplaceAllHTTPCheckDefaults with any type of body
func NewReplaceAllHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckDefaultsRequest generates requests for DeleteHTTPCheckDefaults
func NewDeleteHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckDefaultsRequest generates requests for GetHTTPCheckDefaults
func NewGetHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckDefaultsRequest calls the generic CreateHTTPCheckDefaults builder with application/json body
func NewCreateHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckDefaultsRequestWithBody generates requests for CreateHTTPCheckDefaults with any type of body
func NewCreateHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckDefaultsRequest calls the generic ReplaceHTTPCheckDefaults builder with application/json body
func NewReplaceHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckDefaultsRequestWithBody generates requests for ReplaceHTTPCheckDefaults with any type of body
func NewReplaceHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleDefaultsRequest generates requests for GetAllHTTPErrorRuleDefaults
func NewGetAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleDefaultsRequest calls the generic ReplaceAllHTTPErrorRuleDefaults builder with application/json body
func NewReplaceAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPErrorRuleDefaults with any type of body
func NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleDefaultsRequest generates requests for DeleteHTTPErrorRuleDefaults
func NewDeleteHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleDefaultsRequest generates requests for GetHTTPErrorRuleDefaults
func NewGetHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleDefaultsRequest calls the generic CreateHTTPErrorRuleDefaults builder with application/json body
func NewCreateHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleDefaultsRequestWithBody generates requests for CreateHTTPErrorRuleDefaults with any type of body
func NewCreateHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleDefaultsRequest calls the generic ReplaceHTTPErrorRuleDefaults builder with application/json body
func NewReplaceHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceHTTPErrorRuleDefaults with any type of body
func NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetDefaultsRequest generates requests for GetAllLogTargetDefaults
func NewGetAllLogTargetDefaultsRequest(server string, parentName ParentName, params *GetAllLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetDefaultsRequest calls the generic ReplaceAllLogTargetDefaults builder with application/json body
func NewReplaceAllLogTargetDefaultsRequest(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetDefaultsRequestWithBody generates requests for ReplaceAllLogTargetDefaults with any type of body
func NewReplaceAllLogTargetDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetDefaultsRequest generates requests for DeleteLogTargetDefaults
func NewDeleteLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetDefaultsRequest generates requests for GetLogTargetDefaults
func NewGetLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *GetLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetDefaultsRequest calls the generic CreateLogTargetDefaults builder with application/json body
func NewCreateLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetDefaultsRequestWithBody generates requests for CreateLogTargetDefaults with any type of body
func NewCreateLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetDefaultsRequest calls the generic ReplaceLogTargetDefaults builder with application/json body
func NewReplaceLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetDefaultsRequestWithBody generates requests for ReplaceLogTargetDefaults with any type of body
func NewReplaceLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllQUICInitialRuleDefaultsRequest generates requests for GetAllQUICInitialRuleDefaults
func NewGetAllQUICInitialRuleDefaultsRequest(server string, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllQUICInitialRuleDefaultsRequest calls the generic ReplaceAllQUICInitialRuleDefaults builder with application/json body
func NewReplaceAllQUICInitialRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllQUICInitialRuleDefaultsRequestWithBody generates requests for ReplaceAllQUICInitialRuleDefaults with any type of body
func NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteQUICInitialRuleDefaultsRequest generates requests for DeleteQUICInitialRuleDefaults
func NewDeleteQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQUICInitialRuleDefaultsRequest generates requests for GetQUICInitialRuleDefaults
func NewGetQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateQUICInitialRuleDefaultsRequest calls the generic CreateQUICInitialRuleDefaults builder with application/json body
func NewCreateQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQUICInitialRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateQUICInitialRuleDefaultsRequestWithBody generates requests for CreateQUICInitialRuleDefaults with any type of body
func NewCreateQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceQUICInitialRuleDefaultsRequest calls the generic ReplaceQUICInitialRuleDefaults builder with application/json body
func NewReplaceQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceQUICInitialRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceQUICInitialRuleDefaultsRequestWithBody generates requests for ReplaceQUICInitialRuleDefaults with any type of body
func NewReplaceQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckDefaultsRequest generates requests for GetAllTCPCheckDefaults
func NewGetAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckDefaultsRequest calls the generic ReplaceAllTCPCheckDefaults builder with application/json body
func NewReplaceAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckDefaultsRequestWithBody generates requests for ReplaceAllTCPCheckDefaults with any type of body
func NewReplaceAllTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckDefaultsRequest generates requests for DeleteTCPCheckDefaults
func NewDeleteTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckDefaultsRequest generates requests for GetTCPCheckDefaults
func NewGetTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckDefaultsRequest calls the generic CreateTCPCheckDefaults builder with application/json body
func NewCreateTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckDefaultsRequestWithBody generates requests for CreateTCPCheckDefaults with any type of body
func NewCreateTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckDefaultsRequest calls the generic ReplaceTCPCheckDefaults builder with application/json body
func NewReplaceTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckDefaultsRequestWithBody generates requests for ReplaceTCPCheckDefaults with any type of body
func NewReplaceTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFCGIAppsRequest generates requests for GetFCGIApps
func NewGetFCGIAppsRequest(server string, params *GetFCGIAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFCGIAppRequest calls the generic CreateFCGIApp builder with application/json body
func NewCreateFCGIAppRequest(server string, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFCGIAppRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFCGIAppRequestWithBody generates requests for CreateFCGIApp with any type of body
func NewCreateFCGIAppRequestWithBody(server string, params *CreateFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFCGIAppRequest generates requests for DeleteFCGIApp
func NewDeleteFCGIAppRequest(server string, name string, params *DeleteFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFCGIAppRequest generates requests for GetFCGIApp
func NewGetFCGIAppRequest(server string, name string, params *GetFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFCGIAppRequest calls the generic ReplaceFCGIApp builder with application/json body
func NewReplaceFCGIAppRequest(server string, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFCGIAppRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFCGIAppRequestWithBody generates requests for ReplaceFCGIApp with any type of body
func NewReplaceFCGIAppRequestWithBody(server string, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFCGIAppRequest generates requests for GetAllAclFCGIApp
func NewGetAllAclFCGIAppRequest(server string, parentName ParentName, params *GetAllAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFCGIAppRequest calls the generic ReplaceAllAclFCGIApp builder with application/json body
func NewReplaceAllAclFCGIAppRequest(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFCGIAppRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFCGIAppRequestWithBody generates requests for ReplaceAllAclFCGIApp with any type of body
func NewReplaceAllAclFCGIAppRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFCGIAppRequest generates requests for DeleteAclFCGIApp
func NewDeleteAclFCGIAppRequest(server string, parentName ParentName, index int, params *DeleteAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFCGIAppRequest generates requests for GetAclFCGIApp
func NewGetAclFCGIAppRequest(server string, parentName ParentName, index int, params *GetAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFCGIAppRequest calls the generic CreateAclFCGIApp builder with application/json body
func NewCreateAclFCGIAppRequest(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFCGIAppRequestWithBody generates requests for CreateAclFCGIApp with any type of body
func NewCreateAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFCGIAppRequest calls the generic ReplaceAclFCGIApp builder with application/json body
func NewReplaceAclFCGIAppRequest(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFCGIAppRequestWithBody generates requests for ReplaceAclFCGIApp with any type of body
func NewReplaceAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFrontendsRequest generates requests for GetFrontends
func NewGetFrontendsRequest(server string, params *GetFrontendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFrontendRequest calls the generic CreateFrontend builder with application/json body
func NewCreateFrontendRequest(server string, params *CreateFrontendParams, body CreateFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFrontendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFrontendRequestWithBody generates requests for CreateFrontend with any type of body
func NewCreateFrontendRequestWithBody(server string, params *CreateFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFrontendRequest generates requests for DeleteFrontend
func NewDeleteFrontendRequest(server string, name string, params *DeleteFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFrontendRequest generates requests for GetFrontend
func NewGetFrontendRequest(server string, name string, params *GetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFrontendRequest calls the generic ReplaceFrontend builder with application/json body
func NewReplaceFrontendRequest(server string, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFrontendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFrontendRequestWithBody generates requests for ReplaceFrontend with any type of body
func NewReplaceFrontendRequestWithBody(server string, name string, params *ReplaceFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFrontendRequest generates requests for GetAllAclFrontend
func NewGetAllAclFrontendRequest(server string, parentName ParentName, params *GetAllAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFrontendRequest calls the generic ReplaceAllAclFrontend builder with application/json body
func NewReplaceAllAclFrontendRequest(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFrontendRequestWithBody generates requests for ReplaceAllAclFrontend with any type of body
func NewReplaceAllAclFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFrontendRequest generates requests for DeleteAclFrontend
func NewDeleteAclFrontendRequest(server string, parentName ParentName, index int, params *DeleteAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFrontendRequest generates requests for GetAclFrontend
func NewGetAclFrontendRequest(server string, parentName ParentName, index int, params *GetAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFrontendRequest calls the generic CreateAclFrontend builder with application/json body
func NewCreateAclFrontendRequest(server string, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFrontendRequestWithBody generates requests for CreateAclFrontend with any type of body
func NewCreateAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFrontendRequest calls the generic ReplaceAclFrontend builder with application/json body
func NewReplaceAclFrontendRequest(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFrontendRequestWithBody generates requests for ReplaceAclFrontend with any type of body
func NewReplaceAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackendSwitchingRulesRequest generates requests for GetBackendSwitchingRules
func NewGetBackendSwitchingRulesRequest(server string, parentName ParentName, params *GetBackendSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendSwitchingRulesRequest calls the generic ReplaceBackendSwitchingRules builder with application/json body
func NewReplaceBackendSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRulesRequestWithBody generates requests for ReplaceBackendSwitchingRules with any type of body
func NewReplaceBackendSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendSwitchingRuleRequest generates requests for DeleteBackendSwitchingRule
func NewDeleteBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendSwitchingRuleRequest generates requests for GetBackendSwitchingRule
func NewGetBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendSwitchingRuleRequest calls the generic CreateBackendSwitchingRule builder with application/json body
func NewCreateBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateBackendSwitchingRuleRequestWithBody generates requests for CreateBackendSwitchingRule with any type of body
func NewCreateBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceBackendSwitchingRuleRequest calls the generic ReplaceBackendSwitchingRule builder with application/json body
func NewReplaceBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRuleRequestWithBody generates requests for ReplaceBackendSwitchingRule with any type of body
func NewReplaceBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindFrontendRequest generates requests for GetAllBindFrontend
func NewGetAllBindFrontendRequest(server string, parentName ParentName, params *GetAllBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindFrontendRequest calls the generic CreateBindFrontend builder with application/json body
func NewCreateBindFrontendRequest(server string, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindFrontendRequestWithBody generates requests for CreateBindFrontend with any type of body
func NewCreateBindFrontendRequestWithBody(server string, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindFrontendRequest generates requests for DeleteBindFrontend
func NewDeleteBindFrontendRequest(server string, parentName ParentName, name string, params *DeleteBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindFrontendRequest generates requests for GetBindFrontend
func NewGetBindFrontendRequest(server string, parentName ParentName, name string, params *GetBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindFrontendRequest calls the generic ReplaceBindFrontend builder with application/json body
func NewReplaceBindFrontendRequest(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindFrontendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindFrontendRequestWithBody generates requests for ReplaceBindFrontend with any type of body
func NewReplaceBindFrontendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeclareCapturesRequest generates requests for GetDeclareCaptures
func NewGetDeclareCapturesRequest(server string, parentName ParentName, params *GetDeclareCapturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDeclareCapturesRequest calls the generic ReplaceDeclareCaptures builder with application/json body
func NewReplaceDeclareCapturesRequest(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCapturesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceDeclareCapturesRequestWithBody generates requests for ReplaceDeclareCaptures with any type of body
func NewReplaceDeclareCapturesRequestWithBody(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeclareCaptureRequest generates requests for DeleteDeclareCapture
func NewDeleteDeclareCaptureRequest(server string, parentName ParentName, index int, params *DeleteDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeclareCaptureRequest generates requests for GetDeclareCapture
func NewGetDeclareCaptureRequest(server string, parentName ParentName, index int, params *GetDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeclareCaptureRequest calls the generic CreateDeclareCapture builder with application/json body
func NewCreateDeclareCaptureRequest(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateDeclareCaptureRequestWithBody generates requests for CreateDeclareCapture with any type of body
func NewCreateDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceDeclareCaptureRequest calls the generic ReplaceDeclareCapture builder with application/json body
func NewReplaceDeclareCaptureRequest(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceDeclareCaptureRequestWithBody generates requests for ReplaceDeclareCapture with any type of body
func NewReplaceDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterFrontendRequest generates requests for GetAllFilterFrontend
func NewGetAllFilterFrontendRequest(server string, parentName ParentName, params *GetAllFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterFrontendRequest calls the generic ReplaceAllFilterFrontend builder with application/json body
func NewReplaceAllFilterFrontendRequest(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterFrontendRequestWithBody generates requests for ReplaceAllFilterFrontend with any type of body
func NewReplaceAllFilterFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterFrontendRequest generates requests for DeleteFilterFrontend
func NewDeleteFilterFrontendRequest(server string, parentName ParentName, index int, params *DeleteFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterFrontendRequest generates requests for GetFilterFrontend
func NewGetFilterFrontendRequest(server string, parentName ParentName, index int, params *GetFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterFrontendRequest calls the generic CreateFilterFrontend builder with application/json body
func NewCreateFilterFrontendRequest(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterFrontendRequestWithBody generates requests for CreateFilterFrontend with any type of body
func NewCreateFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterFrontendRequest calls the generic ReplaceFilterFrontend builder with application/json body
func NewReplaceFilterFrontendRequest(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterFrontendRequestWithBody generates requests for ReplaceFilterFrontend with any type of body
func NewReplaceFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleFrontendRequest generates requests for GetAllHTTPAfterResponseRuleFrontend
func NewGetAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceAllHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleFrontendRequest generates requests for DeleteHTTPAfterResponseRuleFrontend
func NewDeleteHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleFrontendRequest generates requests for GetHTTPAfterResponseRuleFrontend
func NewGetHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleFrontendRequest calls the generic CreateHTTPAfterResponseRuleFrontend builder with application/json body
func NewCreateHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleFrontendRequestWithBody generates requests for CreateHTTPAfterResponseRuleFrontend with any type of body
func NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleFrontendRequest generates requests for GetAllHTTPErrorRuleFrontend
func NewGetAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleFrontendRequest calls the generic ReplaceAllHTTPErrorRuleFrontend builder with application/json body
func NewReplaceAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleFrontend with any type of body
func NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleFrontendRequest generates requests for DeleteHTTPErrorRuleFrontend
func NewDeleteHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleFrontendRequest generates requests for GetHTTPErrorRuleFrontend
func NewGetHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleFrontendRequest calls the generic CreateHTTPErrorRuleFrontend builder with application/json body
func NewCreateHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleFrontendRequestWithBody generates requests for CreateHTTPErrorRuleFrontend with any type of body
func NewCreateHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleFrontendRequest calls the generic ReplaceHTTPErrorRuleFrontend builder with application/json body
func NewReplaceHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceHTTPErrorRuleFrontend with any type of body
func NewReplaceHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleFrontendRequest generates requests for GetAllHTTPRequestRuleFrontend
func NewGetAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleFrontendRequest calls the generic ReplaceAllHTTPRequestRuleFrontend builder with application/json body
func NewReplaceAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleFrontend with any type of body
func NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleFrontendRequest generates requests for DeleteHTTPRequestRuleFrontend
func NewDeleteHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleFrontendRequest generates requests for GetHTTPRequestRuleFrontend
func NewGetHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleFrontendRequest calls the generic CreateHTTPRequestRuleFrontend builder with application/json body
func NewCreateHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleFrontendRequestWithBody generates requests for CreateHTTPRequestRuleFrontend with any type of body
func NewCreateHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleFrontendRequest calls the generic ReplaceHTTPRequestRuleFrontend builder with application/json body
func NewReplaceHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceHTTPRequestRuleFrontend with any type of body
func NewReplaceHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleFrontendRequest generates requests for GetAllHTTPResponseRuleFrontend
func NewGetAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleFrontendRequest calls the generic ReplaceAllHTTPResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleFrontend with any type of body
func NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleFrontendRequest generates requests for DeleteHTTPResponseRuleFrontend
func NewDeleteHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleFrontendRequest generates requests for GetHTTPResponseRuleFrontend
func NewGetHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleFrontendRequest calls the generic CreateHTTPResponseRuleFrontend builder with application/json body
func NewCreateHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleFrontendRequestWithBody generates requests for CreateHTTPResponseRuleFrontend with any type of body
func NewCreateHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleFrontendRequest calls the generic ReplaceHTTPResponseRuleFrontend builder with application/json body
func NewReplaceHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPResponseRuleFrontend with any type of body
func NewReplaceHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetFrontendRequest generates requests for GetAllLogTargetFrontend
func NewGetAllLogTargetFrontendRequest(server string, parentName ParentName, params *GetAllLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetFrontendRequest calls the generic ReplaceAllLogTargetFrontend builder with application/json body
func NewReplaceAllLogTargetFrontendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetFrontendRequestWithBody generates requests for ReplaceAllLogTargetFrontend with any type of body
func NewReplaceAllLogTargetFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetFrontendRequest generates requests for DeleteLogTargetFrontend
func NewDeleteLogTargetFrontendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetFrontendRequest generates requests for GetLogTargetFrontend
func NewGetLogTargetFrontendRequest(server string, parentName ParentName, index int, params *GetLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetFrontendRequest calls the generic CreateLogTargetFrontend builder with application/json body
func NewCreateLogTargetFrontendRequest(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetFrontendRequestWithBody generates requests for CreateLogTargetFrontend with any type of body
func NewCreateLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetFrontendRequest calls the generic ReplaceLogTargetFrontend builder with application/json body
func NewReplaceLogTargetFrontendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetFrontendRequestWithBody generates requests for ReplaceLogTargetFrontend with any type of body
func NewReplaceLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllQUICInitialRuleFrontendRequest generates requests for GetAllQUICInitialRuleFrontend
func NewGetAllQUICInitialRuleFrontendRequest(server string, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllQUICInitialRuleFrontendRequest calls the generic ReplaceAllQUICInitialRuleFrontend builder with application/json body
func NewReplaceAllQUICInitialRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllQUICInitialRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllQUICInitialRuleFrontendRequestWithBody generates requests for ReplaceAllQUICInitialRuleFrontend with any type of body
func NewReplaceAllQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteQUICInitialRuleFrontendRequest generates requests for DeleteQUICInitialRuleFrontend
func NewDeleteQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQUICInitialRuleFrontendRequest generates requests for GetQUICInitialRuleFrontend
func NewGetQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateQUICInitialRuleFrontendRequest calls the generic CreateQUICInitialRuleFrontend builder with application/json body
func NewCreateQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQUICInitialRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateQUICInitialRuleFrontendRequestWithBody generates requests for CreateQUICInitialRuleFrontend with any type of body
func NewCreateQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceQUICInitialRuleFrontendRequest calls the generic ReplaceQUICInitialRuleFrontend builder with application/json body
func NewReplaceQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceQUICInitialRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceQUICInitialRuleFrontendRequestWithBody generates requests for ReplaceQUICInitialRuleFrontend with any type of body
func NewReplaceQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleFrontendRequest generates requests for GetAllTCPRequestRuleFrontend
func NewGetAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleFrontendRequest calls the generic ReplaceAllTCPRequestRuleFrontend builder with application/json body
func NewReplaceAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllTCPRequestRuleFrontend with any type of body
func NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleFrontendRequest generates requests for DeleteTCPRequestRuleFrontend
func NewDeleteTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleFrontendRequest generates requests for GetTCPRequestRuleFrontend
func NewGetTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleFrontendRequest calls the generic CreateTCPRequestRuleFrontend builder with application/json body
func NewCreateTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleFrontendRequestWithBody generates requests for CreateTCPRequestRuleFrontend with any type of body
func NewCreateTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleFrontendRequest calls the generic ReplaceTCPRequestRuleFrontend builder with application/json body
func NewReplaceTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceTCPRequestRuleFrontend with any type of body
func NewReplaceTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string, params *GetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGlobalRequest calls the generic ReplaceGlobal builder with application/json body
func NewReplaceGlobalRequest(server string, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceGlobalRequestWithBody generates requests for ReplaceGlobal with any type of body
func NewReplaceGlobalRequestWithBody(server string, params *ReplaceGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetGlobalRequest generates requests for GetAllLogTargetGlobal
func NewGetAllLogTargetGlobalRequest(server string, params *GetAllLogTargetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetGlobalRequest calls the generic ReplaceAllLogTargetGlobal builder with application/json body
func NewReplaceAllLogTargetGlobalRequest(server string, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetGlobalRequestWithBody generates requests for ReplaceAllLogTargetGlobal with any type of body
func NewReplaceAllLogTargetGlobalRequestWithBody(server string, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetGlobalRequest generates requests for DeleteLogTargetGlobal
func NewDeleteLogTargetGlobalRequest(server string, index int, params *DeleteLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetGlobalRequest generates requests for GetLogTargetGlobal
func NewGetLogTargetGlobalRequest(server string, index int, params *GetLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetGlobalRequest calls the generic CreateLogTargetGlobal builder with application/json body
func NewCreateLogTargetGlobalRequest(server string, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetGlobalRequestWithBody generates requests for CreateLogTargetGlobal with any type of body
func NewCreateLogTargetGlobalRequestWithBody(server string, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetGlobalRequest calls the generic ReplaceLogTargetGlobal builder with application/json body
func NewReplaceLogTargetGlobalRequest(server string, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetGlobalRequestWithBody generates requests for ReplaceLogTargetGlobal with any type of body
func NewReplaceLogTargetGlobalRequestWithBody(server string, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, params *CreateGroupParams, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, params *CreateGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, name string, params *DeleteGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, name string, params *GetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGroupRequest calls the generic ReplaceGroup builder with application/json body
func NewReplaceGroupRequest(server string, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGroupRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceGroupRequestWithBody generates requests for ReplaceGroup with any type of body
func NewReplaceGroupRequestWithBody(server string, name string, params *ReplaceGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHTTPErrorsSectionsRequest generates requests for GetHTTPErrorsSections
func NewGetHTTPErrorsSectionsRequest(server string, params *GetHTTPErrorsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorsSectionRequest calls the generic CreateHTTPErrorsSection builder with application/json body
func NewCreateHTTPErrorsSectionRequest(server string, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorsSectionRequestWithBody generates requests for CreateHTTPErrorsSection with any type of body
func NewCreateHTTPErrorsSectionRequestWithBody(server string, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorsSectionRequest generates requests for DeleteHTTPErrorsSection
func NewDeleteHTTPErrorsSectionRequest(server string, name string, params *DeleteHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorsSectionRequest generates requests for GetHTTPErrorsSection
func NewGetHTTPErrorsSectionRequest(server string, name string, params *GetHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceHTTPErrorsSectionRequest calls the generic ReplaceHTTPErrorsSection builder with application/json body
func NewReplaceHTTPErrorsSectionRequest(server string, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorsSectionRequestWithBody generates requests for ReplaceHTTPErrorsSection with any type of body
func NewReplaceHTTPErrorsSectionRequestWithBody(server string, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogForwardsRequest generates requests for GetLogForwards
func NewGetLogForwardsRequest(server string, params *GetLogForwardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogForwardRequest calls the generic CreateLogForward builder with application/json body
func NewCreateLogForwardRequest(server string, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogForwardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogForwardRequestWithBody generates requests for CreateLogForward with any type of body
func NewCreateLogForwardRequestWithBody(server string, params *CreateLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogForwardRequest generates requests for DeleteLogForward
func NewDeleteLogForwardRequest(server string, name string, params *DeleteLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogForwardRequest generates requests for GetLogForward
func NewGetLogForwardRequest(server string, name string, params *GetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogForwardRequest calls the generic ReplaceLogForward builder with application/json body
func NewReplaceLogForwardRequest(server string, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogForwardRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceLogForwardRequestWithBody generates requests for ReplaceLogForward with any type of body
func NewReplaceLogForwardRequestWithBody(server string, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindLogForwardRequest generates requests for GetAllBindLogForward
func NewGetAllBindLogForwardRequest(server string, parentName ParentName, params *GetAllBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindLogForwardRequest calls the generic CreateBindLogForward builder with application/json body
func NewCreateBindLogForwardRequest(server string, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindLogForwardRequestWithBody generates requests for CreateBindLogForward with any type of body
func NewCreateBindLogForwardRequestWithBody(server string, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindLogForwardRequest generates requests for DeleteBindLogForward
func NewDeleteBindLogForwardRequest(server string, parentName ParentName, name string, params *DeleteBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindLogForwardRequest generates requests for GetBindLogForward
func NewGetBindLogForwardRequest(server string, parentName ParentName, name string, params *GetBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindLogForwardRequest calls the generic ReplaceBindLogForward builder with application/json body
func NewReplaceBindLogForwardRequest(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindLogForwardRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindLogForwardRequestWithBody generates requests for ReplaceBindLogForward with any type of body
func NewReplaceBindLogForwardRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDgramBindsRequest generates requests for GetDgramBinds
func NewGetDgramBindsRequest(server string, parentName ParentName, params *GetDgramBindsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDgramBindRequest calls the generic CreateDgramBind builder with application/json body
func NewCreateDgramBindRequest(server string, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDgramBindRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateDgramBindRequestWithBody generates requests for CreateDgramBind with any type of body
func NewCreateDgramBindRequestWithBody(server string, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDgramBindRequest generates requests for DeleteDgramBind
func NewDeleteDgramBindRequest(server string, parentName ParentName, name string, params *DeleteDgramBindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDgramBindRequest generates requests for GetDgramBind
func NewGetDgramBindRequest(server string, parentName ParentName, name string, params *GetDgramBindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDgramBindRequest calls the generic ReplaceDgramBind builder with application/json body
func NewReplaceDgramBindRequest(server string, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDgramBindRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceDgramBindRequestWithBody generates requests for ReplaceDgramBind with any type of body
func NewReplaceDgramBindRequestWithBody(server string, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetLogForwardRequest generates requests for GetAllLogTargetLogForward
func NewGetAllLogTargetLogForwardRequest(server string, parentName ParentName, params *GetAllLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetLogForwardRequest calls the generic ReplaceAllLogTargetLogForward builder with application/json body
func NewReplaceAllLogTargetLogForwardRequest(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetLogForwardRequestWithBody generates requests for ReplaceAllLogTargetLogForward with any type of body
func NewReplaceAllLogTargetLogForwardRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetLogForwardRequest generates requests for DeleteLogTargetLogForward
func NewDeleteLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetLogForwardRequest generates requests for GetLogTargetLogForward
func NewGetLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *GetLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetLogForwardRequest calls the generic CreateLogTargetLogForward builder with application/json body
func NewCreateLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetLogForwardRequestWithBody generates requests for CreateLogTargetLogForward with any type of body
func NewCreateLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetLogForwardRequest calls the generic ReplaceLogTargetLogForward builder with application/json body
func NewReplaceLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetLogForwardRequestWithBody generates requests for ReplaceLogTargetLogForward with any type of body
func NewReplaceLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogProfilesRequest generates requests for GetLogProfiles
func NewGetLogProfilesRequest(server string, params *GetLogProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogProfileRequest calls the generic CreateLogProfile builder with application/json body
func NewCreateLogProfileRequest(server string, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogProfileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogProfileRequestWithBody generates requests for CreateLogProfile with any type of body
func NewCreateLogProfileRequestWithBody(server string, params *CreateLogProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogProfileRequest generates requests for DeleteLogProfile
func NewDeleteLogProfileRequest(server string, name string, params *DeleteLogProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogProfileRequest generates requests for GetLogProfile
func NewGetLogProfileRequest(server string, name string, params *GetLogProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditLogProfileRequest calls the generic EditLogProfile builder with application/json body
func NewEditLogProfileRequest(server string, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditLogProfileRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditLogProfileRequestWithBody generates requests for EditLogProfile with any type of body
func NewEditLogProfileRequestWithBody(server string, name string, params *EditLogProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailerEntriesRequest generates requests for GetMailerEntries
func NewGetMailerEntriesRequest(server string, params *GetMailerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailerEntryRequest calls the generic CreateMailerEntry builder with application/json body
func NewCreateMailerEntryRequest(server string, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailerEntryRequestWithBody generates requests for CreateMailerEntry with any type of body
func NewCreateMailerEntryRequestWithBody(server string, params *CreateMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailerEntryRequest generates requests for DeleteMailerEntry
func NewDeleteMailerEntryRequest(server string, name string, params *DeleteMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailerEntryRequest generates requests for GetMailerEntry
func NewGetMailerEntryRequest(server string, name string, params *GetMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceMailerEntryRequest calls the generic ReplaceMailerEntry builder with application/json body
func NewReplaceMailerEntryRequest(server string, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceMailerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceMailerEntryRequestWithBody generates requests for ReplaceMailerEntry with any type of body
func NewReplaceMailerEntryRequestWithBody(server string, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailersSectionsRequest generates requests for GetMailersSections
func NewGetMailersSectionsRequest(server string, params *GetMailersSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailersSectionRequest calls the generic CreateMailersSection builder with application/json body
func NewCreateMailersSectionRequest(server string, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailersSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailersSectionRequestWithBody generates requests for CreateMailersSection with any type of body
func NewCreateMailersSectionRequestWithBody(server string, params *CreateMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailersSectionRequest generates requests for DeleteMailersSection
func NewDeleteMailersSectionRequest(server string, name string, params *DeleteMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailersSectionRequest generates requests for GetMailersSection
func NewGetMailersSectionRequest(server string, name string, params *GetMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditMailersSectionRequest calls the generic EditMailersSection builder with application/json body
func NewEditMailersSectionRequest(server string, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMailersSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditMailersSectionRequestWithBody generates requests for EditMailersSection with any type of body
func NewEditMailersSectionRequestWithBody(server string, name string, params *EditMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNameserversRequest generates requests for GetNameservers
func NewGetNameserversRequest(server string, params *GetNameserversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNameserverRequest calls the generic CreateNameserver builder with application/json body
func NewCreateNameserverRequest(server string, params *CreateNameserverParams, body CreateNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNameserverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateNameserverRequestWithBody generates requests for CreateNameserver with any type of body
func NewCreateNameserverRequestWithBody(server string, params *CreateNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNameserverRequest generates requests for DeleteNameserver
func NewDeleteNameserverRequest(server string, name string, params *DeleteNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNameserverRequest generates requests for GetNameserver
func NewGetNameserverRequest(server string, name string, params *GetNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceNameserverRequest calls the generic ReplaceNameserver builder with application/json body
func NewReplaceNameserverRequest(server string, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceNameserverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceNameserverRequestWithBody generates requests for ReplaceNameserver with any type of body
func NewReplaceNameserverRequestWithBody(server string, name string, params *ReplaceNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerEntriesRequest generates requests for GetPeerEntries
func NewGetPeerEntriesRequest(server string, params *GetPeerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerEntryRequest calls the generic CreatePeerEntry builder with application/json body
func NewCreatePeerEntryRequest(server string, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerEntryRequestWithBody generates requests for CreatePeerEntry with any type of body
func NewCreatePeerEntryRequestWithBody(server string, params *CreatePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerEntryRequest generates requests for DeletePeerEntry
func NewDeletePeerEntryRequest(server string, name string, params *DeletePeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerEntryRequest generates requests for GetPeerEntry
func NewGetPeerEntryRequest(server string, name string, params *GetPeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplacePeerEntryRequest calls the generic ReplacePeerEntry builder with application/json body
func NewReplacePeerEntryRequest(server string, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplacePeerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplacePeerEntryRequestWithBody generates requests for ReplacePeerEntry with any type of body
func NewReplacePeerEntryRequestWithBody(server string, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerSectionsRequest generates requests for GetPeerSections
func NewGetPeerSectionsRequest(server string, params *GetPeerSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerRequest calls the generic CreatePeer builder with application/json body
func NewCreatePeerRequest(server string, params *CreatePeerParams, body CreatePeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerRequestWithBody generates requests for CreatePeer with any type of body
func NewCreatePeerRequestWithBody(server string, params *CreatePeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerRequest generates requests for DeletePeer
func NewDeletePeerRequest(server string, name string, params *DeletePeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerSectionRequest generates requests for GetPeerSection
func NewGetPeerSectionRequest(server string, name string, params *GetPeerSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllBindPeerRequest generates requests for GetAllBindPeer
func NewGetAllBindPeerRequest(server string, parentName ParentName, params *GetAllBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindPeerRequest calls the generic CreateBindPeer builder with application/json body
func NewCreateBindPeerRequest(server string, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindPeerRequestWithBody generates requests for CreateBindPeer with any type of body
func NewCreateBindPeerRequestWithBody(server string, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindPeerRequest generates requests for DeleteBindPeer
func NewDeleteBindPeerRequest(server string, parentName ParentName, name string, params *DeleteBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindPeerRequest generates requests for GetBindPeer
func NewGetBindPeerRequest(server string, parentName ParentName, name string, params *GetBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindPeerRequest calls the generic ReplaceBindPeer builder with application/json body
func NewReplaceBindPeerRequest(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindPeerRequestWithBody generates requests for ReplaceBindPeer with any type of body
func NewReplaceBindPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetPeerRequest generates requests for GetAllLogTargetPeer
func NewGetAllLogTargetPeerRequest(server string, parentName ParentName, params *GetAllLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetPeerRequest calls the generic ReplaceAllLogTargetPeer builder with application/json body
func NewReplaceAllLogTargetPeerRequest(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetPeerRequestWithBody generates requests for ReplaceAllLogTargetPeer with any type of body
func NewReplaceAllLogTargetPeerRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetPeerRequest generates requests for DeleteLogTargetPeer
func NewDeleteLogTargetPeerRequest(server string, parentName ParentName, index int, params *DeleteLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetPeerRequest generates requests for GetLogTargetPeer
func NewGetLogTargetPeerRequest(server string, parentName ParentName, index int, params *GetLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetPeerRequest calls the generic CreateLogTargetPeer builder with application/json body
func NewCreateLogTargetPeerRequest(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetPeerRequestWithBody generates requests for CreateLogTargetPeer with any type of body
func NewCreateLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetPeerRequest calls the generic ReplaceLogTargetPeer builder with application/json body
func NewReplaceLogTargetPeerRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetPeerRequestWithBody generates requests for ReplaceLogTargetPeer with any type of body
func NewReplaceLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerPeerRequest generates requests for GetAllServerPeer
func NewGetAllServerPeerRequest(server string, parentName ParentName, params *GetAllServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerPeerRequest calls the generic CreateServerPeer builder with application/json body
func NewCreateServerPeerRequest(server string, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerPeerRequestWithBody generates requests for CreateServerPeer with any type of body
func NewCreateServerPeerRequestWithBody(server string, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerPeerRequest generates requests for DeleteServerPeer
func NewDeleteServerPeerRequest(server string, parentName ParentName, name string, params *DeleteServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerPeerRequest generates requests for GetServerPeer
func NewGetServerPeerRequest(server string, parentName ParentName, name string, params *GetServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerPeerRequest calls the generic ReplaceServerPeer builder with application/json body
func NewReplaceServerPeerRequest(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerPeerRequestWithBody generates requests for ReplaceServerPeer with any type of body
func NewReplaceServerPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, parentName ParentName, params *GetTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, parentName ParentName, name string, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, parentName ParentName, name string, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceTableRequest calls the generic ReplaceTable builder with application/json body
func NewReplaceTableRequest(server string, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTableRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceTableRequestWithBody generates requests for ReplaceTable with any type of body
func NewReplaceTableRequestWithBody(server string, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramsRequest generates requests for GetPrograms
func NewGetProgramsRequest(server string, params *GetProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRequest calls the generic CreateProgram builder with application/json body
func NewCreateProgramRequest(server string, params *CreateProgramParams, body CreateProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProgramRequestWithBody generates requests for CreateProgram with any type of body
func NewCreateProgramRequestWithBody(server string, params *CreateProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, name string, params *DeleteProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, name string, params *GetProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceProgramRequest calls the generic ReplaceProgram builder with application/json body
func NewReplaceProgramRequest(server string, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceProgramRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceProgramRequestWithBody generates requests for ReplaceProgram with any type of body
func NewReplaceProgramRequestWithBody(server string, name string, params *ReplaceProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHAProxyConfigurationRequest generates requests for GetHAProxyConfiguration
func NewGetHAProxyConfigurationRequest(server string, params *GetHAProxyConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostHAProxyConfigurationRequestWithTextBody calls the generic PostHAProxyConfiguration builder with text/plain body
func NewPostHAProxyConfigurationRequestWithTextBody(server string, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewPostHAProxyConfigurationRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewPostHAProxyConfigurationRequestWithBody generates requests for PostHAProxyConfiguration with any type of body
func NewPostHAProxyConfigurationRequestWithBody(server string, params *PostHAProxyConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_version", runtime.ParamLocationQuery, *params.SkipVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyValidate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_validate", runtime.ParamLocationQuery, *params.OnlyValidate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRuntimeActions != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Runtime-Actions", runtime.ParamLocationHeader, *params.XRuntimeActions)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Runtime-Actions", headerParam0)
		}

	}

	return req, nil
}

// NewGetResolversRequest generates requests for GetResolvers
func NewGetResolversRequest(server string, params *GetResolversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResolverRequest calls the generic CreateResolver builder with application/json body
func NewCreateResolverRequest(server string, params *CreateResolverParams, body CreateResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResolverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateResolverRequestWithBody generates requests for CreateResolver with any type of body
func NewCreateResolverRequestWithBody(server string, params *CreateResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResolverRequest generates requests for DeleteResolver
func NewDeleteResolverRequest(server string, name string, params *DeleteResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResolverRequest generates requests for GetResolver
func NewGetResolverRequest(server string, name string, params *GetResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceResolverRequest calls the generic ReplaceResolver builder with application/json body
func NewReplaceResolverRequest(server string, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceResolverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceResolverRequestWithBody generates requests for ReplaceResolver with any type of body
func NewReplaceResolverRequestWithBody(server string, name string, params *ReplaceResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRingsRequest generates requests for GetRings
func NewGetRingsRequest(server string, params *GetRingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRingRequest calls the generic CreateRing builder with application/json body
func NewCreateRingRequest(server string, params *CreateRingParams, body CreateRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRingRequestWithBody generates requests for CreateRing with any type of body
func NewCreateRingRequestWithBody(server string, params *CreateRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRingRequest generates requests for DeleteRing
func NewDeleteRingRequest(server string, name string, params *DeleteRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRingRequest generates requests for GetRing
func NewGetRingRequest(server string, name string, params *GetRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRingRequest calls the generic ReplaceRing builder with application/json body
func NewReplaceRingRequest(server string, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRingRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceRingRequestWithBody generates requests for ReplaceRing with any type of body
func NewReplaceRingRequestWithBody(server string, name string, params *ReplaceRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerRingRequest generates requests for GetAllServerRing
func NewGetAllServerRingRequest(server string, parentName ParentName, params *GetAllServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerRingRequest calls the generic CreateServerRing builder with application/json body
func NewCreateServerRingRequest(server string, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRingRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerRingRequestWithBody generates requests for CreateServerRing with any type of body
func NewCreateServerRingRequestWithBody(server string, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerRingRequest generates requests for DeleteServerRing
func NewDeleteServerRingRequest(server string, parentName ParentName, name string, params *DeleteServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerRingRequest generates requests for GetServerRing
func NewGetServerRingRequest(server string, parentName ParentName, name string, params *GetServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerRingRequest calls the generic ReplaceServerRing builder with application/json body
func NewReplaceServerRingRequest(server string, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerRingRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerRingRequestWithBody generates requests for ReplaceServerRing with any type of body
func NewReplaceServerRingRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTracesRequest generates requests for DeleteTraces
func NewDeleteTracesRequest(server string, params *DeleteTracesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracesRequest generates requests for GetTraces
func NewGetTracesRequest(server string, params *GetTracesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTracesRequest calls the generic CreateTraces builder with application/json body
func NewCreateTracesRequest(server string, params *CreateTracesParams, body CreateTracesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTracesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTracesRequestWithBody generates requests for CreateTraces with any type of body
func NewCreateTracesRequestWithBody(server string, params *CreateTracesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTracesRequest calls the generic ReplaceTraces builder with application/json body
func NewReplaceTracesRequest(server string, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTracesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceTracesRequestWithBody generates requests for ReplaceTraces with any type of body
func NewReplaceTracesRequestWithBody(server string, params *ReplaceTracesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTraceEntryRequest calls the generic DeleteTraceEntry builder with application/json body
func NewDeleteTraceEntryRequest(server string, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTraceEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteTraceEntryRequestWithBody generates requests for DeleteTraceEntry with any type of body
func NewDeleteTraceEntryRequestWithBody(server string, params *DeleteTraceEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTraceEntryRequest calls the generic CreateTraceEntry builder with application/json body
func NewCreateTraceEntryRequest(server string, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTraceEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTraceEntryRequestWithBody generates requests for CreateTraceEntry with any type of body
func NewCreateTraceEntryRequestWithBody(server string, params *CreateTraceEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserlistsRequest generates requests for GetUserlists
func NewGetUserlistsRequest(server string, params *GetUserlistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserlistRequest calls the generic CreateUserlist builder with application/json body
func NewCreateUserlistRequest(server string, params *CreateUserlistParams, body CreateUserlistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserlistRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserlistRequestWithBody generates requests for CreateUserlist with any type of body
func NewCreateUserlistRequestWithBody(server string, params *CreateUserlistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserlistRequest generates requests for DeleteUserlist
func NewDeleteUserlistRequest(server string, name string, params *DeleteUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserlistRequest generates requests for GetUserlist
func NewGetUserlistRequest(server string, name string, params *GetUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, username string, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, username string, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceUserRequest calls the generic ReplaceUser builder with application/json body
func NewReplaceUserRequest(server string, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceUserRequestWithBody(server, username, params, "application/json", bodyReader)
}

// NewReplaceUserRequestWithBody generates requests for ReplaceUser with any type of body
func NewReplaceUserRequestWithBody(server string, username string, params *ReplaceUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationVersionRequest generates requests for GetConfigurationVersion
func NewGetConfigurationVersionRequest(server string, params *GetConfigurationVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReloadsRequest generates requests for GetReloads
func NewGetReloadsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReloadRequest generates requests for GetReload
func NewGetReloadRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeEndpointsRequest generates requests for GetRuntimeEndpoints
func NewGetRuntimeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsRequest generates requests for GetServicesHaproxyRuntimeAcls
func NewGetServicesHaproxyRuntimeAclsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsIdRequest generates requests for GetServicesHaproxyRuntimeAclsId
func NewGetServicesHaproxyRuntimeAclsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntries
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest calls the generic PostServicesHaproxyRuntimeAclsParentNameEntries builder with application/json body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody generates requests for PostServicesHaproxyRuntimeAclsParentNameEntries with any type of body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddPayloadRuntimeACLRequest calls the generic AddPayloadRuntimeACL builder with application/json body
func NewAddPayloadRuntimeACLRequest(server string, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeACLRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddPayloadRuntimeACLRequestWithBody generates requests for AddPayloadRuntimeACL with any type of body
func NewAddPayloadRuntimeACLRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for DeleteServicesHaproxyRuntimeAclsParentNameEntriesId
func NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntriesId
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeServerRequest generates requests for GetAllRuntimeServer
func NewGetAllRuntimeServerRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRuntimeServerRequest calls the generic AddRuntimeServer builder with application/json body
func NewAddRuntimeServerRequest(server string, parentName ParentName, body AddRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRuntimeServerRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddRuntimeServerRequestWithBody generates requests for AddRuntimeServer with any type of body
func NewAddRuntimeServerRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeServerRequest generates requests for DeleteRuntimeServer
func NewDeleteRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeServerRequest generates requests for GetRuntimeServer
func NewGetRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeServerRequest calls the generic ReplaceRuntimeServer builder with application/json body
func NewReplaceRuntimeServerRequest(server string, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeServerRequestWithBody(server, parentName, name, "application/json", bodyReader)
}

// NewReplaceRuntimeServerRequestWithBody generates requests for ReplaceRuntimeServer with any type of body
func NewReplaceRuntimeServerRequestWithBody(server string, parentName ParentName, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHaproxyProcessInfoRequest generates requests for GetHaproxyProcessInfo
func NewGetHaproxyProcessInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeMapFilesRequest generates requests for GetAllRuntimeMapFiles
func NewGetAllRuntimeMapFilesRequest(server string, params *GetAllRuntimeMapFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnmanaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unmanaged", runtime.ParamLocationQuery, *params.IncludeUnmanaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearRuntimeMapRequest generates requests for ClearRuntimeMap
func NewClearRuntimeMapRequest(server string, name string, params *ClearRuntimeMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forceDelete", runtime.ParamLocationQuery, *params.ForceDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneRuntimeMapRequest generates requests for GetOneRuntimeMap
func NewGetOneRuntimeMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPayloadRuntimeMapRequest calls the generic AddPayloadRuntimeMap builder with application/json body
func NewAddPayloadRuntimeMapRequest(server string, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeMapRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewAddPayloadRuntimeMapRequestWithBody generates requests for AddPayloadRuntimeMap with any type of body
func NewAddPayloadRuntimeMapRequestWithBody(server string, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowRuntimeMapRequest generates requests for ShowRuntimeMap
func NewShowRuntimeMapRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMapEntryRequest calls the generic AddMapEntry builder with application/json body
func NewAddMapEntryRequest(server string, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMapEntryRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewAddMapEntryRequestWithBody generates requests for AddMapEntry with any type of body
func NewAddMapEntryRequestWithBody(server string, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeMapEntryRequest generates requests for DeleteRuntimeMapEntry
func NewDeleteRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeMapEntryRequest generates requests for GetRuntimeMapEntry
func NewGetRuntimeMapEntryRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeMapEntryRequest calls the generic ReplaceRuntimeMapEntry builder with application/json body
func NewReplaceRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeMapEntryRequestWithBody(server, parentName, id, params, "application/json", bodyReader)
}

// NewReplaceRuntimeMapEntryRequestWithBody generates requests for ReplaceRuntimeMapEntry with any type of body
func NewReplaceRuntimeMapEntryRequestWithBody(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickTablesRequest generates requests for GetStickTables
func NewGetStickTablesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableRequest generates requests for GetStickTable
func NewGetStickTableRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableEntriesRequest generates requests for GetStickTableEntries
func NewGetStickTableEntriesRequest(server string, parentName ParentName, params *GetStickTableEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetStickTableEntriesRequest calls the generic SetStickTableEntries builder with application/json body
func NewSetStickTableEntriesRequest(server string, parentName ParentName, body SetStickTableEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetStickTableEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewSetStickTableEntriesRequestWithBody generates requests for SetStickTableEntries with any type of body
func NewSetStickTableEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSitesRequest generates requests for GetSites
func NewGetSitesRequest(server string, params *GetSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, params *CreateSiteParams, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, params *CreateSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteRequest generates requests for DeleteSite
func NewDeleteSiteRequest(server string, name string, params *DeleteSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string, name string, params *GetSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSiteRequest calls the generic ReplaceSite builder with application/json body
func NewReplaceSiteRequest(server string, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSiteRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceSiteRequestWithBody generates requests for ReplaceSite with any type of body
func NewReplaceSiteRequestWithBody(server string, name string, params *ReplaceSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSpoeEndpointsRequest generates requests for GetSpoeEndpoints
func NewGetSpoeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeFilesRequest generates requests for GetAllSpoeFiles
func NewGetAllSpoeFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeRequestWithBody generates requests for CreateSpoe with any type of body
func NewCreateSpoeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeFileRequest generates requests for DeleteSpoeFile
func NewDeleteSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneSpoeFileRequest generates requests for GetOneSpoeFile
func NewGetOneSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeScopeRequest generates requests for GetAllSpoeScope
func NewGetAllSpoeScopeRequest(server string, parentName ParentName, params *GetAllSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeScopeRequest calls the generic CreateSpoeScope builder with application/json body
func NewCreateSpoeScopeRequest(server string, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeScopeRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateSpoeScopeRequestWithBody generates requests for CreateSpoeScope with any type of body
func NewCreateSpoeScopeRequestWithBody(server string, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeScopeRequest generates requests for DeleteSpoeScope
func NewDeleteSpoeScopeRequest(server string, parentName ParentName, name string, params *DeleteSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeScopeRequest generates requests for GetSpoeScope
func NewGetSpoeScopeRequest(server string, parentName ParentName, name string, params *GetSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeAgentRequest generates requests for GetAllSpoeAgent
func NewGetAllSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeAgentRequest calls the generic CreateSpoeAgent builder with application/json body
func NewCreateSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeAgentRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeAgentRequestWithBody generates requests for CreateSpoeAgent with any type of body
func NewCreateSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeAgentRequest generates requests for DeleteSpoeAgent
func NewDeleteSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeAgentRequest generates requests for GetSpoeAgent
func NewGetSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeAgentRequest calls the generic ReplaceSpoeAgent builder with application/json body
func NewReplaceSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeAgentRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeAgentRequestWithBody generates requests for ReplaceSpoeAgent with any type of body
func NewReplaceSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeGroupRequest generates requests for GetAllSpoeGroup
func NewGetAllSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeGroupRequest calls the generic CreateSpoeGroup builder with application/json body
func NewCreateSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeGroupRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeGroupRequestWithBody generates requests for CreateSpoeGroup with any type of body
func NewCreateSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeGroupRequest generates requests for DeleteSpoeGroup
func NewDeleteSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeGroupRequest generates requests for GetSpoeGroup
func NewGetSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeGroupRequest calls the generic ReplaceSpoeGroup builder with application/json body
func NewReplaceSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeGroupRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeGroupRequestWithBody generates requests for ReplaceSpoeGroup with any type of body
func NewReplaceSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeMessageRequest generates requests for GetAllSpoeMessage
func NewGetAllSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeMessageRequest calls the generic CreateSpoeMessage builder with application/json body
func NewCreateSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeMessageRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeMessageRequestWithBody generates requests for CreateSpoeMessage with any type of body
func NewCreateSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeMessageRequest generates requests for DeleteSpoeMessage
func NewDeleteSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeMessageRequest generates requests for GetSpoeMessage
func NewGetSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeMessageRequest calls the generic ReplaceSpoeMessage builder with application/json body
func NewReplaceSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeMessageRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeMessageRequestWithBody generates requests for ReplaceSpoeMessage with any type of body
func NewReplaceSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeTransactionRequest generates requests for GetAllSpoeTransaction
func NewGetAllSpoeTransactionRequest(server string, parentName ParentName, params *GetAllSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartSpoeTransactionRequest generates requests for StartSpoeTransaction
func NewStartSpoeTransactionRequest(server string, parentName ParentName, params *StartSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpoeTransactionRequest generates requests for DeleteSpoeTransaction
func NewDeleteSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeTransactionRequest generates requests for GetSpoeTransaction
func NewGetSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitSpoeTransactionRequest generates requests for CommitSpoeTransaction
func NewCommitSpoeTransactionRequest(server string, parentName ParentName, id string, params *CommitSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeConfigurationVersionRequest generates requests for GetSpoeConfigurationVersion
func NewGetSpoeConfigurationVersionRequest(server string, parentName ParentName, params *GetSpoeConfigurationVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/%s/version", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsEndpointsRequest generates requests for GetStatsEndpoints
func NewGetStatsEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, params *GetStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats/native")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageEndpointsRequest generates requests for GetStorageEndpoints
func NewGetStorageEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllStorageGeneralFilesRequest generates requests for GetAllStorageGeneralFiles
func NewGetAllStorageGeneralFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageGeneralFileRequestWithBody generates requests for CreateStorageGeneralFile with any type of body
func NewCreateStorageGeneralFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageGeneralFileRequest generates requests for DeleteStorageGeneralFile
func NewDeleteStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageGeneralFileRequest generates requests for GetOneStorageGeneralFile
func NewGetOneStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageGeneralFileRequestWithBody generates requests for ReplaceStorageGeneralFile with any type of body
func NewReplaceStorageGeneralFileRequestWithBody(server string, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageMapFilesRequest generates requests for GetAllStorageMapFiles
func NewGetAllStorageMapFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageMapFileRequestWithBody generates requests for CreateStorageMapFile with any type of body
func NewCreateStorageMapFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageMapRequest generates requests for DeleteStorageMap
func NewDeleteStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageMapRequest generates requests for GetOneStorageMap
func NewGetOneStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageMapFileRequestWithTextBody calls the generic ReplaceStorageMapFile builder with text/plain body
func NewReplaceStorageMapFileRequestWithTextBody(server string, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageMapFileRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageMapFileRequestWithBody generates requests for ReplaceStorageMapFile with any type of body
func NewReplaceStorageMapFileRequestWithBody(server string, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageSSLCertificatesRequest generates requests for GetAllStorageSSLCertificates
func NewGetAllStorageSSLCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageSSLCertificateRequestWithBody generates requests for CreateStorageSSLCertificate with any type of body
func NewCreateStorageSSLCertificateRequestWithBody(server string, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageSSLCertificateRequest generates requests for DeleteStorageSSLCertificate
func NewDeleteStorageSSLCertificateRequest(server string, name string, params *DeleteStorageSSLCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageSSLCertificateRequest generates requests for GetOneStorageSSLCertificate
func NewGetOneStorageSSLCertificateRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageSSLCertificateRequestWithTextBody calls the generic ReplaceStorageSSLCertificate builder with text/plain body
func NewReplaceStorageSSLCertificateRequestWithTextBody(server string, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageSSLCertificateRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageSSLCertificateRequestWithBody generates requests for ReplaceStorageSSLCertificate with any type of body
func NewReplaceStorageSSLCertificateRequestWithBody(server string, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartTransactionRequest generates requests for StartTransaction
func NewStartTransactionRequest(server string, params *StartTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitTransactionRequest generates requests for CommitTransaction
func NewCommitTransactionRequest(server string, id string, params *CommitTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpecificationRequest generates requests for GetSpecification
func NewGetSpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiv3SpecificationRequest generates requests for GetOpenapiv3Specification
func NewGetOpenapiv3SpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification_openapiv3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAPIEndpointsWithResponse request
	GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// PostClusterWithBodyWithResponse request with any body
	PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	// EditClusterWithBodyWithResponse request with any body
	EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	// InitiateCertificateRefreshWithResponse request
	InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetInfoWithResponse request
	GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error)

	// GetAWSRegionsWithResponse request
	GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error)

	// CreateAWSRegionWithBodyWithResponse request with any body
	CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	// DeleteAWSRegionWithResponse request
	DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error)

	// GetAWSRegionWithResponse request
	GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error)

	// ReplaceAWSRegionWithBodyWithResponse request with any body
	ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	// GetConsulsWithResponse request
	GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error)

	// CreateConsulWithBodyWithResponse request with any body
	CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	// DeleteConsulWithResponse request
	DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error)

	// GetConsulWithResponse request
	GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error)

	// ReplaceConsulWithBodyWithResponse request with any body
	ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	// GetServicesEndpointsWithResponse request
	GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error)

	// GetHaproxyEndpointsWithResponse request
	GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error)

	// GetConfigurationEndpointsWithResponse request
	GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error)

	// GetBackendsWithResponse request
	GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error)

	// CreateBackendWithBodyWithResponse request with any body
	CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	// DeleteBackendWithResponse request
	DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error)

	// GetBackendWithResponse request
	GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error)

	// ReplaceBackendWithBodyWithResponse request with any body
	ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	// GetAllAclBackendWithResponse request
	GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error)

	// ReplaceAllAclBackendWithBodyWithResponse request with any body
	ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	// DeleteAclBackendWithResponse request
	DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error)

	// GetAclBackendWithResponse request
	GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error)

	// CreateAclBackendWithBodyWithResponse request with any body
	CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	// ReplaceAclBackendWithBodyWithResponse request with any body
	ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	// GetAllFilterBackendWithResponse request
	GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error)

	// ReplaceAllFilterBackendWithBodyWithResponse request with any body
	ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	// DeleteFilterBackendWithResponse request
	DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error)

	// GetFilterBackendWithResponse request
	GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error)

	// CreateFilterBackendWithBodyWithResponse request with any body
	CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	// ReplaceFilterBackendWithBodyWithResponse request with any body
	ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	// GetAllHTTPAfterResponseRuleBackendWithResponse request
	GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	// DeleteHTTPAfterResponseRuleBackendWithResponse request
	DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error)

	// GetHTTPAfterResponseRuleBackendWithResponse request
	GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error)

	// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	// GetAllHTTPCheckBackendWithResponse request
	GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error)

	// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	// DeleteHTTPCheckBackendWithResponse request
	DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error)

	// GetHTTPCheckBackendWithResponse request
	GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error)

	// CreateHTTPCheckBackendWithBodyWithResponse request with any body
	CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	// ReplaceHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	// GetAllHTTPErrorRuleBackendWithResponse request
	GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error)

	// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	// DeleteHTTPErrorRuleBackendWithResponse request
	DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error)

	// GetHTTPErrorRuleBackendWithResponse request
	GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error)

	// CreateHTTPErrorRuleBackendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	// GetAllHTTPRequestRuleBackendWithResponse request
	GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error)

	// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	// DeleteHTTPRequestRuleBackendWithResponse request
	DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error)

	// GetHTTPRequestRuleBackendWithResponse request
	GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error)

	// CreateHTTPRequestRuleBackendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	// GetAllHTTPResponseRuleBackendWithResponse request
	GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error)

	// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	// DeleteHTTPResponseRuleBackendWithResponse request
	DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error)

	// GetHTTPResponseRuleBackendWithResponse request
	GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error)

	// CreateHTTPResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	// GetAllLogTargetBackendWithResponse request
	GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error)

	// ReplaceAllLogTargetBackendWithBodyWithResponse request with any body
	ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	// DeleteLogTargetBackendWithResponse request
	DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error)

	// GetLogTargetBackendWithResponse request
	GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error)

	// CreateLogTargetBackendWithBodyWithResponse request with any body
	CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	// ReplaceLogTargetBackendWithBodyWithResponse request with any body
	ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	// GetServerSwitchingRulesWithResponse request
	GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error)

	// ReplaceServerSwitchingRulesWithBodyWithResponse request with any body
	ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	// DeleteServerSwitchingRuleWithResponse request
	DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error)

	// GetServerSwitchingRuleWithResponse request
	GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error)

	// CreateServerSwitchingRuleWithBodyWithResponse request with any body
	CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	// ReplaceServerSwitchingRuleWithBodyWithResponse request with any body
	ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	// GetServerTemplatesWithResponse request
	GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error)

	// CreateServerTemplateWithBodyWithResponse request with any body
	CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	// DeleteServerTemplateWithResponse request
	DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error)

	// GetServerTemplateWithResponse request
	GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error)

	// ReplaceServerTemplateWithBodyWithResponse request with any body
	ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	// GetAllServerBackendWithResponse request
	GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error)

	// CreateServerBackendWithBodyWithResponse request with any body
	CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	// DeleteServerBackendWithResponse request
	DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error)

	// GetServerBackendWithResponse request
	GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error)

	// ReplaceServerBackendWithBodyWithResponse request with any body
	ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	// GetStickRulesWithResponse request
	GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error)

	// ReplaceStickRulesWithBodyWithResponse request with any body
	ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	// DeleteStickRuleWithResponse request
	DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error)

	// GetStickRuleWithResponse request
	GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error)

	// CreateStickRuleWithBodyWithResponse request with any body
	CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	// ReplaceStickRuleWithBodyWithResponse request with any body
	ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	// GetAllTCPCheckBackendWithResponse request
	GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error)

	// ReplaceAllTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	// DeleteTCPCheckBackendWithResponse request
	DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error)

	// GetTCPCheckBackendWithResponse request
	GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error)

	// CreateTCPCheckBackendWithBodyWithResponse request with any body
	CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	// ReplaceTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	// GetAllTCPRequestRuleBackendWithResponse request
	GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error)

	// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	// DeleteTCPRequestRuleBackendWithResponse request
	DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error)

	// GetTCPRequestRuleBackendWithResponse request
	GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error)

	// CreateTCPRequestRuleBackendWithBodyWithResponse request with any body
	CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	// GetAllTCPResponseRuleBackendWithResponse request
	GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error)

	// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	// DeleteTCPResponseRuleBackendWithResponse request
	DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error)

	// GetTCPResponseRuleBackendWithResponse request
	GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error)

	// CreateTCPResponseRuleBackendWithBodyWithResponse request with any body
	CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	// GetCachesWithResponse request
	GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error)

	// CreateCacheWithBodyWithResponse request with any body
	CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	// DeleteCacheWithResponse request
	DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error)

	// GetCacheWithResponse request
	GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error)

	// ReplaceCacheWithBodyWithResponse request with any body
	ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	// GetCrtLoadsWithResponse request
	GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error)

	// CreateCrtLoadWithBodyWithResponse request with any body
	CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	// DeleteCrtLoadWithResponse request
	DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error)

	// GetCrtLoadWithResponse request
	GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error)

	// ReplaceCrtLoadWithBodyWithResponse request with any body
	ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	// GetCrtStoresWithResponse request
	GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error)

	// CreateCrtStoreWithBodyWithResponse request with any body
	CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	// DeleteCrtStoreWithResponse request
	DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error)

	// GetCrtStoreWithResponse request
	GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error)

	// EditCrtStoreWithBodyWithResponse request with any body
	EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	// GetDefaultsSectionsWithResponse request
	GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error)

	// AddDefaultsSectionWithBodyWithResponse request with any body
	AddDefaultsSectionWithBodyWithResponse(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error)

	AddDefaultsSectionWithResponse(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error)

	// CreateDefaultsSectionWithBodyWithResponse request with any body
	CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	// DeleteDefaultsSectionWithResponse request
	DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error)

	// GetDefaultsSectionWithResponse request
	GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error)

	// ReplaceDefaultsSectionWithBodyWithResponse request with any body
	ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	// GetAllHTTPCheckDefaultsWithResponse request
	GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error)

	// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	// DeleteHTTPCheckDefaultsWithResponse request
	DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error)

	// GetHTTPCheckDefaultsWithResponse request
	GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error)

	// CreateHTTPCheckDefaultsWithBodyWithResponse request with any body
	CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	// GetAllHTTPErrorRuleDefaultsWithResponse request
	GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	// DeleteHTTPErrorRuleDefaultsWithResponse request
	DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error)

	// GetHTTPErrorRuleDefaultsWithResponse request
	GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error)

	// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	// GetAllLogTargetDefaultsWithResponse request
	GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error)

	// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	// DeleteLogTargetDefaultsWithResponse request
	DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error)

	// GetLogTargetDefaultsWithResponse request
	GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error)

	// CreateLogTargetDefaultsWithBodyWithResponse request with any body
	CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	// ReplaceLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	// GetAllQUICInitialRuleDefaultsWithResponse request
	GetAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleDefaultsResponse, error)

	// ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error)

	ReplaceAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error)

	// DeleteQUICInitialRuleDefaultsWithResponse request
	DeleteQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleDefaultsResponse, error)

	// GetQUICInitialRuleDefaultsWithResponse request
	GetQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleDefaultsResponse, error)

	// CreateQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	CreateQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error)

	CreateQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error)

	// ReplaceQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	ReplaceQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error)

	ReplaceQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error)

	// GetAllTCPCheckDefaultsWithResponse request
	GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error)

	// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	// DeleteTCPCheckDefaultsWithResponse request
	DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error)

	// GetTCPCheckDefaultsWithResponse request
	GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error)

	// CreateTCPCheckDefaultsWithBodyWithResponse request with any body
	CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	// ReplaceTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	// GetFCGIAppsWithResponse request
	GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error)

	// CreateFCGIAppWithBodyWithResponse request with any body
	CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	// DeleteFCGIAppWithResponse request
	DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error)

	// GetFCGIAppWithResponse request
	GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error)

	// ReplaceFCGIAppWithBodyWithResponse request with any body
	ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	// GetAllAclFCGIAppWithResponse request
	GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error)

	// ReplaceAllAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	// DeleteAclFCGIAppWithResponse request
	DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error)

	// GetAclFCGIAppWithResponse request
	GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error)

	// CreateAclFCGIAppWithBodyWithResponse request with any body
	CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	// ReplaceAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	// GetFrontendsWithResponse request
	GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error)

	// CreateFrontendWithBodyWithResponse request with any body
	CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	// DeleteFrontendWithResponse request
	DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error)

	// GetFrontendWithResponse request
	GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error)

	// ReplaceFrontendWithBodyWithResponse request with any body
	ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	// GetAllAclFrontendWithResponse request
	GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error)

	// ReplaceAllAclFrontendWithBodyWithResponse request with any body
	ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	// DeleteAclFrontendWithResponse request
	DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error)

	// GetAclFrontendWithResponse request
	GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error)

	// CreateAclFrontendWithBodyWithResponse request with any body
	CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	// ReplaceAclFrontendWithBodyWithResponse request with any body
	ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	// GetBackendSwitchingRulesWithResponse request
	GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error)

	// ReplaceBackendSwitchingRulesWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	// DeleteBackendSwitchingRuleWithResponse request
	DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error)

	// GetBackendSwitchingRuleWithResponse request
	GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error)

	// CreateBackendSwitchingRuleWithBodyWithResponse request with any body
	CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	// ReplaceBackendSwitchingRuleWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	// GetAllBindFrontendWithResponse request
	GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error)

	// CreateBindFrontendWithBodyWithResponse request with any body
	CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	// DeleteBindFrontendWithResponse request
	DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error)

	// GetBindFrontendWithResponse request
	GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error)

	// ReplaceBindFrontendWithBodyWithResponse request with any body
	ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	// GetDeclareCapturesWithResponse request
	GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error)

	// ReplaceDeclareCapturesWithBodyWithResponse request with any body
	ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	// DeleteDeclareCaptureWithResponse request
	DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error)

	// GetDeclareCaptureWithResponse request
	GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error)

	// CreateDeclareCaptureWithBodyWithResponse request with any body
	CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	// ReplaceDeclareCaptureWithBodyWithResponse request with any body
	ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	// GetAllFilterFrontendWithResponse request
	GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error)

	// ReplaceAllFilterFrontendWithBodyWithResponse request with any body
	ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	// DeleteFilterFrontendWithResponse request
	DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error)

	// GetFilterFrontendWithResponse request
	GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error)

	// CreateFilterFrontendWithBodyWithResponse request with any body
	CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	// ReplaceFilterFrontendWithBodyWithResponse request with any body
	ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	// GetAllHTTPAfterResponseRuleFrontendWithResponse request
	GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	// DeleteHTTPAfterResponseRuleFrontendWithResponse request
	DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error)

	// GetHTTPAfterResponseRuleFrontendWithResponse request
	GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error)

	// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	// GetAllHTTPErrorRuleFrontendWithResponse request
	GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	// DeleteHTTPErrorRuleFrontendWithResponse request
	DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error)

	// GetHTTPErrorRuleFrontendWithResponse request
	GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error)

	// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	// GetAllHTTPRequestRuleFrontendWithResponse request
	GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	// DeleteHTTPRequestRuleFrontendWithResponse request
	DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error)

	// GetHTTPRequestRuleFrontendWithResponse request
	GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error)

	// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	// GetAllHTTPResponseRuleFrontendWithResponse request
	GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	// DeleteHTTPResponseRuleFrontendWithResponse request
	DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error)

	// GetHTTPResponseRuleFrontendWithResponse request
	GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error)

	// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	// GetAllLogTargetFrontendWithResponse request
	GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error)

	// ReplaceAllLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	// DeleteLogTargetFrontendWithResponse request
	DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error)

	// GetLogTargetFrontendWithResponse request
	GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error)

	// CreateLogTargetFrontendWithBodyWithResponse request with any body
	CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	// ReplaceLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	// GetAllQUICInitialRuleFrontendWithResponse request
	GetAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleFrontendResponse, error)

	// ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error)

	ReplaceAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error)

	// DeleteQUICInitialRuleFrontendWithResponse request
	DeleteQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleFrontendResponse, error)

	// GetQUICInitialRuleFrontendWithResponse request
	GetQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleFrontendResponse, error)

	// CreateQUICInitialRuleFrontendWithBodyWithResponse request with any body
	CreateQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error)

	CreateQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error)

	// ReplaceQUICInitialRuleFrontendWithBodyWithResponse request with any body
	ReplaceQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error)

	ReplaceQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error)

	// GetAllTCPRequestRuleFrontendWithResponse request
	GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error)

	// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	// DeleteTCPRequestRuleFrontendWithResponse request
	DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error)

	// GetTCPRequestRuleFrontendWithResponse request
	GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error)

	// CreateTCPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	// GetGlobalWithResponse request
	GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// ReplaceGlobalWithBodyWithResponse request with any body
	ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	// GetAllLogTargetGlobalWithResponse request
	GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error)

	// ReplaceAllLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	// DeleteLogTargetGlobalWithResponse request
	DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error)

	// GetLogTargetGlobalWithResponse request
	GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error)

	// CreateLogTargetGlobalWithBodyWithResponse request with any body
	CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	// ReplaceLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ReplaceGroupWithBodyWithResponse request with any body
	ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	// GetHTTPErrorsSectionsWithResponse request
	GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error)

	// CreateHTTPErrorsSectionWithBodyWithResponse request with any body
	CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	// DeleteHTTPErrorsSectionWithResponse request
	DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error)

	// GetHTTPErrorsSectionWithResponse request
	GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error)

	// ReplaceHTTPErrorsSectionWithBodyWithResponse request with any body
	ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	// GetLogForwardsWithResponse request
	GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error)

	// CreateLogForwardWithBodyWithResponse request with any body
	CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	// DeleteLogForwardWithResponse request
	DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error)

	// GetLogForwardWithResponse request
	GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error)

	// ReplaceLogForwardWithBodyWithResponse request with any body
	ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	// GetAllBindLogForwardWithResponse request
	GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error)

	// CreateBindLogForwardWithBodyWithResponse request with any body
	CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	// DeleteBindLogForwardWithResponse request
	DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error)

	// GetBindLogForwardWithResponse request
	GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error)

	// ReplaceBindLogForwardWithBodyWithResponse request with any body
	ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	// GetDgramBindsWithResponse request
	GetDgramBindsWithResponse(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*GetDgramBindsResponse, error)

	// CreateDgramBindWithBodyWithResponse request with any body
	CreateDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error)

	CreateDgramBindWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error)

	// DeleteDgramBindWithResponse request
	DeleteDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindResponse, error)

	// GetDgramBindWithResponse request
	GetDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*GetDgramBindResponse, error)

	// ReplaceDgramBindWithBodyWithResponse request with any body
	ReplaceDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error)

	ReplaceDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error)

	// GetAllLogTargetLogForwardWithResponse request
	GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error)

	// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	// DeleteLogTargetLogForwardWithResponse request
	DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error)

	// GetLogTargetLogForwardWithResponse request
	GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error)

	// CreateLogTargetLogForwardWithBodyWithResponse request with any body
	CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	// ReplaceLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	// GetLogProfilesWithResponse request
	GetLogProfilesWithResponse(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*GetLogProfilesResponse, error)

	// CreateLogProfileWithBodyWithResponse request with any body
	CreateLogProfileWithBodyWithResponse(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error)

	CreateLogProfileWithResponse(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error)

	// DeleteLogProfileWithResponse request
	DeleteLogProfileWithResponse(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*DeleteLogProfileResponse, error)

	// GetLogProfileWithResponse request
	GetLogProfileWithResponse(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*GetLogProfileResponse, error)

	// EditLogProfileWithBodyWithResponse request with any body
	EditLogProfileWithBodyWithResponse(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error)

	EditLogProfileWithResponse(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error)

	// GetMailerEntriesWithResponse request
	GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error)

	// CreateMailerEntryWithBodyWithResponse request with any body
	CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	// DeleteMailerEntryWithResponse request
	DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error)

	// GetMailerEntryWithResponse request
	GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error)

	// ReplaceMailerEntryWithBodyWithResponse request with any body
	ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	// GetMailersSectionsWithResponse request
	GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error)

	// CreateMailersSectionWithBodyWithResponse request with any body
	CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	// DeleteMailersSectionWithResponse request
	DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error)

	// GetMailersSectionWithResponse request
	GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error)

	// EditMailersSectionWithBodyWithResponse request with any body
	EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	// GetNameserversWithResponse request
	GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error)

	// CreateNameserverWithBodyWithResponse request with any body
	CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	// DeleteNameserverWithResponse request
	DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error)

	// GetNameserverWithResponse request
	GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error)

	// ReplaceNameserverWithBodyWithResponse request with any body
	ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	// GetPeerEntriesWithResponse request
	GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error)

	// CreatePeerEntryWithBodyWithResponse request with any body
	CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	// DeletePeerEntryWithResponse request
	DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error)

	// GetPeerEntryWithResponse request
	GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error)

	// ReplacePeerEntryWithBodyWithResponse request with any body
	ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	// GetPeerSectionsWithResponse request
	GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error)

	// CreatePeerWithBodyWithResponse request with any body
	CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	// DeletePeerWithResponse request
	DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error)

	// GetPeerSectionWithResponse request
	GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error)

	// GetAllBindPeerWithResponse request
	GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error)

	// CreateBindPeerWithBodyWithResponse request with any body
	CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	// DeleteBindPeerWithResponse request
	DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error)

	// GetBindPeerWithResponse request
	GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error)

	// ReplaceBindPeerWithBodyWithResponse request with any body
	ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	// GetAllLogTargetPeerWithResponse request
	GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error)

	// ReplaceAllLogTargetPeerWithBodyWithResponse request with any body
	ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	// DeleteLogTargetPeerWithResponse request
	DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error)

	// GetLogTargetPeerWithResponse request
	GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error)

	// CreateLogTargetPeerWithBodyWithResponse request with any body
	CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	// ReplaceLogTargetPeerWithBodyWithResponse request with any body
	ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	// GetAllServerPeerWithResponse request
	GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error)

	// CreateServerPeerWithBodyWithResponse request with any body
	CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	// DeleteServerPeerWithResponse request
	DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error)

	// GetServerPeerWithResponse request
	GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error)

	// ReplaceServerPeerWithBodyWithResponse request with any body
	ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// ReplaceTableWithBodyWithResponse request with any body
	ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	// GetProgramsWithResponse request
	GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	// CreateProgramWithBodyWithResponse request with any body
	CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	// DeleteProgramWithResponse request
	DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// ReplaceProgramWithBodyWithResponse request with any body
	ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	// GetHAProxyConfigurationWithResponse request
	GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error)

	// PostHAProxyConfigurationWithBodyWithResponse request with any body
	PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	// GetResolversWithResponse request
	GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error)

	// CreateResolverWithBodyWithResponse request with any body
	CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	// DeleteResolverWithResponse request
	DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error)

	// GetResolverWithResponse request
	GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error)

	// ReplaceResolverWithBodyWithResponse request with any body
	ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	// GetRingsWithResponse request
	GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error)

	// CreateRingWithBodyWithResponse request with any body
	CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	// DeleteRingWithResponse request
	DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error)

	// GetRingWithResponse request
	GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error)

	// ReplaceRingWithBodyWithResponse request with any body
	ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	// GetAllServerRingWithResponse request
	GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error)

	// CreateServerRingWithBodyWithResponse request with any body
	CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	// DeleteServerRingWithResponse request
	DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error)

	// GetServerRingWithResponse request
	GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error)

	// ReplaceServerRingWithBodyWithResponse request with any body
	ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	// DeleteTracesWithResponse request
	DeleteTracesWithResponse(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*DeleteTracesResponse, error)

	// GetTracesWithResponse request
	GetTracesWithResponse(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*GetTracesResponse, error)

	// CreateTracesWithBodyWithResponse request with any body
	CreateTracesWithBodyWithResponse(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error)

	CreateTracesWithResponse(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error)

	// ReplaceTracesWithBodyWithResponse request with any body
	ReplaceTracesWithBodyWithResponse(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error)

	ReplaceTracesWithResponse(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error)

	// DeleteTraceEntryWithBodyWithResponse request with any body
	DeleteTraceEntryWithBodyWithResponse(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error)

	DeleteTraceEntryWithResponse(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error)

	// CreateTraceEntryWithBodyWithResponse request with any body
	CreateTraceEntryWithBodyWithResponse(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error)

	CreateTraceEntryWithResponse(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error)

	// GetUserlistsWithResponse request
	GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error)

	// CreateUserlistWithBodyWithResponse request with any body
	CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	// DeleteUserlistWithResponse request
	DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error)

	// GetUserlistWithResponse request
	GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ReplaceUserWithBodyWithResponse request with any body
	ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	// GetConfigurationVersionWithResponse request
	GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error)

	// GetReloadsWithResponse request
	GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error)

	// GetReloadWithResponse request
	GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error)

	// GetRuntimeEndpointsWithResponse request
	GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error)

	// GetServicesHaproxyRuntimeAclsWithResponse request
	GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error)

	// GetServicesHaproxyRuntimeAclsIdWithResponse request
	GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// AddPayloadRuntimeACLWithBodyWithResponse request with any body
	AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetAllRuntimeServerWithResponse request
	GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error)

	// AddRuntimeServerWithBodyWithResponse request with any body
	AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	// DeleteRuntimeServerWithResponse request
	DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error)

	// GetRuntimeServerWithResponse request
	GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error)

	// ReplaceRuntimeServerWithBodyWithResponse request with any body
	ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	// GetHaproxyProcessInfoWithResponse request
	GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error)

	// GetAllRuntimeMapFilesWithResponse request
	GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error)

	// ClearRuntimeMapWithResponse request
	ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error)

	// GetOneRuntimeMapWithResponse request
	GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error)

	// AddPayloadRuntimeMapWithBodyWithResponse request with any body
	AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	// ShowRuntimeMapWithResponse request
	ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error)

	// AddMapEntryWithBodyWithResponse request with any body
	AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	// DeleteRuntimeMapEntryWithResponse request
	DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error)

	// GetRuntimeMapEntryWithResponse request
	GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error)

	// ReplaceRuntimeMapEntryWithBodyWithResponse request with any body
	ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	// GetStickTablesWithResponse request
	GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error)

	// GetStickTableWithResponse request
	GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error)

	// GetStickTableEntriesWithResponse request
	GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error)

	// SetStickTableEntriesWithBodyWithResponse request with any body
	SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	// GetSitesWithResponse request
	GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	// DeleteSiteWithResponse request
	DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error)

	// ReplaceSiteWithBodyWithResponse request with any body
	ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	// GetSpoeEndpointsWithResponse request
	GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error)

	// GetAllSpoeFilesWithResponse request
	GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error)

	// CreateSpoeWithBodyWithResponse request with any body
	CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error)

	// DeleteSpoeFileWithResponse request
	DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error)

	// GetOneSpoeFileWithResponse request
	GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error)

	// GetAllSpoeScopeWithResponse request
	GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error)

	// CreateSpoeScopeWithBodyWithResponse request with any body
	CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	// DeleteSpoeScopeWithResponse request
	DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error)

	// GetSpoeScopeWithResponse request
	GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error)

	// GetAllSpoeAgentWithResponse request
	GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error)

	// CreateSpoeAgentWithBodyWithResponse request with any body
	CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	// DeleteSpoeAgentWithResponse request
	DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error)

	// GetSpoeAgentWithResponse request
	GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error)

	// ReplaceSpoeAgentWithBodyWithResponse request with any body
	ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	// GetAllSpoeGroupWithResponse request
	GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error)

	// CreateSpoeGroupWithBodyWithResponse request with any body
	CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	// DeleteSpoeGroupWithResponse request
	DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error)

	// GetSpoeGroupWithResponse request
	GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error)

	// ReplaceSpoeGroupWithBodyWithResponse request with any body
	ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	// GetAllSpoeMessageWithResponse request
	GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error)

	// CreateSpoeMessageWithBodyWithResponse request with any body
	CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	// DeleteSpoeMessageWithResponse request
	DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error)

	// GetSpoeMessageWithResponse request
	GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error)

	// ReplaceSpoeMessageWithBodyWithResponse request with any body
	ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	// GetAllSpoeTransactionWithResponse request
	GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error)

	// StartSpoeTransactionWithResponse request
	StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error)

	// DeleteSpoeTransactionWithResponse request
	DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error)

	// GetSpoeTransactionWithResponse request
	GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error)

	// CommitSpoeTransactionWithResponse request
	CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error)

	// GetSpoeConfigurationVersionWithResponse request
	GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error)

	// GetStatsEndpointsWithResponse request
	GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetStorageEndpointsWithResponse request
	GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error)

	// GetAllStorageGeneralFilesWithResponse request
	GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error)

	// CreateStorageGeneralFileWithBodyWithResponse request with any body
	CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error)

	// DeleteStorageGeneralFileWithResponse request
	DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error)

	// GetOneStorageGeneralFileWithResponse request
	GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error)

	// ReplaceStorageGeneralFileWithBodyWithResponse request with any body
	ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error)

	// GetAllStorageMapFilesWithResponse request
	GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error)

	// CreateStorageMapFileWithBodyWithResponse request with any body
	CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error)

	// DeleteStorageMapWithResponse request
	DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error)

	// GetOneStorageMapWithResponse request
	GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error)

	// ReplaceStorageMapFileWithBodyWithResponse request with any body
	ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	// GetAllStorageSSLCertificatesWithResponse request
	GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error)

	// CreateStorageSSLCertificateWithBodyWithResponse request with any body
	CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error)

	// DeleteStorageSSLCertificateWithResponse request
	DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error)

	// GetOneStorageSSLCertificateWithResponse request
	GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error)

	// ReplaceStorageSSLCertificateWithBodyWithResponse request with any body
	ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	// GetTransactionsWithResponse request
	GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// StartTransactionWithResponse request
	StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error)

	// DeleteTransactionWithResponse request
	DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransactionWithResponse request
	GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// CommitTransactionWithResponse request
	CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	// GetSpecificationWithResponse request
	GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error)

	// GetOpenapiv3SpecificationWithResponse request
	GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error)
}

type GetAPIEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAPIEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCertificateRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r InitiateCertificateRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCertificateRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Health
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Info
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AwsRegion
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consuls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Consul
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSON202      *ServerSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplates
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSON202      *StickRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSON202      *TcpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Caches
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStores
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DefaultsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSON202      *QUICInitialRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FcgiApps
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSON202      *BackendSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSON202      *Captures
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSON202      *QUICInitialRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSON202      *Global
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Groups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForwards
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBinds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogProfile
	JSON202      *LogProfile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfile
	JSON202      *LogProfile
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameservers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplacePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplacePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplacePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerSection
	JSON202      *PeerSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Programs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolvers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Traces
	JSON202      *Traces
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON202      *Traces
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTraceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTraceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTraceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTraceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TraceEntry
	JSON202      *TraceEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTraceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTraceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Userlist
	JSON202      *Userlist
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlist
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Users
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reloads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reload
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFilesEntries
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFileEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFilesEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFileEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RuntimeAddServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyProcessInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessInfo
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyProcessInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyProcessInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ClearRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Map
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntries
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ShowRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTable
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTableEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r SetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sites
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *string `json:"data,omitempty"`
	}
	JSON404     *NotFound
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScopes
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeScope
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScope
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgents
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeAgent
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeGroup
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessages
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeMessage
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeTransaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON202      *SpoeTransaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NativeStats
	JSON500      *NativeStats
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStorageEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageGeneralFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeneralFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageGeneralFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageGeneralFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GeneralFile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Map
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageSSLCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificates
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageSSLCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageSSLCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Transaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON202      *Transaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON406      *NotAcceptable
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiv3SpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOpenapiv3SpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiv3SpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAPIEndpointsWithResponse request returning *GetAPIEndpointsResponse
func (c *ClientWithResponses) GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error) {
	rsp, err := c.GetAPIEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIEndpointsResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// PostClusterWithBodyWithResponse request with arbitrary body returning *PostClusterResponse
func (c *ClientWithResponses) PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

func (c *ClientWithResponses) PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

// EditClusterWithBodyWithResponse request with arbitrary body returning *EditClusterResponse
func (c *ClientWithResponses) EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

func (c *ClientWithResponses) EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

// InitiateCertificateRefreshWithResponse request returning *InitiateCertificateRefreshResponse
func (c *ClientWithResponses) InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error) {
	rsp, err := c.InitiateCertificateRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCertificateRefreshResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetInfoWithResponse request returning *GetInfoResponse
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error) {
	rsp, err := c.GetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoResponse(rsp)
}

// GetAWSRegionsWithResponse request returning *GetAWSRegionsResponse
func (c *ClientWithResponses) GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error) {
	rsp, err := c.GetAWSRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionsResponse(rsp)
}

// CreateAWSRegionWithBodyWithResponse request with arbitrary body returning *CreateAWSRegionResponse
func (c *ClientWithResponses) CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

// DeleteAWSRegionWithResponse request returning *DeleteAWSRegionResponse
func (c *ClientWithResponses) DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error) {
	rsp, err := c.DeleteAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAWSRegionResponse(rsp)
}

// GetAWSRegionWithResponse request returning *GetAWSRegionResponse
func (c *ClientWithResponses) GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error) {
	rsp, err := c.GetAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionResponse(rsp)
}

// ReplaceAWSRegionWithBodyWithResponse request with arbitrary body returning *ReplaceAWSRegionResponse
func (c *ClientWithResponses) ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegion(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

// GetConsulsWithResponse request returning *GetConsulsResponse
func (c *ClientWithResponses) GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error) {
	rsp, err := c.GetConsuls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulsResponse(rsp)
}

// CreateConsulWithBodyWithResponse request with arbitrary body returning *CreateConsulResponse
func (c *ClientWithResponses) CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsulWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

func (c *ClientWithResponses) CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsul(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

// DeleteConsulWithResponse request returning *DeleteConsulResponse
func (c *ClientWithResponses) DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error) {
	rsp, err := c.DeleteConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConsulResponse(rsp)
}

// GetConsulWithResponse request returning *GetConsulResponse
func (c *ClientWithResponses) GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error) {
	rsp, err := c.GetConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulResponse(rsp)
}

// ReplaceConsulWithBodyWithResponse request with arbitrary body returning *ReplaceConsulResponse
func (c *ClientWithResponses) ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsulWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

func (c *ClientWithResponses) ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsul(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

// GetServicesEndpointsWithResponse request returning *GetServicesEndpointsResponse
func (c *ClientWithResponses) GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error) {
	rsp, err := c.GetServicesEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesEndpointsResponse(rsp)
}

// GetHaproxyEndpointsWithResponse request returning *GetHaproxyEndpointsResponse
func (c *ClientWithResponses) GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error) {
	rsp, err := c.GetHaproxyEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyEndpointsResponse(rsp)
}

// GetConfigurationEndpointsWithResponse request returning *GetConfigurationEndpointsResponse
func (c *ClientWithResponses) GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error) {
	rsp, err := c.GetConfigurationEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationEndpointsResponse(rsp)
}

// GetBackendsWithResponse request returning *GetBackendsResponse
func (c *ClientWithResponses) GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error) {
	rsp, err := c.GetBackends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendsResponse(rsp)
}

// CreateBackendWithBodyWithResponse request with arbitrary body returning *CreateBackendResponse
func (c *ClientWithResponses) CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

// DeleteBackendWithResponse request returning *DeleteBackendResponse
func (c *ClientWithResponses) DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error) {
	rsp, err := c.DeleteBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendResponse(rsp)
}

// GetBackendWithResponse request returning *GetBackendResponse
func (c *ClientWithResponses) GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error) {
	rsp, err := c.GetBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendResponse(rsp)
}

// ReplaceBackendWithBodyWithResponse request with arbitrary body returning *ReplaceBackendResponse
func (c *ClientWithResponses) ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

// GetAllAclBackendWithResponse request returning *GetAllAclBackendResponse
func (c *ClientWithResponses) GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error) {
	rsp, err := c.GetAllAclBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclBackendResponse(rsp)
}

// ReplaceAllAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclBackendResponse
func (c *ClientWithResponses) ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

// DeleteAclBackendWithResponse request returning *DeleteAclBackendResponse
func (c *ClientWithResponses) DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error) {
	rsp, err := c.DeleteAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclBackendResponse(rsp)
}

// GetAclBackendWithResponse request returning *GetAclBackendResponse
func (c *ClientWithResponses) GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error) {
	rsp, err := c.GetAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclBackendResponse(rsp)
}

// CreateAclBackendWithBodyWithResponse request with arbitrary body returning *CreateAclBackendResponse
func (c *ClientWithResponses) CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

// ReplaceAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAclBackendResponse
func (c *ClientWithResponses) ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

// GetAllFilterBackendWithResponse request returning *GetAllFilterBackendResponse
func (c *ClientWithResponses) GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error) {
	rsp, err := c.GetAllFilterBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterBackendResponse(rsp)
}

// ReplaceAllFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterBackendResponse
func (c *ClientWithResponses) ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

// DeleteFilterBackendWithResponse request returning *DeleteFilterBackendResponse
func (c *ClientWithResponses) DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error) {
	rsp, err := c.DeleteFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterBackendResponse(rsp)
}

// GetFilterBackendWithResponse request returning *GetFilterBackendResponse
func (c *ClientWithResponses) GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error) {
	rsp, err := c.GetFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterBackendResponse(rsp)
}

// CreateFilterBackendWithBodyWithResponse request with arbitrary body returning *CreateFilterBackendResponse
func (c *ClientWithResponses) CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

// ReplaceFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterBackendResponse
func (c *ClientWithResponses) ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleBackendWithResponse request returning *GetAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleBackendWithResponse request returning *DeleteHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetHTTPAfterResponseRuleBackendWithResponse request returning *GetHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleBackendResponse(rsp)
}

// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetAllHTTPCheckBackendWithResponse request returning *GetAllHTTPCheckBackendResponse
func (c *ClientWithResponses) GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error) {
	rsp, err := c.GetAllHTTPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckBackendResponse(rsp)
}

// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

// DeleteHTTPCheckBackendWithResponse request returning *DeleteHTTPCheckBackendResponse
func (c *ClientWithResponses) DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error) {
	rsp, err := c.DeleteHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckBackendResponse(rsp)
}

// GetHTTPCheckBackendWithResponse request returning *GetHTTPCheckBackendResponse
func (c *ClientWithResponses) GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error) {
	rsp, err := c.GetHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckBackendResponse(rsp)
}

// CreateHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckBackendResponse
func (c *ClientWithResponses) CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

// ReplaceHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

// GetAllHTTPErrorRuleBackendWithResponse request returning *GetAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

// DeleteHTTPErrorRuleBackendWithResponse request returning *DeleteHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleBackendResponse(rsp)
}

// GetHTTPErrorRuleBackendWithResponse request returning *GetHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleBackendResponse(rsp)
}

// CreateHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

// GetAllHTTPRequestRuleBackendWithResponse request returning *GetAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

// DeleteHTTPRequestRuleBackendWithResponse request returning *DeleteHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleBackendResponse(rsp)
}

// GetHTTPRequestRuleBackendWithResponse request returning *GetHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleBackendResponse(rsp)
}

// CreateHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

// GetAllHTTPResponseRuleBackendWithResponse request returning *GetAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

// DeleteHTTPResponseRuleBackendWithResponse request returning *DeleteHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleBackendResponse(rsp)
}

// GetHTTPResponseRuleBackendWithResponse request returning *GetHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleBackendResponse(rsp)
}

// CreateHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

// GetAllLogTargetBackendWithResponse request returning *GetAllLogTargetBackendResponse
func (c *ClientWithResponses) GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error) {
	rsp, err := c.GetAllLogTargetBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetBackendResponse(rsp)
}

// ReplaceAllLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

// DeleteLogTargetBackendWithResponse request returning *DeleteLogTargetBackendResponse
func (c *ClientWithResponses) DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error) {
	rsp, err := c.DeleteLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetBackendResponse(rsp)
}

// GetLogTargetBackendWithResponse request returning *GetLogTargetBackendResponse
func (c *ClientWithResponses) GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error) {
	rsp, err := c.GetLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetBackendResponse(rsp)
}

// CreateLogTargetBackendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetBackendResponse
func (c *ClientWithResponses) CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

// ReplaceLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

// GetServerSwitchingRulesWithResponse request returning *GetServerSwitchingRulesResponse
func (c *ClientWithResponses) GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error) {
	rsp, err := c.GetServerSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRulesResponse(rsp)
}

// ReplaceServerSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

// DeleteServerSwitchingRuleWithResponse request returning *DeleteServerSwitchingRuleResponse
func (c *ClientWithResponses) DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error) {
	rsp, err := c.DeleteServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerSwitchingRuleResponse(rsp)
}

// GetServerSwitchingRuleWithResponse request returning *GetServerSwitchingRuleResponse
func (c *ClientWithResponses) GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error) {
	rsp, err := c.GetServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRuleResponse(rsp)
}

// CreateServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateServerSwitchingRuleResponse
func (c *ClientWithResponses) CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

// ReplaceServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

// GetServerTemplatesWithResponse request returning *GetServerTemplatesResponse
func (c *ClientWithResponses) GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error) {
	rsp, err := c.GetServerTemplates(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplatesResponse(rsp)
}

// CreateServerTemplateWithBodyWithResponse request with arbitrary body returning *CreateServerTemplateResponse
func (c *ClientWithResponses) CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplateWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplate(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

// DeleteServerTemplateWithResponse request returning *DeleteServerTemplateResponse
func (c *ClientWithResponses) DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error) {
	rsp, err := c.DeleteServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerTemplateResponse(rsp)
}

// GetServerTemplateWithResponse request returning *GetServerTemplateResponse
func (c *ClientWithResponses) GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error) {
	rsp, err := c.GetServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplateResponse(rsp)
}

// ReplaceServerTemplateWithBodyWithResponse request with arbitrary body returning *ReplaceServerTemplateResponse
func (c *ClientWithResponses) ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplateWithBody(ctx, parentName, prefix, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplate(ctx, parentName, prefix, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

// GetAllServerBackendWithResponse request returning *GetAllServerBackendResponse
func (c *ClientWithResponses) GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error) {
	rsp, err := c.GetAllServerBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerBackendResponse(rsp)
}

// CreateServerBackendWithBodyWithResponse request with arbitrary body returning *CreateServerBackendResponse
func (c *ClientWithResponses) CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

// DeleteServerBackendWithResponse request returning *DeleteServerBackendResponse
func (c *ClientWithResponses) DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error) {
	rsp, err := c.DeleteServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerBackendResponse(rsp)
}

// GetServerBackendWithResponse request returning *GetServerBackendResponse
func (c *ClientWithResponses) GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error) {
	rsp, err := c.GetServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerBackendResponse(rsp)
}

// ReplaceServerBackendWithBodyWithResponse request with arbitrary body returning *ReplaceServerBackendResponse
func (c *ClientWithResponses) ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

// GetStickRulesWithResponse request returning *GetStickRulesResponse
func (c *ClientWithResponses) GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error) {
	rsp, err := c.GetStickRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRulesResponse(rsp)
}

// ReplaceStickRulesWithBodyWithResponse request with arbitrary body returning *ReplaceStickRulesResponse
func (c *ClientWithResponses) ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

// DeleteStickRuleWithResponse request returning *DeleteStickRuleResponse
func (c *ClientWithResponses) DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error) {
	rsp, err := c.DeleteStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStickRuleResponse(rsp)
}

// GetStickRuleWithResponse request returning *GetStickRuleResponse
func (c *ClientWithResponses) GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error) {
	rsp, err := c.GetStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRuleResponse(rsp)
}

// CreateStickRuleWithBodyWithResponse request with arbitrary body returning *CreateStickRuleResponse
func (c *ClientWithResponses) CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

// ReplaceStickRuleWithBodyWithResponse request with arbitrary body returning *ReplaceStickRuleResponse
func (c *ClientWithResponses) ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

// GetAllTCPCheckBackendWithResponse request returning *GetAllTCPCheckBackendResponse
func (c *ClientWithResponses) GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error) {
	rsp, err := c.GetAllTCPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckBackendResponse(rsp)
}

// ReplaceAllTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

// DeleteTCPCheckBackendWithResponse request returning *DeleteTCPCheckBackendResponse
func (c *ClientWithResponses) DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error) {
	rsp, err := c.DeleteTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckBackendResponse(rsp)
}

// GetTCPCheckBackendWithResponse request returning *GetTCPCheckBackendResponse
func (c *ClientWithResponses) GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error) {
	rsp, err := c.GetTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckBackendResponse(rsp)
}

// CreateTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckBackendResponse
func (c *ClientWithResponses) CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

// ReplaceTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

// GetAllTCPRequestRuleBackendWithResponse request returning *GetAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleBackendResponse(rsp)
}

// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

// DeleteTCPRequestRuleBackendWithResponse request returning *DeleteTCPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleBackendResponse(rsp)
}

// GetTCPRequestRuleBackendWithResponse request returning *GetTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleBackendResponse(rsp)
}

// CreateTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

// GetAllTCPResponseRuleBackendWithResponse request returning *GetAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPResponseRuleBackendResponse(rsp)
}

// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

// DeleteTCPResponseRuleBackendWithResponse request returning *DeleteTCPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPResponseRuleBackendResponse(rsp)
}

// GetTCPResponseRuleBackendWithResponse request returning *GetTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPResponseRuleBackendResponse(rsp)
}

// CreateTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

// GetCachesWithResponse request returning *GetCachesResponse
func (c *ClientWithResponses) GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error) {
	rsp, err := c.GetCaches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCachesResponse(rsp)
}

// CreateCacheWithBodyWithResponse request with arbitrary body returning *CreateCacheResponse
func (c *ClientWithResponses) CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCacheWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

func (c *ClientWithResponses) CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCache(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

// DeleteCacheWithResponse request returning *DeleteCacheResponse
func (c *ClientWithResponses) DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error) {
	rsp, err := c.DeleteCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCacheResponse(rsp)
}

// GetCacheWithResponse request returning *GetCacheResponse
func (c *ClientWithResponses) GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error) {
	rsp, err := c.GetCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCacheResponse(rsp)
}

// ReplaceCacheWithBodyWithResponse request with arbitrary body returning *ReplaceCacheResponse
func (c *ClientWithResponses) ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCacheWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCache(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

// GetCrtLoadsWithResponse request returning *GetCrtLoadsResponse
func (c *ClientWithResponses) GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error) {
	rsp, err := c.GetCrtLoads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadsResponse(rsp)
}

// CreateCrtLoadWithBodyWithResponse request with arbitrary body returning *CreateCrtLoadResponse
func (c *ClientWithResponses) CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoad(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

// DeleteCrtLoadWithResponse request returning *DeleteCrtLoadResponse
func (c *ClientWithResponses) DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error) {
	rsp, err := c.DeleteCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtLoadResponse(rsp)
}

// GetCrtLoadWithResponse request returning *GetCrtLoadResponse
func (c *ClientWithResponses) GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error) {
	rsp, err := c.GetCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadResponse(rsp)
}

// ReplaceCrtLoadWithBodyWithResponse request with arbitrary body returning *ReplaceCrtLoadResponse
func (c *ClientWithResponses) ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoadWithBody(ctx, certificate, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoad(ctx, certificate, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

// GetCrtStoresWithResponse request returning *GetCrtStoresResponse
func (c *ClientWithResponses) GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error) {
	rsp, err := c.GetCrtStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoresResponse(rsp)
}

// CreateCrtStoreWithBodyWithResponse request with arbitrary body returning *CreateCrtStoreResponse
func (c *ClientWithResponses) CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStoreWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStore(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

// DeleteCrtStoreWithResponse request returning *DeleteCrtStoreResponse
func (c *ClientWithResponses) DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error) {
	rsp, err := c.DeleteCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtStoreResponse(rsp)
}

// GetCrtStoreWithResponse request returning *GetCrtStoreResponse
func (c *ClientWithResponses) GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error) {
	rsp, err := c.GetCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoreResponse(rsp)
}

// EditCrtStoreWithBodyWithResponse request with arbitrary body returning *EditCrtStoreResponse
func (c *ClientWithResponses) EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStoreWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStore(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

// GetDefaultsSectionsWithResponse request returning *GetDefaultsSectionsResponse
func (c *ClientWithResponses) GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error) {
	rsp, err := c.GetDefaultsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionsResponse(rsp)
}

// AddDefaultsSectionWithBodyWithResponse request with arbitrary body returning *AddDefaultsSectionResponse
func (c *ClientWithResponses) AddDefaultsSectionWithBodyWithResponse(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error) {
	rsp, err := c.AddDefaultsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) AddDefaultsSectionWithResponse(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error) {
	rsp, err := c.AddDefaultsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultsSectionResponse(rsp)
}

// CreateDefaultsSectionWithBodyWithResponse request with arbitrary body returning *CreateDefaultsSectionResponse
func (c *ClientWithResponses) CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

// DeleteDefaultsSectionWithResponse request returning *DeleteDefaultsSectionResponse
func (c *ClientWithResponses) DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error) {
	rsp, err := c.DeleteDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDefaultsSectionResponse(rsp)
}

// GetDefaultsSectionWithResponse request returning *GetDefaultsSectionResponse
func (c *ClientWithResponses) GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error) {
	rsp, err := c.GetDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionResponse(rsp)
}

// ReplaceDefaultsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceDefaultsSectionResponse
func (c *ClientWithResponses) ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

// GetAllHTTPCheckDefaultsWithResponse request returning *GetAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckDefaultsResponse(rsp)
}

// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

// DeleteHTTPCheckDefaultsWithResponse request returning *DeleteHTTPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckDefaultsResponse(rsp)
}

// GetHTTPCheckDefaultsWithResponse request returning *GetHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckDefaultsResponse(rsp)
}

// CreateHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckDefaultsResponse
func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

// GetAllHTTPErrorRuleDefaultsWithResponse request returning *GetAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

// DeleteHTTPErrorRuleDefaultsWithResponse request returning *DeleteHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleDefaultsResponse(rsp)
}

// GetHTTPErrorRuleDefaultsWithResponse request returning *GetHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleDefaultsResponse(rsp)
}

// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

// GetAllLogTargetDefaultsWithResponse request returning *GetAllLogTargetDefaultsResponse
func (c *ClientWithResponses) GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error) {
	rsp, err := c.GetAllLogTargetDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetDefaultsResponse(rsp)
}

// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

// DeleteLogTargetDefaultsWithResponse request returning *DeleteLogTargetDefaultsResponse
func (c *ClientWithResponses) DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error) {
	rsp, err := c.DeleteLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetDefaultsResponse(rsp)
}

// GetLogTargetDefaultsWithResponse request returning *GetLogTargetDefaultsResponse
func (c *ClientWithResponses) GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error) {
	rsp, err := c.GetLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetDefaultsResponse(rsp)
}

// CreateLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *CreateLogTargetDefaultsResponse
func (c *ClientWithResponses) CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

// ReplaceLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

// GetAllQUICInitialRuleDefaultsWithResponse request returning *GetAllQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) GetAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.GetAllQUICInitialRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllQUICInitialRuleDefaultsResponse(rsp)
}

// ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp)
}

// DeleteQUICInitialRuleDefaultsWithResponse request returning *DeleteQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) DeleteQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.DeleteQUICInitialRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQUICInitialRuleDefaultsResponse(rsp)
}

// GetQUICInitialRuleDefaultsWithResponse request returning *GetQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) GetQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.GetQUICInitialRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQUICInitialRuleDefaultsResponse(rsp)
}

// CreateQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) CreateQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.CreateQUICInitialRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.CreateQUICInitialRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleDefaultsResponse(rsp)
}

// ReplaceQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleDefaultsResponse(rsp)
}

// GetAllTCPCheckDefaultsWithResponse request returning *GetAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllTCPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckDefaultsResponse(rsp)
}

// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

// DeleteTCPCheckDefaultsWithResponse request returning *DeleteTCPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckDefaultsResponse(rsp)
}

// GetTCPCheckDefaultsWithResponse request returning *GetTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckDefaultsResponse(rsp)
}

// CreateTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckDefaultsResponse
func (c *ClientWithResponses) CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

// ReplaceTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

// GetFCGIAppsWithResponse request returning *GetFCGIAppsResponse
func (c *ClientWithResponses) GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error) {
	rsp, err := c.GetFCGIApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppsResponse(rsp)
}

// CreateFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateFCGIAppResponse
func (c *ClientWithResponses) CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIAppWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIApp(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

// DeleteFCGIAppWithResponse request returning *DeleteFCGIAppResponse
func (c *ClientWithResponses) DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error) {
	rsp, err := c.DeleteFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFCGIAppResponse(rsp)
}

// GetFCGIAppWithResponse request returning *GetFCGIAppResponse
func (c *ClientWithResponses) GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error) {
	rsp, err := c.GetFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppResponse(rsp)
}

// ReplaceFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceFCGIAppResponse
func (c *ClientWithResponses) ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIAppWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIApp(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

// GetAllAclFCGIAppWithResponse request returning *GetAllAclFCGIAppResponse
func (c *ClientWithResponses) GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error) {
	rsp, err := c.GetAllAclFCGIApp(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFCGIAppResponse(rsp)
}

// ReplaceAllAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIAppWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIApp(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

// DeleteAclFCGIAppWithResponse request returning *DeleteAclFCGIAppResponse
func (c *ClientWithResponses) DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error) {
	rsp, err := c.DeleteAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFCGIAppResponse(rsp)
}

// GetAclFCGIAppWithResponse request returning *GetAclFCGIAppResponse
func (c *ClientWithResponses) GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error) {
	rsp, err := c.GetAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFCGIAppResponse(rsp)
}

// CreateAclFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateAclFCGIAppResponse
func (c *ClientWithResponses) CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

// ReplaceAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

// GetFrontendsWithResponse request returning *GetFrontendsResponse
func (c *ClientWithResponses) GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error) {
	rsp, err := c.GetFrontends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendsResponse(rsp)
}

// CreateFrontendWithBodyWithResponse request with arbitrary body returning *CreateFrontendResponse
func (c *ClientWithResponses) CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

// DeleteFrontendWithResponse request returning *DeleteFrontendResponse
func (c *ClientWithResponses) DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error) {
	rsp, err := c.DeleteFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFrontendResponse(rsp)
}

// GetFrontendWithResponse request returning *GetFrontendResponse
func (c *ClientWithResponses) GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error) {
	rsp, err := c.GetFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendResponse(rsp)
}

// ReplaceFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFrontendResponse
func (c *ClientWithResponses) ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

// GetAllAclFrontendWithResponse request returning *GetAllAclFrontendResponse
func (c *ClientWithResponses) GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error) {
	rsp, err := c.GetAllAclFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFrontendResponse(rsp)
}

// ReplaceAllAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFrontendResponse
func (c *ClientWithResponses) ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

// DeleteAclFrontendWithResponse request returning *DeleteAclFrontendResponse
func (c *ClientWithResponses) DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error) {
	rsp, err := c.DeleteAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFrontendResponse(rsp)
}

// GetAclFrontendWithResponse request returning *GetAclFrontendResponse
func (c *ClientWithResponses) GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error) {
	rsp, err := c.GetAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFrontendResponse(rsp)
}

// CreateAclFrontendWithBodyWithResponse request with arbitrary body returning *CreateAclFrontendResponse
func (c *ClientWithResponses) CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

// ReplaceAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAclFrontendResponse
func (c *ClientWithResponses) ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

// GetBackendSwitchingRulesWithResponse request returning *GetBackendSwitchingRulesResponse
func (c *ClientWithResponses) GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error) {
	rsp, err := c.GetBackendSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRulesResponse(rsp)
}

// ReplaceBackendSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

// DeleteBackendSwitchingRuleWithResponse request returning *DeleteBackendSwitchingRuleResponse
func (c *ClientWithResponses) DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error) {
	rsp, err := c.DeleteBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendSwitchingRuleResponse(rsp)
}

// GetBackendSwitchingRuleWithResponse request returning *GetBackendSwitchingRuleResponse
func (c *ClientWithResponses) GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error) {
	rsp, err := c.GetBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRuleResponse(rsp)
}

// CreateBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateBackendSwitchingRuleResponse
func (c *ClientWithResponses) CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

// ReplaceBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

// GetAllBindFrontendWithResponse request returning *GetAllBindFrontendResponse
func (c *ClientWithResponses) GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error) {
	rsp, err := c.GetAllBindFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindFrontendResponse(rsp)
}

// CreateBindFrontendWithBodyWithResponse request with arbitrary body returning *CreateBindFrontendResponse
func (c *ClientWithResponses) CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

// DeleteBindFrontendWithResponse request returning *DeleteBindFrontendResponse
func (c *ClientWithResponses) DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error) {
	rsp, err := c.DeleteBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindFrontendResponse(rsp)
}

// GetBindFrontendWithResponse request returning *GetBindFrontendResponse
func (c *ClientWithResponses) GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error) {
	rsp, err := c.GetBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindFrontendResponse(rsp)
}

// ReplaceBindFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceBindFrontendResponse
func (c *ClientWithResponses) ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

// GetDeclareCapturesWithResponse request returning *GetDeclareCapturesResponse
func (c *ClientWithResponses) GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error) {
	rsp, err := c.GetDeclareCaptures(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCapturesResponse(rsp)
}

// ReplaceDeclareCapturesWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCapturesResponse
func (c *ClientWithResponses) ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCapturesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCaptures(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

// DeleteDeclareCaptureWithResponse request returning *DeleteDeclareCaptureResponse
func (c *ClientWithResponses) DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error) {
	rsp, err := c.DeleteDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeclareCaptureResponse(rsp)
}

// GetDeclareCaptureWithResponse request returning *GetDeclareCaptureResponse
func (c *ClientWithResponses) GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error) {
	rsp, err := c.GetDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCaptureResponse(rsp)
}

// CreateDeclareCaptureWithBodyWithResponse request with arbitrary body returning *CreateDeclareCaptureResponse
func (c *ClientWithResponses) CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

// ReplaceDeclareCaptureWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCaptureResponse
func (c *ClientWithResponses) ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

// GetAllFilterFrontendWithResponse request returning *GetAllFilterFrontendResponse
func (c *ClientWithResponses) GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error) {
	rsp, err := c.GetAllFilterFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterFrontendResponse(rsp)
}

// ReplaceAllFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterFrontendResponse
func (c *ClientWithResponses) ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

// DeleteFilterFrontendWithResponse request returning *DeleteFilterFrontendResponse
func (c *ClientWithResponses) DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error) {
	rsp, err := c.DeleteFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterFrontendResponse(rsp)
}

// GetFilterFrontendWithResponse request returning *GetFilterFrontendResponse
func (c *ClientWithResponses) GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error) {
	rsp, err := c.GetFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterFrontendResponse(rsp)
}

// CreateFilterFrontendWithBodyWithResponse request with arbitrary body returning *CreateFilterFrontendResponse
func (c *ClientWithResponses) CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

// ReplaceFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterFrontendResponse
func (c *ClientWithResponses) ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleFrontendWithResponse request returning *GetAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleFrontendWithResponse request returning *DeleteHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetHTTPAfterResponseRuleFrontendWithResponse request returning *GetHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleFrontendResponse(rsp)
}

// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetAllHTTPErrorRuleFrontendWithResponse request returning *GetAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

// DeleteHTTPErrorRuleFrontendWithResponse request returning *DeleteHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleFrontendResponse(rsp)
}

// GetHTTPErrorRuleFrontendWithResponse request returning *GetHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleFrontendResponse(rsp)
}

// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

// GetAllHTTPRequestRuleFrontendWithResponse request returning *GetAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

// DeleteHTTPRequestRuleFrontendWithResponse request returning *DeleteHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleFrontendResponse(rsp)
}

// GetHTTPRequestRuleFrontendWithResponse request returning *GetHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleFrontendResponse(rsp)
}

// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

// GetAllHTTPResponseRuleFrontendWithResponse request returning *GetAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPResponseRuleFrontendWithResponse request returning *DeleteHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleFrontendResponse(rsp)
}

// GetHTTPResponseRuleFrontendWithResponse request returning *GetHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleFrontendResponse(rsp)
}

// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

// GetAllLogTargetFrontendWithResponse request returning *GetAllLogTargetFrontendResponse
func (c *ClientWithResponses) GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error) {
	rsp, err := c.GetAllLogTargetFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetFrontendResponse(rsp)
}

// ReplaceAllLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

// DeleteLogTargetFrontendWithResponse request returning *DeleteLogTargetFrontendResponse
func (c *ClientWithResponses) DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error) {
	rsp, err := c.DeleteLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetFrontendResponse(rsp)
}

// GetLogTargetFrontendWithResponse request returning *GetLogTargetFrontendResponse
func (c *ClientWithResponses) GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error) {
	rsp, err := c.GetLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetFrontendResponse(rsp)
}

// CreateLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetFrontendResponse
func (c *ClientWithResponses) CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

// ReplaceLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

// GetAllQUICInitialRuleFrontendWithResponse request returning *GetAllQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) GetAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.GetAllQUICInitialRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllQUICInitialRuleFrontendResponse(rsp)
}

// ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleFrontendResponse(rsp)
}

// DeleteQUICInitialRuleFrontendWithResponse request returning *DeleteQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) DeleteQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.DeleteQUICInitialRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQUICInitialRuleFrontendResponse(rsp)
}

// GetQUICInitialRuleFrontendWithResponse request returning *GetQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) GetQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.GetQUICInitialRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQUICInitialRuleFrontendResponse(rsp)
}

// CreateQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) CreateQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.CreateQUICInitialRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.CreateQUICInitialRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleFrontendResponse(rsp)
}

// ReplaceQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) ReplaceQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleFrontendResponse(rsp)
}

// GetAllTCPRequestRuleFrontendWithResponse request returning *GetAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

// DeleteTCPRequestRuleFrontendWithResponse request returning *DeleteTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleFrontendResponse(rsp)
}

// GetTCPRequestRuleFrontendWithResponse request returning *GetTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleFrontendResponse(rsp)
}

// CreateTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// ReplaceGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceGlobalResponse
func (c *ClientWithResponses) ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

// GetAllLogTargetGlobalWithResponse request returning *GetAllLogTargetGlobalResponse
func (c *ClientWithResponses) GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error) {
	rsp, err := c.GetAllLogTargetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetGlobalResponse(rsp)
}

// ReplaceAllLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

// DeleteLogTargetGlobalWithResponse request returning *DeleteLogTargetGlobalResponse
func (c *ClientWithResponses) DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error) {
	rsp, err := c.DeleteLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetGlobalResponse(rsp)
}

// GetLogTargetGlobalWithResponse request returning *GetLogTargetGlobalResponse
func (c *ClientWithResponses) GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error) {
	rsp, err := c.GetLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetGlobalResponse(rsp)
}

// CreateLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *CreateLogTargetGlobalResponse
func (c *ClientWithResponses) CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

// ReplaceLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ReplaceGroupWithBodyWithResponse request with arbitrary body returning *ReplaceGroupResponse
func (c *ClientWithResponses) ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroupWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroup(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

// GetHTTPErrorsSectionsWithResponse request returning *GetHTTPErrorsSectionsResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error) {
	rsp, err := c.GetHTTPErrorsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionsResponse(rsp)
}

// CreateHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorsSectionResponse
func (c *ClientWithResponses) CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

// DeleteHTTPErrorsSectionWithResponse request returning *DeleteHTTPErrorsSectionResponse
func (c *ClientWithResponses) DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error) {
	rsp, err := c.DeleteHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorsSectionResponse(rsp)
}

// GetHTTPErrorsSectionWithResponse request returning *GetHTTPErrorsSectionResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error) {
	rsp, err := c.GetHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionResponse(rsp)
}

// ReplaceHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorsSectionResponse
func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

// GetLogForwardsWithResponse request returning *GetLogForwardsResponse
func (c *ClientWithResponses) GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error) {
	rsp, err := c.GetLogForwards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardsResponse(rsp)
}

// CreateLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogForwardResponse
func (c *ClientWithResponses) CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForwardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForward(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

// DeleteLogForwardWithResponse request returning *DeleteLogForwardResponse
func (c *ClientWithResponses) DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error) {
	rsp, err := c.DeleteLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogForwardResponse(rsp)
}

// GetLogForwardWithResponse request returning *GetLogForwardResponse
func (c *ClientWithResponses) GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error) {
	rsp, err := c.GetLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardResponse(rsp)
}

// ReplaceLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogForwardResponse
func (c *ClientWithResponses) ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForwardWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForward(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

// GetAllBindLogForwardWithResponse request returning *GetAllBindLogForwardResponse
func (c *ClientWithResponses) GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error) {
	rsp, err := c.GetAllBindLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindLogForwardResponse(rsp)
}

// CreateBindLogForwardWithBodyWithResponse request with arbitrary body returning *CreateBindLogForwardResponse
func (c *ClientWithResponses) CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

// DeleteBindLogForwardWithResponse request returning *DeleteBindLogForwardResponse
func (c *ClientWithResponses) DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error) {
	rsp, err := c.DeleteBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindLogForwardResponse(rsp)
}

// GetBindLogForwardWithResponse request returning *GetBindLogForwardResponse
func (c *ClientWithResponses) GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error) {
	rsp, err := c.GetBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindLogForwardResponse(rsp)
}

// ReplaceBindLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceBindLogForwardResponse
func (c *ClientWithResponses) ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForwardWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForward(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

// GetDgramBindsWithResponse request returning *GetDgramBindsResponse
func (c *ClientWithResponses) GetDgramBindsWithResponse(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*GetDgramBindsResponse, error) {
	rsp, err := c.GetDgramBinds(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindsResponse(rsp)
}

// CreateDgramBindWithBodyWithResponse request with arbitrary body returning *CreateDgramBindResponse
func (c *ClientWithResponses) CreateDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error) {
	rsp, err := c.CreateDgramBindWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindResponse(rsp)
}

func (c *ClientWithResponses) CreateDgramBindWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error) {
	rsp, err := c.CreateDgramBind(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindResponse(rsp)
}

// DeleteDgramBindWithResponse request returning *DeleteDgramBindResponse
func (c *ClientWithResponses) DeleteDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindResponse, error) {
	rsp, err := c.DeleteDgramBind(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDgramBindResponse(rsp)
}

// GetDgramBindWithResponse request returning *GetDgramBindResponse
func (c *ClientWithResponses) GetDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*GetDgramBindResponse, error) {
	rsp, err := c.GetDgramBind(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindResponse(rsp)
}

// ReplaceDgramBindWithBodyWithResponse request with arbitrary body returning *ReplaceDgramBindResponse
func (c *ClientWithResponses) ReplaceDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error) {
	rsp, err := c.ReplaceDgramBindWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error) {
	rsp, err := c.ReplaceDgramBind(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindResponse(rsp)
}

// GetAllLogTargetLogForwardWithResponse request returning *GetAllLogTargetLogForwardResponse
func (c *ClientWithResponses) GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error) {
	rsp, err := c.GetAllLogTargetLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetLogForwardResponse(rsp)
}

// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

// DeleteLogTargetLogForwardWithResponse request returning *DeleteLogTargetLogForwardResponse
func (c *ClientWithResponses) DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error) {
	rsp, err := c.DeleteLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetLogForwardResponse(rsp)
}

// GetLogTargetLogForwardWithResponse request returning *GetLogTargetLogForwardResponse
func (c *ClientWithResponses) GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error) {
	rsp, err := c.GetLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetLogForwardResponse(rsp)
}

// CreateLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogTargetLogForwardResponse
func (c *ClientWithResponses) CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

// ReplaceLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

// GetLogProfilesWithResponse request returning *GetLogProfilesResponse
func (c *ClientWithResponses) GetLogProfilesWithResponse(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*GetLogProfilesResponse, error) {
	rsp, err := c.GetLogProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogProfilesResponse(rsp)
}

// CreateLogProfileWithBodyWithResponse request with arbitrary body returning *CreateLogProfileResponse
func (c *ClientWithResponses) CreateLogProfileWithBodyWithResponse(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error) {
	rsp, err := c.CreateLogProfileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateLogProfileWithResponse(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error) {
	rsp, err := c.CreateLogProfile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogProfileResponse(rsp)
}

// DeleteLogProfileWithResponse request returning *DeleteLogProfileResponse
func (c *ClientWithResponses) DeleteLogProfileWithResponse(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*DeleteLogProfileResponse, error) {
	rsp, err := c.DeleteLogProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogProfileResponse(rsp)
}

// GetLogProfileWithResponse request returning *GetLogProfileResponse
func (c *ClientWithResponses) GetLogProfileWithResponse(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*GetLogProfileResponse, error) {
	rsp, err := c.GetLogProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogProfileResponse(rsp)
}

// EditLogProfileWithBodyWithResponse request with arbitrary body returning *EditLogProfileResponse
func (c *ClientWithResponses) EditLogProfileWithBodyWithResponse(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error) {
	rsp, err := c.EditLogProfileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLogProfileResponse(rsp)
}

func (c *ClientWithResponses) EditLogProfileWithResponse(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error) {
	rsp, err := c.EditLogProfile(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLogProfileResponse(rsp)
}

// GetMailerEntriesWithResponse request returning *GetMailerEntriesResponse
func (c *ClientWithResponses) GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error) {
	rsp, err := c.GetMailerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntriesResponse(rsp)
}

// CreateMailerEntryWithBodyWithResponse request with arbitrary body returning *CreateMailerEntryResponse
func (c *ClientWithResponses) CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

// DeleteMailerEntryWithResponse request returning *DeleteMailerEntryResponse
func (c *ClientWithResponses) DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error) {
	rsp, err := c.DeleteMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailerEntryResponse(rsp)
}

// GetMailerEntryWithResponse request returning *GetMailerEntryResponse
func (c *ClientWithResponses) GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error) {
	rsp, err := c.GetMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntryResponse(rsp)
}

// ReplaceMailerEntryWithBodyWithResponse request with arbitrary body returning *ReplaceMailerEntryResponse
func (c *ClientWithResponses) ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

// GetMailersSectionsWithResponse request returning *GetMailersSectionsResponse
func (c *ClientWithResponses) GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error) {
	rsp, err := c.GetMailersSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionsResponse(rsp)
}

// CreateMailersSectionWithBodyWithResponse request with arbitrary body returning *CreateMailersSectionResponse
func (c *ClientWithResponses) CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

// DeleteMailersSectionWithResponse request returning *DeleteMailersSectionResponse
func (c *ClientWithResponses) DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error) {
	rsp, err := c.DeleteMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailersSectionResponse(rsp)
}

// GetMailersSectionWithResponse request returning *GetMailersSectionResponse
func (c *ClientWithResponses) GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error) {
	rsp, err := c.GetMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionResponse(rsp)
}

// EditMailersSectionWithBodyWithResponse request with arbitrary body returning *EditMailersSectionResponse
func (c *ClientWithResponses) EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

// GetNameserversWithResponse request returning *GetNameserversResponse
func (c *ClientWithResponses) GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error) {
	rsp, err := c.GetNameservers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserversResponse(rsp)
}

// CreateNameserverWithBodyWithResponse request with arbitrary body returning *CreateNameserverResponse
func (c *ClientWithResponses) CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

func (c *ClientWithResponses) CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

// DeleteNameserverWithResponse request returning *DeleteNameserverResponse
func (c *ClientWithResponses) DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error) {
	rsp, err := c.DeleteNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNameserverResponse(rsp)
}

// GetNameserverWithResponse request returning *GetNameserverResponse
func (c *ClientWithResponses) GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error) {
	rsp, err := c.GetNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserverResponse(rsp)
}

// ReplaceNameserverWithBodyWithResponse request with arbitrary body returning *ReplaceNameserverResponse
func (c *ClientWithResponses) ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

// GetPeerEntriesWithResponse request returning *GetPeerEntriesResponse
func (c *ClientWithResponses) GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error) {
	rsp, err := c.GetPeerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntriesResponse(rsp)
}

// CreatePeerEntryWithBodyWithResponse request with arbitrary body returning *CreatePeerEntryResponse
func (c *ClientWithResponses) CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

// DeletePeerEntryWithResponse request returning *DeletePeerEntryResponse
func (c *ClientWithResponses) DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error) {
	rsp, err := c.DeletePeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerEntryResponse(rsp)
}

// GetPeerEntryWithResponse request returning *GetPeerEntryResponse
func (c *ClientWithResponses) GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error) {
	rsp, err := c.GetPeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntryResponse(rsp)
}

// ReplacePeerEntryWithBodyWithResponse request with arbitrary body returning *ReplacePeerEntryResponse
func (c *ClientWithResponses) ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

// GetPeerSectionsWithResponse request returning *GetPeerSectionsResponse
func (c *ClientWithResponses) GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error) {
	rsp, err := c.GetPeerSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionsResponse(rsp)
}

// CreatePeerWithBodyWithResponse request with arbitrary body returning *CreatePeerResponse
func (c *ClientWithResponses) CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

// DeletePeerWithResponse request returning *DeletePeerResponse
func (c *ClientWithResponses) DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error) {
	rsp, err := c.DeletePeer(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerResponse(rsp)
}

// GetPeerSectionWithResponse request returning *GetPeerSectionResponse
func (c *ClientWithResponses) GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error) {
	rsp, err := c.GetPeerSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionResponse(rsp)
}

// GetAllBindPeerWithResponse request returning *GetAllBindPeerResponse
func (c *ClientWithResponses) GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error) {
	rsp, err := c.GetAllBindPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindPeerResponse(rsp)
}

// CreateBindPeerWithBodyWithResponse request with arbitrary body returning *CreateBindPeerResponse
func (c *ClientWithResponses) CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

// DeleteBindPeerWithResponse request returning *DeleteBindPeerResponse
func (c *ClientWithResponses) DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error) {
	rsp, err := c.DeleteBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindPeerResponse(rsp)
}

// GetBindPeerWithResponse request returning *GetBindPeerResponse
func (c *ClientWithResponses) GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error) {
	rsp, err := c.GetBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindPeerResponse(rsp)
}

// ReplaceBindPeerWithBodyWithResponse request with arbitrary body returning *ReplaceBindPeerResponse
func (c *ClientWithResponses) ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

// GetAllLogTargetPeerWithResponse request returning *GetAllLogTargetPeerResponse
func (c *ClientWithResponses) GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error) {
	rsp, err := c.GetAllLogTargetPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetPeerResponse(rsp)
}

// ReplaceAllLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

// DeleteLogTargetPeerWithResponse request returning *DeleteLogTargetPeerResponse
func (c *ClientWithResponses) DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error) {
	rsp, err := c.DeleteLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetPeerResponse(rsp)
}

// GetLogTargetPeerWithResponse request returning *GetLogTargetPeerResponse
func (c *ClientWithResponses) GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error) {
	rsp, err := c.GetLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetPeerResponse(rsp)
}

// CreateLogTargetPeerWithBodyWithResponse request with arbitrary body returning *CreateLogTargetPeerResponse
func (c *ClientWithResponses) CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

// ReplaceLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

// GetAllServerPeerWithResponse request returning *GetAllServerPeerResponse
func (c *ClientWithResponses) GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error) {
	rsp, err := c.GetAllServerPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerPeerResponse(rsp)
}

// CreateServerPeerWithBodyWithResponse request with arbitrary body returning *CreateServerPeerResponse
func (c *ClientWithResponses) CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

// DeleteServerPeerWithResponse request returning *DeleteServerPeerResponse
func (c *ClientWithResponses) DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error) {
	rsp, err := c.DeleteServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerPeerResponse(rsp)
}

// GetServerPeerWithResponse request returning *GetServerPeerResponse
func (c *ClientWithResponses) GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error) {
	rsp, err := c.GetServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerPeerResponse(rsp)
}

// ReplaceServerPeerWithBodyWithResponse request with arbitrary body returning *ReplaceServerPeerResponse
func (c *ClientWithResponses) ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

// GetTablesWithResponse request returning *GetTablesResponse
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error) {
	rsp, err := c.GetTables(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ReplaceTableWithBodyWithResponse request with arbitrary body returning *ReplaceTableResponse
func (c *ClientWithResponses) ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTableWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTable(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

// GetProgramsWithResponse request returning *GetProgramsResponse
func (c *ClientWithResponses) GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

// CreateProgramWithBodyWithResponse request with arbitrary body returning *CreateProgramResponse
func (c *ClientWithResponses) CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgramWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

func (c *ClientWithResponses) CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgram(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResponse
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error) {
	rsp, err := c.DeleteProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// ReplaceProgramWithBodyWithResponse request with arbitrary body returning *ReplaceProgramResponse
func (c *ClientWithResponses) ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgramWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

func (c *ClientWithResponses) ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgram(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

// GetHAProxyConfigurationWithResponse request returning *GetHAProxyConfigurationResponse
func (c *ClientWithResponses) GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error) {
	rsp, err := c.GetHAProxyConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHAProxyConfigurationResponse(rsp)
}

// PostHAProxyConfigurationWithBodyWithResponse request with arbitrary body returning *PostHAProxyConfigurationResponse
func (c *ClientWithResponses) PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

// GetResolversWithResponse request returning *GetResolversResponse
func (c *ClientWithResponses) GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error) {
	rsp, err := c.GetResolvers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolversResponse(rsp)
}

// CreateResolverWithBodyWithResponse request with arbitrary body returning *CreateResolverResponse
func (c *ClientWithResponses) CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

func (c *ClientWithResponses) CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

// DeleteResolverWithResponse request returning *DeleteResolverResponse
func (c *ClientWithResponses) DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error) {
	rsp, err := c.DeleteResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResolverResponse(rsp)
}

// GetResolverWithResponse request returning *GetResolverResponse
func (c *ClientWithResponses) GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error) {
	rsp, err := c.GetResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolverResponse(rsp)
}

// ReplaceResolverWithBodyWithResponse request with arbitrary body returning *ReplaceResolverResponse
func (c *ClientWithResponses) ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

// GetRingsWithResponse request returning *GetRingsResponse
func (c *ClientWithResponses) GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error) {
	rsp, err := c.GetRings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingsResponse(rsp)
}

// CreateRingWithBodyWithResponse request with arbitrary body returning *CreateRingResponse
func (c *ClientWithResponses) CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

func (c *ClientWithResponses) CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRing(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

// DeleteRingWithResponse request returning *DeleteRingResponse
func (c *ClientWithResponses) DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error) {
	rsp, err := c.DeleteRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRingResponse(rsp)
}

// GetRingWithResponse request returning *GetRingResponse
func (c *ClientWithResponses) GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error) {
	rsp, err := c.GetRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingResponse(rsp)
}

// ReplaceRingWithBodyWithResponse request with arbitrary body returning *ReplaceRingResponse
func (c *ClientWithResponses) ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRingWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRing(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

// GetAllServerRingWithResponse request returning *GetAllServerRingResponse
func (c *ClientWithResponses) GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error) {
	rsp, err := c.GetAllServerRing(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerRingResponse(rsp)
}

// CreateServerRingWithBodyWithResponse request with arbitrary body returning *CreateServerRingResponse
func (c *ClientWithResponses) CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRingWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

func (c *ClientWithResponses) CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRing(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

// DeleteServerRingWithResponse request returning *DeleteServerRingResponse
func (c *ClientWithResponses) DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error) {
	rsp, err := c.DeleteServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerRingResponse(rsp)
}

// GetServerRingWithResponse request returning *GetServerRingResponse
func (c *ClientWithResponses) GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error) {
	rsp, err := c.GetServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerRingResponse(rsp)
}

// ReplaceServerRingWithBodyWithResponse request with arbitrary body returning *ReplaceServerRingResponse
func (c *ClientWithResponses) ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRingWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRing(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

// DeleteTracesWithResponse request returning *DeleteTracesResponse
func (c *ClientWithResponses) DeleteTracesWithResponse(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*DeleteTracesResponse, error) {
	rsp, err := c.DeleteTraces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTracesResponse(rsp)
}

// GetTracesWithResponse request returning *GetTracesResponse
func (c *ClientWithResponses) GetTracesWithResponse(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*GetTracesResponse, error) {
	rsp, err := c.GetTraces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracesResponse(rsp)
}

// CreateTracesWithBodyWithResponse request with arbitrary body returning *CreateTracesResponse
func (c *ClientWithResponses) CreateTracesWithBodyWithResponse(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error) {
	rsp, err := c.CreateTracesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTracesResponse(rsp)
}

func (c *ClientWithResponses) CreateTracesWithResponse(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error) {
	rsp, err := c.CreateTraces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTracesResponse(rsp)
}

// ReplaceTracesWithBodyWithResponse request with arbitrary body returning *ReplaceTracesResponse
func (c *ClientWithResponses) ReplaceTracesWithBodyWithResponse(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error) {
	rsp, err := c.ReplaceTracesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTracesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTracesWithResponse(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error) {
	rsp, err := c.ReplaceTraces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTracesResponse(rsp)
}

// DeleteTraceEntryWithBodyWithResponse request with arbitrary body returning *DeleteTraceEntryResponse
func (c *ClientWithResponses) DeleteTraceEntryWithBodyWithResponse(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error) {
	rsp, err := c.DeleteTraceEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTraceEntryResponse(rsp)
}

func (c *ClientWithResponses) DeleteTraceEntryWithResponse(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error) {
	rsp, err := c.DeleteTraceEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTraceEntryResponse(rsp)
}

// CreateTraceEntryWithBodyWithResponse request with arbitrary body returning *CreateTraceEntryResponse
func (c *ClientWithResponses) CreateTraceEntryWithBodyWithResponse(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error) {
	rsp, err := c.CreateTraceEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTraceEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateTraceEntryWithResponse(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error) {
	rsp, err := c.CreateTraceEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTraceEntryResponse(rsp)
}

// GetUserlistsWithResponse request returning *GetUserlistsResponse
func (c *ClientWithResponses) GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error) {
	rsp, err := c.GetUserlists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistsResponse(rsp)
}

// CreateUserlistWithBodyWithResponse request with arbitrary body returning *CreateUserlistResponse
func (c *ClientWithResponses) CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlistWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

func (c *ClientWithResponses) CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlist(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

// DeleteUserlistWithResponse request returning *DeleteUserlistResponse
func (c *ClientWithResponses) DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error) {
	rsp, err := c.DeleteUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserlistResponse(rsp)
}

// GetUserlistWithResponse request returning *GetUserlistResponse
func (c *ClientWithResponses) GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error) {
	rsp, err := c.GetUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ReplaceUserWithBodyWithResponse request with arbitrary body returning *ReplaceUserResponse
func (c *ClientWithResponses) ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUserWithBody(ctx, username, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

func (c *ClientWithResponses) ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUser(ctx, username, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

// GetConfigurationVersionWithResponse request returning *GetConfigurationVersionResponse
func (c *ClientWithResponses) GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error) {
	rsp, err := c.GetConfigurationVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationVersionResponse(rsp)
}

// GetReloadsWithResponse request returning *GetReloadsResponse
func (c *ClientWithResponses) GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error) {
	rsp, err := c.GetReloads(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadsResponse(rsp)
}

// GetReloadWithResponse request returning *GetReloadResponse
func (c *ClientWithResponses) GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error) {
	rsp, err := c.GetReload(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadResponse(rsp)
}

// GetRuntimeEndpointsWithResponse request returning *GetRuntimeEndpointsResponse
func (c *ClientWithResponses) GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error) {
	rsp, err := c.GetRuntimeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeEndpointsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsWithResponse request returning *GetServicesHaproxyRuntimeAclsResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAcls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsIdWithResponse request returning *GetServicesHaproxyRuntimeAclsIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with arbitrary body returning *PostServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// AddPayloadRuntimeACLWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeACLResponse
func (c *ClientWithResponses) AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACLWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACL(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetAllRuntimeServerWithResponse request returning *GetAllRuntimeServerResponse
func (c *ClientWithResponses) GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error) {
	rsp, err := c.GetAllRuntimeServer(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeServerResponse(rsp)
}

// AddRuntimeServerWithBodyWithResponse request with arbitrary body returning *AddRuntimeServerResponse
func (c *ClientWithResponses) AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServerWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServer(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

// DeleteRuntimeServerWithResponse request returning *DeleteRuntimeServerResponse
func (c *ClientWithResponses) DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error) {
	rsp, err := c.DeleteRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeServerResponse(rsp)
}

// GetRuntimeServerWithResponse request returning *GetRuntimeServerResponse
func (c *ClientWithResponses) GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error) {
	rsp, err := c.GetRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeServerResponse(rsp)
}

// ReplaceRuntimeServerWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeServerResponse
func (c *ClientWithResponses) ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServerWithBody(ctx, parentName, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServer(ctx, parentName, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

// GetHaproxyProcessInfoWithResponse request returning *GetHaproxyProcessInfoResponse
func (c *ClientWithResponses) GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error) {
	rsp, err := c.GetHaproxyProcessInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyProcessInfoResponse(rsp)
}

// GetAllRuntimeMapFilesWithResponse request returning *GetAllRuntimeMapFilesResponse
func (c *ClientWithResponses) GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error) {
	rsp, err := c.GetAllRuntimeMapFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeMapFilesResponse(rsp)
}

// ClearRuntimeMapWithResponse request returning *ClearRuntimeMapResponse
func (c *ClientWithResponses) ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error) {
	rsp, err := c.ClearRuntimeMap(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearRuntimeMapResponse(rsp)
}

// GetOneRuntimeMapWithResponse request returning *GetOneRuntimeMapResponse
func (c *ClientWithResponses) GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error) {
	rsp, err := c.GetOneRuntimeMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneRuntimeMapResponse(rsp)
}

// AddPayloadRuntimeMapWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeMapResponse
func (c *ClientWithResponses) AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMapWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMap(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

// ShowRuntimeMapWithResponse request returning *ShowRuntimeMapResponse
func (c *ClientWithResponses) ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error) {
	rsp, err := c.ShowRuntimeMap(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowRuntimeMapResponse(rsp)
}

// AddMapEntryWithBodyWithResponse request with arbitrary body returning *AddMapEntryResponse
func (c *ClientWithResponses) AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntryWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

func (c *ClientWithResponses) AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntry(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

// DeleteRuntimeMapEntryWithResponse request returning *DeleteRuntimeMapEntryResponse
func (c *ClientWithResponses) DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error) {
	rsp, err := c.DeleteRuntimeMapEntry(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeMapEntryResponse(rsp)
}

// GetRuntimeMapEntryWithResponse request returning *GetRuntimeMapEntryResponse
func (c *ClientWithResponses) GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error) {
	rsp, err := c.GetRuntimeMapEntry(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeMapEntryResponse(rsp)
}

// ReplaceRuntimeMapEntryWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeMapEntryResponse
func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntryWithBody(ctx, parentName, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntry(ctx, parentName, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

// GetStickTablesWithResponse request returning *GetStickTablesResponse
func (c *ClientWithResponses) GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error) {
	rsp, err := c.GetStickTables(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTablesResponse(rsp)
}

// GetStickTableWithResponse request returning *GetStickTableResponse
func (c *ClientWithResponses) GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error) {
	rsp, err := c.GetStickTable(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableResponse(rsp)
}

// GetStickTableEntriesWithResponse request returning *GetStickTableEntriesResponse
func (c *ClientWithResponses) GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error) {
	rsp, err := c.GetStickTableEntries(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableEntriesResponse(rsp)
}

// SetStickTableEntriesWithBodyWithResponse request with arbitrary body returning *SetStickTableEntriesResponse
func (c *ClientWithResponses) SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

func (c *ClientWithResponses) SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

// GetSitesWithResponse request returning *GetSitesResponse
func (c *ClientWithResponses) GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error) {
	rsp, err := c.GetSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitesResponse(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResponse
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSiteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSite(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

// DeleteSiteWithResponse request returning *DeleteSiteResponse
func (c *ClientWithResponses) DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error) {
	rsp, err := c.DeleteSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteResponse(rsp)
}

// GetSiteWithResponse request returning *GetSiteResponse
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error) {
	rsp, err := c.GetSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResponse(rsp)
}

// ReplaceSiteWithBodyWithResponse request with arbitrary body returning *ReplaceSiteResponse
func (c *ClientWithResponses) ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSiteWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSite(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

// GetSpoeEndpointsWithResponse request returning *GetSpoeEndpointsResponse
func (c *ClientWithResponses) GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error) {
	rsp, err := c.GetSpoeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeEndpointsResponse(rsp)
}

// GetAllSpoeFilesWithResponse request returning *GetAllSpoeFilesResponse
func (c *ClientWithResponses) GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error) {
	rsp, err := c.GetAllSpoeFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeFilesResponse(rsp)
}

// CreateSpoeWithBodyWithResponse request with arbitrary body returning *CreateSpoeResponse
func (c *ClientWithResponses) CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error) {
	rsp, err := c.CreateSpoeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeResponse(rsp)
}

// DeleteSpoeFileWithResponse request returning *DeleteSpoeFileResponse
func (c *ClientWithResponses) DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error) {
	rsp, err := c.DeleteSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeFileResponse(rsp)
}

// GetOneSpoeFileWithResponse request returning *GetOneSpoeFileResponse
func (c *ClientWithResponses) GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error) {
	rsp, err := c.GetOneSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneSpoeFileResponse(rsp)
}

// GetAllSpoeScopeWithResponse request returning *GetAllSpoeScopeResponse
func (c *ClientWithResponses) GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error) {
	rsp, err := c.GetAllSpoeScope(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeScopeResponse(rsp)
}

// CreateSpoeScopeWithBodyWithResponse request with arbitrary body returning *CreateSpoeScopeResponse
func (c *ClientWithResponses) CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScopeWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScope(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

// DeleteSpoeScopeWithResponse request returning *DeleteSpoeScopeResponse
func (c *ClientWithResponses) DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error) {
	rsp, err := c.DeleteSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeScopeResponse(rsp)
}

// GetSpoeScopeWithResponse request returning *GetSpoeScopeResponse
func (c *ClientWithResponses) GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error) {
	rsp, err := c.GetSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeScopeResponse(rsp)
}

// GetAllSpoeAgentWithResponse request returning *GetAllSpoeAgentResponse
func (c *ClientWithResponses) GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error) {
	rsp, err := c.GetAllSpoeAgent(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeAgentResponse(rsp)
}

// CreateSpoeAgentWithBodyWithResponse request with arbitrary body returning *CreateSpoeAgentResponse
func (c *ClientWithResponses) CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgentWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgent(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

// DeleteSpoeAgentWithResponse request returning *DeleteSpoeAgentResponse
func (c *ClientWithResponses) DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error) {
	rsp, err := c.DeleteSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeAgentResponse(rsp)
}

// GetSpoeAgentWithResponse request returning *GetSpoeAgentResponse
func (c *ClientWithResponses) GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error) {
	rsp, err := c.GetSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeAgentResponse(rsp)
}

// ReplaceSpoeAgentWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeAgentResponse
func (c *ClientWithResponses) ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgentWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgent(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

// GetAllSpoeGroupWithResponse request returning *GetAllSpoeGroupResponse
func (c *ClientWithResponses) GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error) {
	rsp, err := c.GetAllSpoeGroup(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeGroupResponse(rsp)
}

// CreateSpoeGroupWithBodyWithResponse request with arbitrary body returning *CreateSpoeGroupResponse
func (c *ClientWithResponses) CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroupWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroup(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

// DeleteSpoeGroupWithResponse request returning *DeleteSpoeGroupResponse
func (c *ClientWithResponses) DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error) {
	rsp, err := c.DeleteSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeGroupResponse(rsp)
}

// GetSpoeGroupWithResponse request returning *GetSpoeGroupResponse
func (c *ClientWithResponses) GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error) {
	rsp, err := c.GetSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeGroupResponse(rsp)
}

// ReplaceSpoeGroupWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeGroupResponse
func (c *ClientWithResponses) ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroupWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroup(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

// GetAllSpoeMessageWithResponse request returning *GetAllSpoeMessageResponse
func (c *ClientWithResponses) GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error) {
	rsp, err := c.GetAllSpoeMessage(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeMessageResponse(rsp)
}

// CreateSpoeMessageWithBodyWithResponse request with arbitrary body returning *CreateSpoeMessageResponse
func (c *ClientWithResponses) CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessageWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessage(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

// DeleteSpoeMessageWithResponse request returning *DeleteSpoeMessageResponse
func (c *ClientWithResponses) DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error) {
	rsp, err := c.DeleteSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeMessageResponse(rsp)
}

// GetSpoeMessageWithResponse request returning *GetSpoeMessageResponse
func (c *ClientWithResponses) GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error) {
	rsp, err := c.GetSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeMessageResponse(rsp)
}

// ReplaceSpoeMessageWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeMessageResponse
func (c *ClientWithResponses) ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessageWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessage(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

// GetAllSpoeTransactionWithResponse request returning *GetAllSpoeTransactionResponse
func (c *ClientWithResponses) GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error) {
	rsp, err := c.GetAllSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeTransactionResponse(rsp)
}

// StartSpoeTransactionWithResponse request returning *StartSpoeTransactionResponse
func (c *ClientWithResponses) StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error) {
	rsp, err := c.StartSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSpoeTransactionResponse(rsp)
}

// DeleteSpoeTransactionWithResponse request returning *DeleteSpoeTransactionResponse
func (c *ClientWithResponses) DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error) {
	rsp, err := c.DeleteSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeTransactionResponse(rsp)
}

// GetSpoeTransactionWithResponse request returning *GetSpoeTransactionResponse
func (c *ClientWithResponses) GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error) {
	rsp, err := c.GetSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeTransactionResponse(rsp)
}

// CommitSpoeTransactionWithResponse request returning *CommitSpoeTransactionResponse
func (c *ClientWithResponses) CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error) {
	rsp, err := c.CommitSpoeTransaction(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitSpoeTransactionResponse(rsp)
}

// GetSpoeConfigurationVersionWithResponse request returning *GetSpoeConfigurationVersionResponse
func (c *ClientWithResponses) GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error) {
	rsp, err := c.GetSpoeConfigurationVersion(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeConfigurationVersionResponse(rsp)
}

// GetStatsEndpointsWithResponse request returning *GetStatsEndpointsResponse
func (c *ClientWithResponses) GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error) {
	rsp, err := c.GetStatsEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsEndpointsResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetStorageEndpointsWithResponse request returning *GetStorageEndpointsResponse
func (c *ClientWithResponses) GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error) {
	rsp, err := c.GetStorageEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageEndpointsResponse(rsp)
}

// GetAllStorageGeneralFilesWithResponse request returning *GetAllStorageGeneralFilesResponse
func (c *ClientWithResponses) GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error) {
	rsp, err := c.GetAllStorageGeneralFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageGeneralFilesResponse(rsp)
}

// CreateStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *CreateStorageGeneralFileResponse
func (c *ClientWithResponses) CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error) {
	rsp, err := c.CreateStorageGeneralFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageGeneralFileResponse(rsp)
}

// DeleteStorageGeneralFileWithResponse request returning *DeleteStorageGeneralFileResponse
func (c *ClientWithResponses) DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error) {
	rsp, err := c.DeleteStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageGeneralFileResponse(rsp)
}

// GetOneStorageGeneralFileWithResponse request returning *GetOneStorageGeneralFileResponse
func (c *ClientWithResponses) GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error) {
	rsp, err := c.GetOneStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageGeneralFileResponse(rsp)
}

// ReplaceStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageGeneralFileResponse
func (c *ClientWithResponses) ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error) {
	rsp, err := c.ReplaceStorageGeneralFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageGeneralFileResponse(rsp)
}

// GetAllStorageMapFilesWithResponse request returning *GetAllStorageMapFilesResponse
func (c *ClientWithResponses) GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error) {
	rsp, err := c.GetAllStorageMapFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageMapFilesResponse(rsp)
}

// CreateStorageMapFileWithBodyWithResponse request with arbitrary body returning *CreateStorageMapFileResponse
func (c *ClientWithResponses) CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error) {
	rsp, err := c.CreateStorageMapFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageMapFileResponse(rsp)
}

// DeleteStorageMapWithResponse request returning *DeleteStorageMapResponse
func (c *ClientWithResponses) DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error) {
	rsp, err := c.DeleteStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageMapResponse(rsp)
}

// GetOneStorageMapWithResponse request returning *GetOneStorageMapResponse
func (c *ClientWithResponses) GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error) {
	rsp, err := c.GetOneStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageMapResponse(rsp)
}

// ReplaceStorageMapFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageMapFileResponse
func (c *ClientWithResponses) ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

// GetAllStorageSSLCertificatesWithResponse request returning *GetAllStorageSSLCertificatesResponse
func (c *ClientWithResponses) GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error) {
	rsp, err := c.GetAllStorageSSLCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageSSLCertificatesResponse(rsp)
}

// CreateStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *CreateStorageSSLCertificateResponse
func (c *ClientWithResponses) CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error) {
	rsp, err := c.CreateStorageSSLCertificateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCertificateResponse(rsp)
}

// DeleteStorageSSLCertificateWithResponse request returning *DeleteStorageSSLCertificateResponse
func (c *ClientWithResponses) DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error) {
	rsp, err := c.DeleteStorageSSLCertificate(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageSSLCertificateResponse(rsp)
}

// GetOneStorageSSLCertificateWithResponse request returning *GetOneStorageSSLCertificateResponse
func (c *ClientWithResponses) GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error) {
	rsp, err := c.GetOneStorageSSLCertificate(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageSSLCertificateResponse(rsp)
}

// ReplaceStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *ReplaceStorageSSLCertificateResponse
func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// StartTransactionWithResponse request returning *StartTransactionResponse
func (c *ClientWithResponses) StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error) {
	rsp, err := c.StartTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// CommitTransactionWithResponse request returning *CommitTransactionResponse
func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

// GetSpecificationWithResponse request returning *GetSpecificationResponse
func (c *ClientWithResponses) GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error) {
	rsp, err := c.GetSpecification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpecificationResponse(rsp)
}

// GetOpenapiv3SpecificationWithResponse request returning *GetOpenapiv3SpecificationResponse
func (c *ClientWithResponses) GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error) {
	rsp, err := c.GetOpenapiv3Specification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiv3SpecificationResponse(rsp)
}

// ParseGetAPIEndpointsResponse parses an HTTP response from a GetAPIEndpointsWithResponse call
func ParseGetAPIEndpointsResponse(rsp *http.Response) (*GetAPIEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostClusterResponse parses an HTTP response from a PostClusterWithResponse call
func ParsePostClusterResponse(rsp *http.Response) (*PostClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditClusterResponse parses an HTTP response from a EditClusterWithResponse call
func ParseEditClusterResponse(rsp *http.Response) (*EditClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInitiateCertificateRefreshResponse parses an HTTP response from a InitiateCertificateRefreshWithResponse call
func ParseInitiateCertificateRefreshResponse(rsp *http.Response) (*InitiateCertificateRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCertificateRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Health
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoResponse parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResponse(rsp *http.Response) (*GetInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Info
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionsResponse parses an HTTP response from a GetAWSRegionsWithResponse call
func ParseGetAWSRegionsResponse(rsp *http.Response) (*GetAWSRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAWSRegionResponse parses an HTTP response from a CreateAWSRegionWithResponse call
func ParseCreateAWSRegionResponse(rsp *http.Response) (*CreateAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAWSRegionResponse parses an HTTP response from a DeleteAWSRegionWithResponse call
func ParseDeleteAWSRegionResponse(rsp *http.Response) (*DeleteAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionResponse parses an HTTP response from a GetAWSRegionWithResponse call
func ParseGetAWSRegionResponse(rsp *http.Response) (*GetAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAWSRegionResponse parses an HTTP response from a ReplaceAWSRegionWithResponse call
func ParseReplaceAWSRegionResponse(rsp *http.Response) (*ReplaceAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulsResponse parses an HTTP response from a GetConsulsWithResponse call
func ParseGetConsulsResponse(rsp *http.Response) (*GetConsulsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consuls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateConsulResponse parses an HTTP response from a CreateConsulWithResponse call
func ParseCreateConsulResponse(rsp *http.Response) (*CreateConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteConsulResponse parses an HTTP response from a DeleteConsulWithResponse call
func ParseDeleteConsulResponse(rsp *http.Response) (*DeleteConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulResponse parses an HTTP response from a GetConsulWithResponse call
func ParseGetConsulResponse(rsp *http.Response) (*GetConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceConsulResponse parses an HTTP response from a ReplaceConsulWithResponse call
func ParseReplaceConsulResponse(rsp *http.Response) (*ReplaceConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesEndpointsResponse parses an HTTP response from a GetServicesEndpointsWithResponse call
func ParseGetServicesEndpointsResponse(rsp *http.Response) (*GetServicesEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyEndpointsResponse parses an HTTP response from a GetHaproxyEndpointsWithResponse call
func ParseGetHaproxyEndpointsResponse(rsp *http.Response) (*GetHaproxyEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationEndpointsResponse parses an HTTP response from a GetConfigurationEndpointsWithResponse call
func ParseGetConfigurationEndpointsResponse(rsp *http.Response) (*GetConfigurationEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendsResponse parses an HTTP response from a GetBackendsWithResponse call
func ParseGetBackendsResponse(rsp *http.Response) (*GetBackendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendResponse parses an HTTP response from a CreateBackendWithResponse call
func ParseCreateBackendResponse(rsp *http.Response) (*CreateBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendResponse parses an HTTP response from a DeleteBackendWithResponse call
func ParseDeleteBackendResponse(rsp *http.Response) (*DeleteBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendResponse parses an HTTP response from a GetBackendWithResponse call
func ParseGetBackendResponse(rsp *http.Response) (*GetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendResponse parses an HTTP response from a ReplaceBackendWithResponse call
func ParseReplaceBackendResponse(rsp *http.Response) (*ReplaceBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclBackendResponse parses an HTTP response from a GetAllAclBackendWithResponse call
func ParseGetAllAclBackendResponse(rsp *http.Response) (*GetAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclBackendResponse parses an HTTP response from a ReplaceAllAclBackendWithResponse call
func ParseReplaceAllAclBackendResponse(rsp *http.Response) (*ReplaceAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclBackendResponse parses an HTTP response from a DeleteAclBackendWithResponse call
func ParseDeleteAclBackendResponse(rsp *http.Response) (*DeleteAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclBackendResponse parses an HTTP response from a GetAclBackendWithResponse call
func ParseGetAclBackendResponse(rsp *http.Response) (*GetAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclBackendResponse parses an HTTP response from a CreateAclBackendWithResponse call
func ParseCreateAclBackendResponse(rsp *http.Response) (*CreateAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclBackendResponse parses an HTTP response from a ReplaceAclBackendWithResponse call
func ParseReplaceAclBackendResponse(rsp *http.Response) (*ReplaceAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterBackendResponse parses an HTTP response from a GetAllFilterBackendWithResponse call
func ParseGetAllFilterBackendResponse(rsp *http.Response) (*GetAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterBackendResponse parses an HTTP response from a ReplaceAllFilterBackendWithResponse call
func ParseReplaceAllFilterBackendResponse(rsp *http.Response) (*ReplaceAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterBackendResponse parses an HTTP response from a DeleteFilterBackendWithResponse call
func ParseDeleteFilterBackendResponse(rsp *http.Response) (*DeleteFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterBackendResponse parses an HTTP response from a GetFilterBackendWithResponse call
func ParseGetFilterBackendResponse(rsp *http.Response) (*GetFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterBackendResponse parses an HTTP response from a CreateFilterBackendWithResponse call
func ParseCreateFilterBackendResponse(rsp *http.Response) (*CreateFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterBackendResponse parses an HTTP response from a ReplaceFilterBackendWithResponse call
func ParseReplaceFilterBackendResponse(rsp *http.Response) (*ReplaceFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleBackendWithResponse call
func ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleBackendWithResponse call
func ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetHTTPAfterResponseRuleBackendWithResponse call
func ParseGetHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleBackendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleBackendWithResponse call
func ParseCreateHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckBackendResponse parses an HTTP response from a GetAllHTTPCheckBackendWithResponse call
func ParseGetAllHTTPCheckBackendResponse(rsp *http.Response) (*GetAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckBackendResponse parses an HTTP response from a ReplaceAllHTTPCheckBackendWithResponse call
func ParseReplaceAllHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckBackendResponse parses an HTTP response from a DeleteHTTPCheckBackendWithResponse call
func ParseDeleteHTTPCheckBackendResponse(rsp *http.Response) (*DeleteHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckBackendResponse parses an HTTP response from a GetHTTPCheckBackendWithResponse call
func ParseGetHTTPCheckBackendResponse(rsp *http.Response) (*GetHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckBackendResponse parses an HTTP response from a CreateHTTPCheckBackendWithResponse call
func ParseCreateHTTPCheckBackendResponse(rsp *http.Response) (*CreateHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckBackendResponse parses an HTTP response from a ReplaceHTTPCheckBackendWithResponse call
func ParseReplaceHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleBackendResponse parses an HTTP response from a GetAllHTTPErrorRuleBackendWithResponse call
func ParseGetAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleBackendWithResponse call
func ParseReplaceAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleBackendResponse parses an HTTP response from a DeleteHTTPErrorRuleBackendWithResponse call
func ParseDeleteHTTPErrorRuleBackendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleBackendResponse parses an HTTP response from a GetHTTPErrorRuleBackendWithResponse call
func ParseGetHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleBackendResponse parses an HTTP response from a CreateHTTPErrorRuleBackendWithResponse call
func ParseCreateHTTPErrorRuleBackendResponse(rsp *http.Response) (*CreateHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceHTTPErrorRuleBackendWithResponse call
func ParseReplaceHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleBackendResponse parses an HTTP response from a GetAllHTTPRequestRuleBackendWithResponse call
func ParseGetAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleBackendWithResponse call
func ParseReplaceAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleBackendResponse parses an HTTP response from a DeleteHTTPRequestRuleBackendWithResponse call
func ParseDeleteHTTPRequestRuleBackendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleBackendResponse parses an HTTP response from a GetHTTPRequestRuleBackendWithResponse call
func ParseGetHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleBackendResponse parses an HTTP response from a CreateHTTPRequestRuleBackendWithResponse call
func ParseCreateHTTPRequestRuleBackendResponse(rsp *http.Response) (*CreateHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceHTTPRequestRuleBackendWithResponse call
func ParseReplaceHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPResponseRuleBackendWithResponse call
func ParseGetAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPResponseRuleBackendWithResponse call
func ParseDeleteHTTPResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleBackendResponse parses an HTTP response from a GetHTTPResponseRuleBackendWithResponse call
func ParseGetHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleBackendResponse parses an HTTP response from a CreateHTTPResponseRuleBackendWithResponse call
func ParseCreateHTTPResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPResponseRuleBackendWithResponse call
func ParseReplaceHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetBackendResponse parses an HTTP response from a GetAllLogTargetBackendWithResponse call
func ParseGetAllLogTargetBackendResponse(rsp *http.Response) (*GetAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetBackendResponse parses an HTTP response from a ReplaceAllLogTargetBackendWithResponse call
func ParseReplaceAllLogTargetBackendResponse(rsp *http.Response) (*ReplaceAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetBackendResponse parses an HTTP response from a DeleteLogTargetBackendWithResponse call
func ParseDeleteLogTargetBackendResponse(rsp *http.Response) (*DeleteLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetBackendResponse parses an HTTP response from a GetLogTargetBackendWithResponse call
func ParseGetLogTargetBackendResponse(rsp *http.Response) (*GetLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetBackendResponse parses an HTTP response from a CreateLogTargetBackendWithResponse call
func ParseCreateLogTargetBackendResponse(rsp *http.Response) (*CreateLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetBackendResponse parses an HTTP response from a ReplaceLogTargetBackendWithResponse call
func ParseReplaceLogTargetBackendResponse(rsp *http.Response) (*ReplaceLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRulesResponse parses an HTTP response from a GetServerSwitchingRulesWithResponse call
func ParseGetServerSwitchingRulesResponse(rsp *http.Response) (*GetServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRulesResponse parses an HTTP response from a ReplaceServerSwitchingRulesWithResponse call
func ParseReplaceServerSwitchingRulesResponse(rsp *http.Response) (*ReplaceServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerSwitchingRuleResponse parses an HTTP response from a DeleteServerSwitchingRuleWithResponse call
func ParseDeleteServerSwitchingRuleResponse(rsp *http.Response) (*DeleteServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRuleResponse parses an HTTP response from a GetServerSwitchingRuleWithResponse call
func ParseGetServerSwitchingRuleResponse(rsp *http.Response) (*GetServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerSwitchingRuleResponse parses an HTTP response from a CreateServerSwitchingRuleWithResponse call
func ParseCreateServerSwitchingRuleResponse(rsp *http.Response) (*CreateServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRuleResponse parses an HTTP response from a ReplaceServerSwitchingRuleWithResponse call
func ParseReplaceServerSwitchingRuleResponse(rsp *http.Response) (*ReplaceServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplatesResponse parses an HTTP response from a GetServerTemplatesWithResponse call
func ParseGetServerTemplatesResponse(rsp *http.Response) (*GetServerTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerTemplateResponse parses an HTTP response from a CreateServerTemplateWithResponse call
func ParseCreateServerTemplateResponse(rsp *http.Response) (*CreateServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerTemplateResponse parses an HTTP response from a DeleteServerTemplateWithResponse call
func ParseDeleteServerTemplateResponse(rsp *http.Response) (*DeleteServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplateResponse parses an HTTP response from a GetServerTemplateWithResponse call
func ParseGetServerTemplateResponse(rsp *http.Response) (*GetServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerTemplateResponse parses an HTTP response from a ReplaceServerTemplateWithResponse call
func ParseReplaceServerTemplateResponse(rsp *http.Response) (*ReplaceServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerBackendResponse parses an HTTP response from a GetAllServerBackendWithResponse call
func ParseGetAllServerBackendResponse(rsp *http.Response) (*GetAllServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerBackendResponse parses an HTTP response from a CreateServerBackendWithResponse call
func ParseCreateServerBackendResponse(rsp *http.Response) (*CreateServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerBackendResponse parses an HTTP response from a DeleteServerBackendWithResponse call
func ParseDeleteServerBackendResponse(rsp *http.Response) (*DeleteServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerBackendResponse parses an HTTP response from a GetServerBackendWithResponse call
func ParseGetServerBackendResponse(rsp *http.Response) (*GetServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerBackendResponse parses an HTTP response from a ReplaceServerBackendWithResponse call
func ParseReplaceServerBackendResponse(rsp *http.Response) (*ReplaceServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRulesResponse parses an HTTP response from a GetStickRulesWithResponse call
func ParseGetStickRulesResponse(rsp *http.Response) (*GetStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRulesResponse parses an HTTP response from a ReplaceStickRulesWithResponse call
func ParseReplaceStickRulesResponse(rsp *http.Response) (*ReplaceStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStickRuleResponse parses an HTTP response from a DeleteStickRuleWithResponse call
func ParseDeleteStickRuleResponse(rsp *http.Response) (*DeleteStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRuleResponse parses an HTTP response from a GetStickRuleWithResponse call
func ParseGetStickRuleResponse(rsp *http.Response) (*GetStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStickRuleResponse parses an HTTP response from a CreateStickRuleWithResponse call
func ParseCreateStickRuleResponse(rsp *http.Response) (*CreateStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRuleResponse parses an HTTP response from a ReplaceStickRuleWithResponse call
func ParseReplaceStickRuleResponse(rsp *http.Response) (*ReplaceStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckBackendResponse parses an HTTP response from a GetAllTCPCheckBackendWithResponse call
func ParseGetAllTCPCheckBackendResponse(rsp *http.Response) (*GetAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckBackendResponse parses an HTTP response from a ReplaceAllTCPCheckBackendWithResponse call
func ParseReplaceAllTCPCheckBackendResponse(rsp *http.Response) (*ReplaceAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckBackendResponse parses an HTTP response from a DeleteTCPCheckBackendWithResponse call
func ParseDeleteTCPCheckBackendResponse(rsp *http.Response) (*DeleteTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckBackendResponse parses an HTTP response from a GetTCPCheckBackendWithResponse call
func ParseGetTCPCheckBackendResponse(rsp *http.Response) (*GetTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckBackendResponse parses an HTTP response from a CreateTCPCheckBackendWithResponse call
func ParseCreateTCPCheckBackendResponse(rsp *http.Response) (*CreateTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckBackendResponse parses an HTTP response from a ReplaceTCPCheckBackendWithResponse call
func ParseReplaceTCPCheckBackendResponse(rsp *http.Response) (*ReplaceTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleBackendResponse parses an HTTP response from a GetAllTCPRequestRuleBackendWithResponse call
func ParseGetAllTCPRequestRuleBackendResponse(rsp *http.Response) (*GetAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleBackendWithResponse call
func ParseReplaceAllTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleBackendResponse parses an HTTP response from a DeleteTCPRequestRuleBackendWithResponse call
func ParseDeleteTCPRequestRuleBackendResponse(rsp *http.Response) (*DeleteTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleBackendResponse parses an HTTP response from a GetTCPRequestRuleBackendWithResponse call
func ParseGetTCPRequestRuleBackendResponse(rsp *http.Response) (*GetTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleBackendResponse parses an HTTP response from a CreateTCPRequestRuleBackendWithResponse call
func ParseCreateTCPRequestRuleBackendResponse(rsp *http.Response) (*CreateTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceTCPRequestRuleBackendWithResponse call
func ParseReplaceTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPResponseRuleBackendResponse parses an HTTP response from a GetAllTCPResponseRuleBackendWithResponse call
func ParseGetAllTCPResponseRuleBackendResponse(rsp *http.Response) (*GetAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllTCPResponseRuleBackendWithResponse call
func ParseReplaceAllTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPResponseRuleBackendResponse parses an HTTP response from a DeleteTCPResponseRuleBackendWithResponse call
func ParseDeleteTCPResponseRuleBackendResponse(rsp *http.Response) (*DeleteTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPResponseRuleBackendResponse parses an HTTP response from a GetTCPResponseRuleBackendWithResponse call
func ParseGetTCPResponseRuleBackendResponse(rsp *http.Response) (*GetTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPResponseRuleBackendResponse parses an HTTP response from a CreateTCPResponseRuleBackendWithResponse call
func ParseCreateTCPResponseRuleBackendResponse(rsp *http.Response) (*CreateTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceTCPResponseRuleBackendWithResponse call
func ParseReplaceTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCachesResponse parses an HTTP response from a GetCachesWithResponse call
func ParseGetCachesResponse(rsp *http.Response) (*GetCachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Caches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCacheResponse parses an HTTP response from a CreateCacheWithResponse call
func ParseCreateCacheResponse(rsp *http.Response) (*CreateCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCacheResponse parses an HTTP response from a DeleteCacheWithResponse call
func ParseDeleteCacheResponse(rsp *http.Response) (*DeleteCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCacheResponse parses an HTTP response from a GetCacheWithResponse call
func ParseGetCacheResponse(rsp *http.Response) (*GetCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCacheResponse parses an HTTP response from a ReplaceCacheWithResponse call
func ParseReplaceCacheResponse(rsp *http.Response) (*ReplaceCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadsResponse parses an HTTP response from a GetCrtLoadsWithResponse call
func ParseGetCrtLoadsResponse(rsp *http.Response) (*GetCrtLoadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtLoadResponse parses an HTTP response from a CreateCrtLoadWithResponse call
func ParseCreateCrtLoadResponse(rsp *http.Response) (*CreateCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtLoadResponse parses an HTTP response from a DeleteCrtLoadWithResponse call
func ParseDeleteCrtLoadResponse(rsp *http.Response) (*DeleteCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadResponse parses an HTTP response from a GetCrtLoadWithResponse call
func ParseGetCrtLoadResponse(rsp *http.Response) (*GetCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCrtLoadResponse parses an HTTP response from a ReplaceCrtLoadWithResponse call
func ParseReplaceCrtLoadResponse(rsp *http.Response) (*ReplaceCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoresResponse parses an HTTP response from a GetCrtStoresWithResponse call
func ParseGetCrtStoresResponse(rsp *http.Response) (*GetCrtStoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtStoreResponse parses an HTTP response from a CreateCrtStoreWithResponse call
func ParseCreateCrtStoreResponse(rsp *http.Response) (*CreateCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtStoreResponse parses an HTTP response from a DeleteCrtStoreWithResponse call
func ParseDeleteCrtStoreResponse(rsp *http.Response) (*DeleteCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoreResponse parses an HTTP response from a GetCrtStoreWithResponse call
func ParseGetCrtStoreResponse(rsp *http.Response) (*GetCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditCrtStoreResponse parses an HTTP response from a EditCrtStoreWithResponse call
func ParseEditCrtStoreResponse(rsp *http.Response) (*EditCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionsResponse parses an HTTP response from a GetDefaultsSectionsWithResponse call
func ParseGetDefaultsSectionsResponse(rsp *http.Response) (*GetDefaultsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefaultsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddDefaultsSectionResponse parses an HTTP response from a AddDefaultsSectionWithResponse call
func ParseAddDefaultsSectionResponse(rsp *http.Response) (*AddDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDefaultsSectionResponse parses an HTTP response from a CreateDefaultsSectionWithResponse call
func ParseCreateDefaultsSectionResponse(rsp *http.Response) (*CreateDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDefaultsSectionResponse parses an HTTP response from a DeleteDefaultsSectionWithResponse call
func ParseDeleteDefaultsSectionResponse(rsp *http.Response) (*DeleteDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionResponse parses an HTTP response from a GetDefaultsSectionWithResponse call
func ParseGetDefaultsSectionResponse(rsp *http.Response) (*GetDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDefaultsSectionResponse parses an HTTP response from a ReplaceDefaultsSectionWithResponse call
func ParseReplaceDefaultsSectionResponse(rsp *http.Response) (*ReplaceDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckDefaultsResponse parses an HTTP response from a GetAllHTTPCheckDefaultsWithResponse call
func ParseGetAllHTTPCheckDefaultsResponse(rsp *http.Response) (*GetAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceAllHTTPCheckDefaultsWithResponse call
func ParseReplaceAllHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckDefaultsResponse parses an HTTP response from a DeleteHTTPCheckDefaultsWithResponse call
func ParseDeleteHTTPCheckDefaultsResponse(rsp *http.Response) (*DeleteHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckDefaultsResponse parses an HTTP response from a GetHTTPCheckDefaultsWithResponse call
func ParseGetHTTPCheckDefaultsResponse(rsp *http.Response) (*GetHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckDefaultsResponse parses an HTTP response from a CreateHTTPCheckDefaultsWithResponse call
func ParseCreateHTTPCheckDefaultsResponse(rsp *http.Response) (*CreateHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceHTTPCheckDefaultsWithResponse call
func ParseReplaceHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetAllHTTPErrorRuleDefaultsWithResponse call
func ParseGetAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleDefaultsResponse parses an HTTP response from a DeleteHTTPErrorRuleDefaultsWithResponse call
func ParseDeleteHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetHTTPErrorRuleDefaultsWithResponse call
func ParseGetHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleDefaultsResponse parses an HTTP response from a CreateHTTPErrorRuleDefaultsWithResponse call
func ParseCreateHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetDefaultsResponse parses an HTTP response from a GetAllLogTargetDefaultsWithResponse call
func ParseGetAllLogTargetDefaultsResponse(rsp *http.Response) (*GetAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetDefaultsResponse parses an HTTP response from a ReplaceAllLogTargetDefaultsWithResponse call
func ParseReplaceAllLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetDefaultsResponse parses an HTTP response from a DeleteLogTargetDefaultsWithResponse call
func ParseDeleteLogTargetDefaultsResponse(rsp *http.Response) (*DeleteLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetDefaultsResponse parses an HTTP response from a GetLogTargetDefaultsWithResponse call
func ParseGetLogTargetDefaultsResponse(rsp *http.Response) (*GetLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetDefaultsResponse parses an HTTP response from a CreateLogTargetDefaultsWithResponse call
func ParseCreateLogTargetDefaultsResponse(rsp *http.Response) (*CreateLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetDefaultsResponse parses an HTTP response from a ReplaceLogTargetDefaultsWithResponse call
func ParseReplaceLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllQUICInitialRuleDefaultsResponse parses an HTTP response from a GetAllQUICInitialRuleDefaultsWithResponse call
func ParseGetAllQUICInitialRuleDefaultsResponse(rsp *http.Response) (*GetAllQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllQUICInitialRuleDefaultsResponse parses an HTTP response from a ReplaceAllQUICInitialRuleDefaultsWithResponse call
func ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteQUICInitialRuleDefaultsResponse parses an HTTP response from a DeleteQUICInitialRuleDefaultsWithResponse call
func ParseDeleteQUICInitialRuleDefaultsResponse(rsp *http.Response) (*DeleteQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetQUICInitialRuleDefaultsResponse parses an HTTP response from a GetQUICInitialRuleDefaultsWithResponse call
func ParseGetQUICInitialRuleDefaultsResponse(rsp *http.Response) (*GetQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateQUICInitialRuleDefaultsResponse parses an HTTP response from a CreateQUICInitialRuleDefaultsWithResponse call
func ParseCreateQUICInitialRuleDefaultsResponse(rsp *http.Response) (*CreateQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceQUICInitialRuleDefaultsResponse parses an HTTP response from a ReplaceQUICInitialRuleDefaultsWithResponse call
func ParseReplaceQUICInitialRuleDefaultsResponse(rsp *http.Response) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckDefaultsResponse parses an HTTP response from a GetAllTCPCheckDefaultsWithResponse call
func ParseGetAllTCPCheckDefaultsResponse(rsp *http.Response) (*GetAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckDefaultsResponse parses an HTTP response from a ReplaceAllTCPCheckDefaultsWithResponse call
func ParseReplaceAllTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckDefaultsResponse parses an HTTP response from a DeleteTCPCheckDefaultsWithResponse call
func ParseDeleteTCPCheckDefaultsResponse(rsp *http.Response) (*DeleteTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckDefaultsResponse parses an HTTP response from a GetTCPCheckDefaultsWithResponse call
func ParseGetTCPCheckDefaultsResponse(rsp *http.Response) (*GetTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckDefaultsResponse parses an HTTP response from a CreateTCPCheckDefaultsWithResponse call
func ParseCreateTCPCheckDefaultsResponse(rsp *http.Response) (*CreateTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckDefaultsResponse parses an HTTP response from a ReplaceTCPCheckDefaultsWithResponse call
func ParseReplaceTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppsResponse parses an HTTP response from a GetFCGIAppsWithResponse call
func ParseGetFCGIAppsResponse(rsp *http.Response) (*GetFCGIAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FcgiApps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFCGIAppResponse parses an HTTP response from a CreateFCGIAppWithResponse call
func ParseCreateFCGIAppResponse(rsp *http.Response) (*CreateFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFCGIAppResponse parses an HTTP response from a DeleteFCGIAppWithResponse call
func ParseDeleteFCGIAppResponse(rsp *http.Response) (*DeleteFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppResponse parses an HTTP response from a GetFCGIAppWithResponse call
func ParseGetFCGIAppResponse(rsp *http.Response) (*GetFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFCGIAppResponse parses an HTTP response from a ReplaceFCGIAppWithResponse call
func ParseReplaceFCGIAppResponse(rsp *http.Response) (*ReplaceFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFCGIAppResponse parses an HTTP response from a GetAllAclFCGIAppWithResponse call
func ParseGetAllAclFCGIAppResponse(rsp *http.Response) (*GetAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFCGIAppResponse parses an HTTP response from a ReplaceAllAclFCGIAppWithResponse call
func ParseReplaceAllAclFCGIAppResponse(rsp *http.Response) (*ReplaceAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFCGIAppResponse parses an HTTP response from a DeleteAclFCGIAppWithResponse call
func ParseDeleteAclFCGIAppResponse(rsp *http.Response) (*DeleteAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFCGIAppResponse parses an HTTP response from a GetAclFCGIAppWithResponse call
func ParseGetAclFCGIAppResponse(rsp *http.Response) (*GetAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFCGIAppResponse parses an HTTP response from a CreateAclFCGIAppWithResponse call
func ParseCreateAclFCGIAppResponse(rsp *http.Response) (*CreateAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFCGIAppResponse parses an HTTP response from a ReplaceAclFCGIAppWithResponse call
func ParseReplaceAclFCGIAppResponse(rsp *http.Response) (*ReplaceAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendsResponse parses an HTTP response from a GetFrontendsWithResponse call
func ParseGetFrontendsResponse(rsp *http.Response) (*GetFrontendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFrontendResponse parses an HTTP response from a CreateFrontendWithResponse call
func ParseCreateFrontendResponse(rsp *http.Response) (*CreateFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFrontendResponse parses an HTTP response from a DeleteFrontendWithResponse call
func ParseDeleteFrontendResponse(rsp *http.Response) (*DeleteFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendResponse parses an HTTP response from a GetFrontendWithResponse call
func ParseGetFrontendResponse(rsp *http.Response) (*GetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFrontendResponse parses an HTTP response from a ReplaceFrontendWithResponse call
func ParseReplaceFrontendResponse(rsp *http.Response) (*ReplaceFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFrontendResponse parses an HTTP response from a GetAllAclFrontendWithResponse call
func ParseGetAllAclFrontendResponse(rsp *http.Response) (*GetAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFrontendResponse parses an HTTP response from a ReplaceAllAclFrontendWithResponse call
func ParseReplaceAllAclFrontendResponse(rsp *http.Response) (*ReplaceAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFrontendResponse parses an HTTP response from a DeleteAclFrontendWithResponse call
func ParseDeleteAclFrontendResponse(rsp *http.Response) (*DeleteAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFrontendResponse parses an HTTP response from a GetAclFrontendWithResponse call
func ParseGetAclFrontendResponse(rsp *http.Response) (*GetAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFrontendResponse parses an HTTP response from a CreateAclFrontendWithResponse call
func ParseCreateAclFrontendResponse(rsp *http.Response) (*CreateAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFrontendResponse parses an HTTP response from a ReplaceAclFrontendWithResponse call
func ParseReplaceAclFrontendResponse(rsp *http.Response) (*ReplaceAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRulesResponse parses an HTTP response from a GetBackendSwitchingRulesWithResponse call
func ParseGetBackendSwitchingRulesResponse(rsp *http.Response) (*GetBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRulesResponse parses an HTTP response from a ReplaceBackendSwitchingRulesWithResponse call
func ParseReplaceBackendSwitchingRulesResponse(rsp *http.Response) (*ReplaceBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendSwitchingRuleResponse parses an HTTP response from a DeleteBackendSwitchingRuleWithResponse call
func ParseDeleteBackendSwitchingRuleResponse(rsp *http.Response) (*DeleteBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRuleResponse parses an HTTP response from a GetBackendSwitchingRuleWithResponse call
func ParseGetBackendSwitchingRuleResponse(rsp *http.Response) (*GetBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendSwitchingRuleResponse parses an HTTP response from a CreateBackendSwitchingRuleWithResponse call
func ParseCreateBackendSwitchingRuleResponse(rsp *http.Response) (*CreateBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRuleResponse parses an HTTP response from a ReplaceBackendSwitchingRuleWithResponse call
func ParseReplaceBackendSwitchingRuleResponse(rsp *http.Response) (*ReplaceBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindFrontendResponse parses an HTTP response from a GetAllBindFrontendWithResponse call
func ParseGetAllBindFrontendResponse(rsp *http.Response) (*GetAllBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindFrontendResponse parses an HTTP response from a CreateBindFrontendWithResponse call
func ParseCreateBindFrontendResponse(rsp *http.Response) (*CreateBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindFrontendResponse parses an HTTP response from a DeleteBindFrontendWithResponse call
func ParseDeleteBindFrontendResponse(rsp *http.Response) (*DeleteBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindFrontendResponse parses an HTTP response from a GetBindFrontendWithResponse call
func ParseGetBindFrontendResponse(rsp *http.Response) (*GetBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindFrontendResponse parses an HTTP response from a ReplaceBindFrontendWithResponse call
func ParseReplaceBindFrontendResponse(rsp *http.Response) (*ReplaceBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCapturesResponse parses an HTTP response from a GetDeclareCapturesWithResponse call
func ParseGetDeclareCapturesResponse(rsp *http.Response) (*GetDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCapturesResponse parses an HTTP response from a ReplaceDeclareCapturesWithResponse call
func ParseReplaceDeclareCapturesResponse(rsp *http.Response) (*ReplaceDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDeclareCaptureResponse parses an HTTP response from a DeleteDeclareCaptureWithResponse call
func ParseDeleteDeclareCaptureResponse(rsp *http.Response) (*DeleteDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCaptureResponse parses an HTTP response from a GetDeclareCaptureWithResponse call
func ParseGetDeclareCaptureResponse(rsp *http.Response) (*GetDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDeclareCaptureResponse parses an HTTP response from a CreateDeclareCaptureWithResponse call
func ParseCreateDeclareCaptureResponse(rsp *http.Response) (*CreateDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCaptureResponse parses an HTTP response from a ReplaceDeclareCaptureWithResponse call
func ParseReplaceDeclareCaptureResponse(rsp *http.Response) (*ReplaceDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterFrontendResponse parses an HTTP response from a GetAllFilterFrontendWithResponse call
func ParseGetAllFilterFrontendResponse(rsp *http.Response) (*GetAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterFrontendResponse parses an HTTP response from a ReplaceAllFilterFrontendWithResponse call
func ParseReplaceAllFilterFrontendResponse(rsp *http.Response) (*ReplaceAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterFrontendResponse parses an HTTP response from a DeleteFilterFrontendWithResponse call
func ParseDeleteFilterFrontendResponse(rsp *http.Response) (*DeleteFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterFrontendResponse parses an HTTP response from a GetFilterFrontendWithResponse call
func ParseGetFilterFrontendResponse(rsp *http.Response) (*GetFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterFrontendResponse parses an HTTP response from a CreateFilterFrontendWithResponse call
func ParseCreateFilterFrontendResponse(rsp *http.Response) (*CreateFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterFrontendResponse parses an HTTP response from a ReplaceFilterFrontendWithResponse call
func ParseReplaceFilterFrontendResponse(rsp *http.Response) (*ReplaceFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleFrontendWithResponse call
func ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleFrontendWithResponse call
func ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleFrontendResponse parses an HTTP response from a GetAllHTTPErrorRuleFrontendWithResponse call
func ParseGetAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleFrontendWithResponse call
func ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleFrontendResponse parses an HTTP response from a DeleteHTTPErrorRuleFrontendWithResponse call
func ParseDeleteHTTPErrorRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleFrontendResponse parses an HTTP response from a GetHTTPErrorRuleFrontendWithResponse call
func ParseGetHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleFrontendResponse parses an HTTP response from a CreateHTTPErrorRuleFrontendWithResponse call
func ParseCreateHTTPErrorRuleFrontendResponse(rsp *http.Response) (*CreateHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceHTTPErrorRuleFrontendWithResponse call
func ParseReplaceHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleFrontendResponse parses an HTTP response from a GetAllHTTPRequestRuleFrontendWithResponse call
func ParseGetAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleFrontendWithResponse call
func ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleFrontendResponse parses an HTTP response from a DeleteHTTPRequestRuleFrontendWithResponse call
func ParseDeleteHTTPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleFrontendResponse parses an HTTP response from a GetHTTPRequestRuleFrontendWithResponse call
func ParseGetHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleFrontendResponse parses an HTTP response from a CreateHTTPRequestRuleFrontendWithResponse call
func ParseCreateHTTPRequestRuleFrontendResponse(rsp *http.Response) (*CreateHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceHTTPRequestRuleFrontendWithResponse call
func ParseReplaceHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPResponseRuleFrontendWithResponse call
func ParseGetAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPResponseRuleFrontendWithResponse call
func ParseDeleteHTTPResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleFrontendResponse parses an HTTP response from a GetHTTPResponseRuleFrontendWithResponse call
func ParseGetHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPResponseRuleFrontendWithResponse call
func ParseCreateHTTPResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPResponseRuleFrontendWithResponse call
func ParseReplaceHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetFrontendResponse parses an HTTP response from a GetAllLogTargetFrontendWithResponse call
func ParseGetAllLogTargetFrontendResponse(rsp *http.Response) (*GetAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetFrontendResponse parses an HTTP response from a ReplaceAllLogTargetFrontendWithResponse call
func ParseReplaceAllLogTargetFrontendResponse(rsp *http.Response) (*ReplaceAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetFrontendResponse parses an HTTP response from a DeleteLogTargetFrontendWithResponse call
func ParseDeleteLogTargetFrontendResponse(rsp *http.Response) (*DeleteLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetFrontendResponse parses an HTTP response from a GetLogTargetFrontendWithResponse call
func ParseGetLogTargetFrontendResponse(rsp *http.Response) (*GetLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetFrontendResponse parses an HTTP response from a CreateLogTargetFrontendWithResponse call
func ParseCreateLogTargetFrontendResponse(rsp *http.Response) (*CreateLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetFrontendResponse parses an HTTP response from a ReplaceLogTargetFrontendWithResponse call
func ParseReplaceLogTargetFrontendResponse(rsp *http.Response) (*ReplaceLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllQUICInitialRuleFrontendResponse parses an HTTP response from a GetAllQUICInitialRuleFrontendWithResponse call
func ParseGetAllQUICInitialRuleFrontendResponse(rsp *http.Response) (*GetAllQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllQUICInitialRuleFrontendResponse parses an HTTP response from a ReplaceAllQUICInitialRuleFrontendWithResponse call
func ParseReplaceAllQUICInitialRuleFrontendResponse(rsp *http.Response) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteQUICInitialRuleFrontendResponse parses an HTTP response from a DeleteQUICInitialRuleFrontendWithResponse call
func ParseDeleteQUICInitialRuleFrontendResponse(rsp *http.Response) (*DeleteQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetQUICInitialRuleFrontendResponse parses an HTTP response from a GetQUICInitialRuleFrontendWithResponse call
func ParseGetQUICInitialRuleFrontendResponse(rsp *http.Response) (*GetQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateQUICInitialRuleFrontendResponse parses an HTTP response from a CreateQUICInitialRuleFrontendWithResponse call
func ParseCreateQUICInitialRuleFrontendResponse(rsp *http.Response) (*CreateQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceQUICInitialRuleFrontendResponse parses an HTTP response from a ReplaceQUICInitialRuleFrontendWithResponse call
func ParseReplaceQUICInitialRuleFrontendResponse(rsp *http.Response) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleFrontendResponse parses an HTTP response from a GetAllTCPRequestRuleFrontendWithResponse call
func ParseGetAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleFrontendWithResponse call
func ParseReplaceAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleFrontendResponse parses an HTTP response from a DeleteTCPRequestRuleFrontendWithResponse call
func ParseDeleteTCPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleFrontendResponse parses an HTTP response from a GetTCPRequestRuleFrontendWithResponse call
func ParseGetTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleFrontendResponse parses an HTTP response from a CreateTCPRequestRuleFrontendWithResponse call
func ParseCreateTCPRequestRuleFrontendResponse(rsp *http.Response) (*CreateTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceTCPRequestRuleFrontendWithResponse call
func ParseReplaceTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGlobalResponse parses an HTTP response from a ReplaceGlobalWithResponse call
func ParseReplaceGlobalResponse(rsp *http.Response) (*ReplaceGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetGlobalResponse parses an HTTP response from a GetAllLogTargetGlobalWithResponse call
func ParseGetAllLogTargetGlobalResponse(rsp *http.Response) (*GetAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetGlobalResponse parses an HTTP response from a ReplaceAllLogTargetGlobalWithResponse call
func ParseReplaceAllLogTargetGlobalResponse(rsp *http.Response) (*ReplaceAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetGlobalResponse parses an HTTP response from a DeleteLogTargetGlobalWithResponse call
func ParseDeleteLogTargetGlobalResponse(rsp *http.Response) (*DeleteLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetGlobalResponse parses an HTTP response from a GetLogTargetGlobalWithResponse call
func ParseGetLogTargetGlobalResponse(rsp *http.Response) (*GetLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetGlobalResponse parses an HTTP response from a CreateLogTargetGlobalWithResponse call
func ParseCreateLogTargetGlobalResponse(rsp *http.Response) (*CreateLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetGlobalResponse parses an HTTP response from a ReplaceLogTargetGlobalWithResponse call
func ParseReplaceLogTargetGlobalResponse(rsp *http.Response) (*ReplaceLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Groups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGroupResponse parses an HTTP response from a ReplaceGroupWithResponse call
func ParseReplaceGroupResponse(rsp *http.Response) (*ReplaceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionsResponse parses an HTTP response from a GetHTTPErrorsSectionsWithResponse call
func ParseGetHTTPErrorsSectionsResponse(rsp *http.Response) (*GetHTTPErrorsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorsSectionResponse parses an HTTP response from a CreateHTTPErrorsSectionWithResponse call
func ParseCreateHTTPErrorsSectionResponse(rsp *http.Response) (*CreateHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorsSectionResponse parses an HTTP response from a DeleteHTTPErrorsSectionWithResponse call
func ParseDeleteHTTPErrorsSectionResponse(rsp *http.Response) (*DeleteHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionResponse parses an HTTP response from a GetHTTPErrorsSectionWithResponse call
func ParseGetHTTPErrorsSectionResponse(rsp *http.Response) (*GetHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorsSectionResponse parses an HTTP response from a ReplaceHTTPErrorsSectionWithResponse call
func ParseReplaceHTTPErrorsSectionResponse(rsp *http.Response) (*ReplaceHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardsResponse parses an HTTP response from a GetLogForwardsWithResponse call
func ParseGetLogForwardsResponse(rsp *http.Response) (*GetLogForwardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForwards
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogForwardResponse parses an HTTP response from a CreateLogForwardWithResponse call
func ParseCreateLogForwardResponse(rsp *http.Response) (*CreateLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogForwardResponse parses an HTTP response from a DeleteLogForwardWithResponse call
func ParseDeleteLogForwardResponse(rsp *http.Response) (*DeleteLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardResponse parses an HTTP response from a GetLogForwardWithResponse call
func ParseGetLogForwardResponse(rsp *http.Response) (*GetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogForwardResponse parses an HTTP response from a ReplaceLogForwardWithResponse call
func ParseReplaceLogForwardResponse(rsp *http.Response) (*ReplaceLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindLogForwardResponse parses an HTTP response from a GetAllBindLogForwardWithResponse call
func ParseGetAllBindLogForwardResponse(rsp *http.Response) (*GetAllBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindLogForwardResponse parses an HTTP response from a CreateBindLogForwardWithResponse call
func ParseCreateBindLogForwardResponse(rsp *http.Response) (*CreateBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindLogForwardResponse parses an HTTP response from a DeleteBindLogForwardWithResponse call
func ParseDeleteBindLogForwardResponse(rsp *http.Response) (*DeleteBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindLogForwardResponse parses an HTTP response from a GetBindLogForwardWithResponse call
func ParseGetBindLogForwardResponse(rsp *http.Response) (*GetBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindLogForwardResponse parses an HTTP response from a ReplaceBindLogForwardWithResponse call
func ParseReplaceBindLogForwardResponse(rsp *http.Response) (*ReplaceBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindsResponse parses an HTTP response from a GetDgramBindsWithResponse call
func ParseGetDgramBindsResponse(rsp *http.Response) (*GetDgramBindsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBinds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDgramBindResponse parses an HTTP response from a CreateDgramBindWithResponse call
func ParseCreateDgramBindResponse(rsp *http.Response) (*CreateDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDgramBindResponse parses an HTTP response from a DeleteDgramBindWithResponse call
func ParseDeleteDgramBindResponse(rsp *http.Response) (*DeleteDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindResponse parses an HTTP response from a GetDgramBindWithResponse call
func ParseGetDgramBindResponse(rsp *http.Response) (*GetDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDgramBindResponse parses an HTTP response from a ReplaceDgramBindWithResponse call
func ParseReplaceDgramBindResponse(rsp *http.Response) (*ReplaceDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetLogForwardResponse parses an HTTP response from a GetAllLogTargetLogForwardWithResponse call
func ParseGetAllLogTargetLogForwardResponse(rsp *http.Response) (*GetAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetLogForwardResponse parses an HTTP response from a ReplaceAllLogTargetLogForwardWithResponse call
func ParseReplaceAllLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetLogForwardResponse parses an HTTP response from a DeleteLogTargetLogForwardWithResponse call
func ParseDeleteLogTargetLogForwardResponse(rsp *http.Response) (*DeleteLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetLogForwardResponse parses an HTTP response from a GetLogTargetLogForwardWithResponse call
func ParseGetLogTargetLogForwardResponse(rsp *http.Response) (*GetLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetLogForwardResponse parses an HTTP response from a CreateLogTargetLogForwardWithResponse call
func ParseCreateLogTargetLogForwardResponse(rsp *http.Response) (*CreateLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetLogForwardResponse parses an HTTP response from a ReplaceLogTargetLogForwardWithResponse call
func ParseReplaceLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogProfilesResponse parses an HTTP response from a GetLogProfilesWithResponse call
func ParseGetLogProfilesResponse(rsp *http.Response) (*GetLogProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogProfileResponse parses an HTTP response from a CreateLogProfileWithResponse call
func ParseCreateLogProfileResponse(rsp *http.Response) (*CreateLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogProfileResponse parses an HTTP response from a DeleteLogProfileWithResponse call
func ParseDeleteLogProfileResponse(rsp *http.Response) (*DeleteLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogProfileResponse parses an HTTP response from a GetLogProfileWithResponse call
func ParseGetLogProfileResponse(rsp *http.Response) (*GetLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditLogProfileResponse parses an HTTP response from a EditLogProfileWithResponse call
func ParseEditLogProfileResponse(rsp *http.Response) (*EditLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntriesResponse parses an HTTP response from a GetMailerEntriesWithResponse call
func ParseGetMailerEntriesResponse(rsp *http.Response) (*GetMailerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailerEntryResponse parses an HTTP response from a CreateMailerEntryWithResponse call
func ParseCreateMailerEntryResponse(rsp *http.Response) (*CreateMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailerEntryResponse parses an HTTP response from a DeleteMailerEntryWithResponse call
func ParseDeleteMailerEntryResponse(rsp *http.Response) (*DeleteMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntryResponse parses an HTTP response from a GetMailerEntryWithResponse call
func ParseGetMailerEntryResponse(rsp *http.Response) (*GetMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceMailerEntryResponse parses an HTTP response from a ReplaceMailerEntryWithResponse call
func ParseReplaceMailerEntryResponse(rsp *http.Response) (*ReplaceMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionsResponse parses an HTTP response from a GetMailersSectionsWithResponse call
func ParseGetMailersSectionsResponse(rsp *http.Response) (*GetMailersSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailersSectionResponse parses an HTTP response from a CreateMailersSectionWithResponse call
func ParseCreateMailersSectionResponse(rsp *http.Response) (*CreateMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailersSectionResponse parses an HTTP response from a DeleteMailersSectionWithResponse call
func ParseDeleteMailersSectionResponse(rsp *http.Response) (*DeleteMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionResponse parses an HTTP response from a GetMailersSectionWithResponse call
func ParseGetMailersSectionResponse(rsp *http.Response) (*GetMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditMailersSectionResponse parses an HTTP response from a EditMailersSectionWithResponse call
func ParseEditMailersSectionResponse(rsp *http.Response) (*EditMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserversResponse parses an HTTP response from a GetNameserversWithResponse call
func ParseGetNameserversResponse(rsp *http.Response) (*GetNameserversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameservers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNameserverResponse parses an HTTP response from a CreateNameserverWithResponse call
func ParseCreateNameserverResponse(rsp *http.Response) (*CreateNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNameserverResponse parses an HTTP response from a DeleteNameserverWithResponse call
func ParseDeleteNameserverResponse(rsp *http.Response) (*DeleteNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserverResponse parses an HTTP response from a GetNameserverWithResponse call
func ParseGetNameserverResponse(rsp *http.Response) (*GetNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceNameserverResponse parses an HTTP response from a ReplaceNameserverWithResponse call
func ParseReplaceNameserverResponse(rsp *http.Response) (*ReplaceNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntriesResponse parses an HTTP response from a GetPeerEntriesWithResponse call
func ParseGetPeerEntriesResponse(rsp *http.Response) (*GetPeerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerEntryResponse parses an HTTP response from a CreatePeerEntryWithResponse call
func ParseCreatePeerEntryResponse(rsp *http.Response) (*CreatePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerEntryResponse parses an HTTP response from a DeletePeerEntryWithResponse call
func ParseDeletePeerEntryResponse(rsp *http.Response) (*DeletePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntryResponse parses an HTTP response from a GetPeerEntryWithResponse call
func ParseGetPeerEntryResponse(rsp *http.Response) (*GetPeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplacePeerEntryResponse parses an HTTP response from a ReplacePeerEntryWithResponse call
func ParseReplacePeerEntryResponse(rsp *http.Response) (*ReplacePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplacePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionsResponse parses an HTTP response from a GetPeerSectionsWithResponse call
func ParseGetPeerSectionsResponse(rsp *http.Response) (*GetPeerSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerResponse parses an HTTP response from a CreatePeerWithResponse call
func ParseCreatePeerResponse(rsp *http.Response) (*CreatePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerResponse parses an HTTP response from a DeletePeerWithResponse call
func ParseDeletePeerResponse(rsp *http.Response) (*DeletePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionResponse parses an HTTP response from a GetPeerSectionWithResponse call
func ParseGetPeerSectionResponse(rsp *http.Response) (*GetPeerSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindPeerResponse parses an HTTP response from a GetAllBindPeerWithResponse call
func ParseGetAllBindPeerResponse(rsp *http.Response) (*GetAllBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindPeerResponse parses an HTTP response from a CreateBindPeerWithResponse call
func ParseCreateBindPeerResponse(rsp *http.Response) (*CreateBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindPeerResponse parses an HTTP response from a DeleteBindPeerWithResponse call
func ParseDeleteBindPeerResponse(rsp *http.Response) (*DeleteBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindPeerResponse parses an HTTP response from a GetBindPeerWithResponse call
func ParseGetBindPeerResponse(rsp *http.Response) (*GetBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindPeerResponse parses an HTTP response from a ReplaceBindPeerWithResponse call
func ParseReplaceBindPeerResponse(rsp *http.Response) (*ReplaceBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetPeerResponse parses an HTTP response from a GetAllLogTargetPeerWithResponse call
func ParseGetAllLogTargetPeerResponse(rsp *http.Response) (*GetAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetPeerResponse parses an HTTP response from a ReplaceAllLogTargetPeerWithResponse call
func ParseReplaceAllLogTargetPeerResponse(rsp *http.Response) (*ReplaceAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetPeerResponse parses an HTTP response from a DeleteLogTargetPeerWithResponse call
func ParseDeleteLogTargetPeerResponse(rsp *http.Response) (*DeleteLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetPeerResponse parses an HTTP response from a GetLogTargetPeerWithResponse call
func ParseGetLogTargetPeerResponse(rsp *http.Response) (*GetLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetPeerResponse parses an HTTP response from a CreateLogTargetPeerWithResponse call
func ParseCreateLogTargetPeerResponse(rsp *http.Response) (*CreateLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetPeerResponse parses an HTTP response from a ReplaceLogTargetPeerWithResponse call
func ParseReplaceLogTargetPeerResponse(rsp *http.Response) (*ReplaceLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerPeerResponse parses an HTTP response from a GetAllServerPeerWithResponse call
func ParseGetAllServerPeerResponse(rsp *http.Response) (*GetAllServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerPeerResponse parses an HTTP response from a CreateServerPeerWithResponse call
func ParseCreateServerPeerResponse(rsp *http.Response) (*CreateServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerPeerResponse parses an HTTP response from a DeleteServerPeerWithResponse call
func ParseDeleteServerPeerResponse(rsp *http.Response) (*DeleteServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerPeerResponse parses an HTTP response from a GetServerPeerWithResponse call
func ParseGetServerPeerResponse(rsp *http.Response) (*GetServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerPeerResponse parses an HTTP response from a ReplaceServerPeerWithResponse call
func ParseReplaceServerPeerResponse(rsp *http.Response) (*ReplaceServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTablesResponse parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesResponse(rsp *http.Response) (*GetTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTableResponse parses an HTTP response from a ReplaceTableWithResponse call
func ParseReplaceTableResponse(rsp *http.Response) (*ReplaceTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramsResponse parses an HTTP response from a GetProgramsWithResponse call
func ParseGetProgramsResponse(rsp *http.Response) (*GetProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Programs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProgramResponse parses an HTTP response from a CreateProgramWithResponse call
func ParseCreateProgramResponse(rsp *http.Response) (*CreateProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProgramResponse parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResponse(rsp *http.Response) (*DeleteProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceProgramResponse parses an HTTP response from a ReplaceProgramWithResponse call
func ParseReplaceProgramResponse(rsp *http.Response) (*ReplaceProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHAProxyConfigurationResponse parses an HTTP response from a GetHAProxyConfigurationWithResponse call
func ParseGetHAProxyConfigurationResponse(rsp *http.Response) (*GetHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostHAProxyConfigurationResponse parses an HTTP response from a PostHAProxyConfigurationWithResponse call
func ParsePostHAProxyConfigurationResponse(rsp *http.Response) (*PostHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResolversResponse parses an HTTP response from a GetResolversWithResponse call
func ParseGetResolversResponse(rsp *http.Response) (*GetResolversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolvers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateResolverResponse parses an HTTP response from a CreateResolverWithResponse call
func ParseCreateResolverResponse(rsp *http.Response) (*CreateResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteResolverResponse parses an HTTP response from a DeleteResolverWithResponse call
func ParseDeleteResolverResponse(rsp *http.Response) (*DeleteResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetResolverResponse parses an HTTP response from a GetResolverWithResponse call
func ParseGetResolverResponse(rsp *http.Response) (*GetResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceResolverResponse parses an HTTP response from a ReplaceResolverWithResponse call
func ParseReplaceResolverResponse(rsp *http.Response) (*ReplaceResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingsResponse parses an HTTP response from a GetRingsWithResponse call
func ParseGetRingsResponse(rsp *http.Response) (*GetRingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRingResponse parses an HTTP response from a CreateRingWithResponse call
func ParseCreateRingResponse(rsp *http.Response) (*CreateRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRingResponse parses an HTTP response from a DeleteRingWithResponse call
func ParseDeleteRingResponse(rsp *http.Response) (*DeleteRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingResponse parses an HTTP response from a GetRingWithResponse call
func ParseGetRingResponse(rsp *http.Response) (*GetRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRingResponse parses an HTTP response from a ReplaceRingWithResponse call
func ParseReplaceRingResponse(rsp *http.Response) (*ReplaceRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerRingResponse parses an HTTP response from a GetAllServerRingWithResponse call
func ParseGetAllServerRingResponse(rsp *http.Response) (*GetAllServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerRingResponse parses an HTTP response from a CreateServerRingWithResponse call
func ParseCreateServerRingResponse(rsp *http.Response) (*CreateServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerRingResponse parses an HTTP response from a DeleteServerRingWithResponse call
func ParseDeleteServerRingResponse(rsp *http.Response) (*DeleteServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerRingResponse parses an HTTP response from a GetServerRingWithResponse call
func ParseGetServerRingResponse(rsp *http.Response) (*GetServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerRingResponse parses an HTTP response from a ReplaceServerRingWithResponse call
func ParseReplaceServerRingResponse(rsp *http.Response) (*ReplaceServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTracesResponse parses an HTTP response from a DeleteTracesWithResponse call
func ParseDeleteTracesResponse(rsp *http.Response) (*DeleteTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTracesResponse parses an HTTP response from a GetTracesWithResponse call
func ParseGetTracesResponse(rsp *http.Response) (*GetTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTracesResponse parses an HTTP response from a CreateTracesWithResponse call
func ParseCreateTracesResponse(rsp *http.Response) (*CreateTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTracesResponse parses an HTTP response from a ReplaceTracesWithResponse call
func ParseReplaceTracesResponse(rsp *http.Response) (*ReplaceTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTraceEntryResponse parses an HTTP response from a DeleteTraceEntryWithResponse call
func ParseDeleteTraceEntryResponse(rsp *http.Response) (*DeleteTraceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTraceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTraceEntryResponse parses an HTTP response from a CreateTraceEntryWithResponse call
func ParseCreateTraceEntryResponse(rsp *http.Response) (*CreateTraceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTraceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TraceEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TraceEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistsResponse parses an HTTP response from a GetUserlistsWithResponse call
func ParseGetUserlistsResponse(rsp *http.Response) (*GetUserlistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserlistResponse parses an HTTP response from a CreateUserlistWithResponse call
func ParseCreateUserlistResponse(rsp *http.Response) (*CreateUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserlistResponse parses an HTTP response from a DeleteUserlistWithResponse call
func ParseDeleteUserlistResponse(rsp *http.Response) (*DeleteUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistResponse parses an HTTP response from a GetUserlistWithResponse call
func ParseGetUserlistResponse(rsp *http.Response) (*GetUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceUserResponse parses an HTTP response from a ReplaceUserWithResponse call
func ParseReplaceUserResponse(rsp *http.Response) (*ReplaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationVersionResponse parses an HTTP response from a GetConfigurationVersionWithResponse call
func ParseGetConfigurationVersionResponse(rsp *http.Response) (*GetConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadsResponse parses an HTTP response from a GetReloadsWithResponse call
func ParseGetReloadsResponse(rsp *http.Response) (*GetReloadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reloads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadResponse parses an HTTP response from a GetReloadWithResponse call
func ParseGetReloadResponse(rsp *http.Response) (*GetReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeEndpointsResponse parses an HTTP response from a GetRuntimeEndpointsWithResponse call
func ParseGetRuntimeEndpointsResponse(rsp *http.Response) (*GetRuntimeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsWithResponse call
func ParseGetServicesHaproxyRuntimeAclsResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeACLResponse parses an HTTP response from a AddPayloadRuntimeACLWithResponse call
func ParseAddPayloadRuntimeACLResponse(rsp *http.Response) (*AddPayloadRuntimeACLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeServerResponse parses an HTTP response from a GetAllRuntimeServerWithResponse call
func ParseGetAllRuntimeServerResponse(rsp *http.Response) (*GetAllRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddRuntimeServerResponse parses an HTTP response from a AddRuntimeServerWithResponse call
func ParseAddRuntimeServerResponse(rsp *http.Response) (*AddRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RuntimeAddServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeServerResponse parses an HTTP response from a DeleteRuntimeServerWithResponse call
func ParseDeleteRuntimeServerResponse(rsp *http.Response) (*DeleteRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeServerResponse parses an HTTP response from a GetRuntimeServerWithResponse call
func ParseGetRuntimeServerResponse(rsp *http.Response) (*GetRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeServerResponse parses an HTTP response from a ReplaceRuntimeServerWithResponse call
func ParseReplaceRuntimeServerResponse(rsp *http.Response) (*ReplaceRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyProcessInfoResponse parses an HTTP response from a GetHaproxyProcessInfoWithResponse call
func ParseGetHaproxyProcessInfoResponse(rsp *http.Response) (*GetHaproxyProcessInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyProcessInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeMapFilesResponse parses an HTTP response from a GetAllRuntimeMapFilesWithResponse call
func ParseGetAllRuntimeMapFilesResponse(rsp *http.Response) (*GetAllRuntimeMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearRuntimeMapResponse parses an HTTP response from a ClearRuntimeMapWithResponse call
func ParseClearRuntimeMapResponse(rsp *http.Response) (*ClearRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneRuntimeMapResponse parses an HTTP response from a GetOneRuntimeMapWithResponse call
func ParseGetOneRuntimeMapResponse(rsp *http.Response) (*GetOneRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeMapResponse parses an HTTP response from a AddPayloadRuntimeMapWithResponse call
func ParseAddPayloadRuntimeMapResponse(rsp *http.Response) (*AddPayloadRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRuntimeMapResponse parses an HTTP response from a ShowRuntimeMapWithResponse call
func ParseShowRuntimeMapResponse(rsp *http.Response) (*ShowRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddMapEntryResponse parses an HTTP response from a AddMapEntryWithResponse call
func ParseAddMapEntryResponse(rsp *http.Response) (*AddMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeMapEntryResponse parses an HTTP response from a DeleteRuntimeMapEntryWithResponse call
func ParseDeleteRuntimeMapEntryResponse(rsp *http.Response) (*DeleteRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeMapEntryResponse parses an HTTP response from a GetRuntimeMapEntryWithResponse call
func ParseGetRuntimeMapEntryResponse(rsp *http.Response) (*GetRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeMapEntryResponse parses an HTTP response from a ReplaceRuntimeMapEntryWithResponse call
func ParseReplaceRuntimeMapEntryResponse(rsp *http.Response) (*ReplaceRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTablesResponse parses an HTTP response from a GetStickTablesWithResponse call
func ParseGetStickTablesResponse(rsp *http.Response) (*GetStickTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableResponse parses an HTTP response from a GetStickTableWithResponse call
func ParseGetStickTableResponse(rsp *http.Response) (*GetStickTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableEntriesResponse parses an HTTP response from a GetStickTableEntriesWithResponse call
func ParseGetStickTableEntriesResponse(rsp *http.Response) (*GetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTableEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetStickTableEntriesResponse parses an HTTP response from a SetStickTableEntriesWithResponse call
func ParseSetStickTableEntriesResponse(rsp *http.Response) (*SetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSitesResponse parses an HTTP response from a GetSitesWithResponse call
func ParseGetSitesResponse(rsp *http.Response) (*GetSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sites
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSiteResponse parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResponse(rsp *http.Response) (*CreateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSiteResponse parses an HTTP response from a DeleteSiteWithResponse call
func ParseDeleteSiteResponse(rsp *http.Response) (*DeleteSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSiteResponse parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResponse(rsp *http.Response) (*GetSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSiteResponse parses an HTTP response from a ReplaceSiteWithResponse call
func ParseReplaceSiteResponse(rsp *http.Response) (*ReplaceSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeEndpointsResponse parses an HTTP response from a GetSpoeEndpointsWithResponse call
func ParseGetSpoeEndpointsResponse(rsp *http.Response) (*GetSpoeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeFilesResponse parses an HTTP response from a GetAllSpoeFilesWithResponse call
func ParseGetAllSpoeFilesResponse(rsp *http.Response) (*GetAllSpoeFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeResponse parses an HTTP response from a CreateSpoeWithResponse call
func ParseCreateSpoeResponse(rsp *http.Response) (*CreateSpoeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeFileResponse parses an HTTP response from a DeleteSpoeFileWithResponse call
func ParseDeleteSpoeFileResponse(rsp *http.Response) (*DeleteSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneSpoeFileResponse parses an HTTP response from a GetOneSpoeFileWithResponse call
func ParseGetOneSpoeFileResponse(rsp *http.Response) (*GetOneSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeScopeResponse parses an HTTP response from a GetAllSpoeScopeWithResponse call
func ParseGetAllSpoeScopeResponse(rsp *http.Response) (*GetAllSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScopes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeScopeResponse parses an HTTP response from a CreateSpoeScopeWithResponse call
func ParseCreateSpoeScopeResponse(rsp *http.Response) (*CreateSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeScopeResponse parses an HTTP response from a DeleteSpoeScopeWithResponse call
func ParseDeleteSpoeScopeResponse(rsp *http.Response) (*DeleteSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeScopeResponse parses an HTTP response from a GetSpoeScopeWithResponse call
func ParseGetSpoeScopeResponse(rsp *http.Response) (*GetSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeAgentResponse parses an HTTP response from a GetAllSpoeAgentWithResponse call
func ParseGetAllSpoeAgentResponse(rsp *http.Response) (*GetAllSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeAgentResponse parses an HTTP response from a CreateSpoeAgentWithResponse call
func ParseCreateSpoeAgentResponse(rsp *http.Response) (*CreateSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeAgentResponse parses an HTTP response from a DeleteSpoeAgentWithResponse call
func ParseDeleteSpoeAgentResponse(rsp *http.Response) (*DeleteSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeAgentResponse parses an HTTP response from a GetSpoeAgentWithResponse call
func ParseGetSpoeAgentResponse(rsp *http.Response) (*GetSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeAgentResponse parses an HTTP response from a ReplaceSpoeAgentWithResponse call
func ParseReplaceSpoeAgentResponse(rsp *http.Response) (*ReplaceSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeGroupResponse parses an HTTP response from a GetAllSpoeGroupWithResponse call
func ParseGetAllSpoeGroupResponse(rsp *http.Response) (*GetAllSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeGroupResponse parses an HTTP response from a CreateSpoeGroupWithResponse call
func ParseCreateSpoeGroupResponse(rsp *http.Response) (*CreateSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeGroupResponse parses an HTTP response from a DeleteSpoeGroupWithResponse call
func ParseDeleteSpoeGroupResponse(rsp *http.Response) (*DeleteSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeGroupResponse parses an HTTP response from a GetSpoeGroupWithResponse call
func ParseGetSpoeGroupResponse(rsp *http.Response) (*GetSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeGroupResponse parses an HTTP response from a ReplaceSpoeGroupWithResponse call
func ParseReplaceSpoeGroupResponse(rsp *http.Response) (*ReplaceSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeMessageResponse parses an HTTP response from a GetAllSpoeMessageWithResponse call
func ParseGetAllSpoeMessageResponse(rsp *http.Response) (*GetAllSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeMessageResponse parses an HTTP response from a CreateSpoeMessageWithResponse call
func ParseCreateSpoeMessageResponse(rsp *http.Response) (*CreateSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeMessageResponse parses an HTTP response from a DeleteSpoeMessageWithResponse call
func ParseDeleteSpoeMessageResponse(rsp *http.Response) (*DeleteSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeMessageResponse parses an HTTP response from a GetSpoeMessageWithResponse call
func ParseGetSpoeMessageResponse(rsp *http.Response) (*GetSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeMessageResponse parses an HTTP response from a ReplaceSpoeMessageWithResponse call
func ParseReplaceSpoeMessageResponse(rsp *http.Response) (*ReplaceSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeTransactionResponse parses an HTTP response from a GetAllSpoeTransactionWithResponse call
func ParseGetAllSpoeTransactionResponse(rsp *http.Response) (*GetAllSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartSpoeTransactionResponse parses an HTTP response from a StartSpoeTransactionWithResponse call
func ParseStartSpoeTransactionResponse(rsp *http.Response) (*StartSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeTransactionResponse parses an HTTP response from a DeleteSpoeTransactionWithResponse call
func ParseDeleteSpoeTransactionResponse(rsp *http.Response) (*DeleteSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeTransactionResponse parses an HTTP response from a GetSpoeTransactionWithResponse call
func ParseGetSpoeTransactionResponse(rsp *http.Response) (*GetSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitSpoeTransactionResponse parses an HTTP response from a CommitSpoeTransactionWithResponse call
func ParseCommitSpoeTransactionResponse(rsp *http.Response) (*CommitSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeConfigurationVersionResponse parses an HTTP response from a GetSpoeConfigurationVersionWithResponse call
func ParseGetSpoeConfigurationVersionResponse(rsp *http.Response) (*GetSpoeConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsEndpointsResponse parses an HTTP response from a GetStatsEndpointsWithResponse call
func ParseGetStatsEndpointsResponse(rsp *http.Response) (*GetStatsEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStorageEndpointsResponse parses an HTTP response from a GetStorageEndpointsWithResponse call
func ParseGetStorageEndpointsResponse(rsp *http.Response) (*GetStorageEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageGeneralFilesResponse parses an HTTP response from a GetAllStorageGeneralFilesWithResponse call
func ParseGetAllStorageGeneralFilesResponse(rsp *http.Response) (*GetAllStorageGeneralFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageGeneralFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeneralFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageGeneralFileResponse parses an HTTP response from a CreateStorageGeneralFileWithResponse call
func ParseCreateStorageGeneralFileResponse(rsp *http.Response) (*CreateStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GeneralFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageGeneralFileResponse parses an HTTP response from a DeleteStorageGeneralFileWithResponse call
func ParseDeleteStorageGeneralFileResponse(rsp *http.Response) (*DeleteStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageGeneralFileResponse parses an HTTP response from a GetOneStorageGeneralFileWithResponse call
func ParseGetOneStorageGeneralFileResponse(rsp *http.Response) (*GetOneStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageGeneralFileResponse parses an HTTP response from a ReplaceStorageGeneralFileWithResponse call
func ParseReplaceStorageGeneralFileResponse(rsp *http.Response) (*ReplaceStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageMapFilesResponse parses an HTTP response from a GetAllStorageMapFilesWithResponse call
func ParseGetAllStorageMapFilesResponse(rsp *http.Response) (*GetAllStorageMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageMapFileResponse parses an HTTP response from a CreateStorageMapFileWithResponse call
func ParseCreateStorageMapFileResponse(rsp *http.Response) (*CreateStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageMapResponse parses an HTTP response from a DeleteStorageMapWithResponse call
func ParseDeleteStorageMapResponse(rsp *http.Response) (*DeleteStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageMapResponse parses an HTTP response from a GetOneStorageMapWithResponse call
func ParseGetOneStorageMapResponse(rsp *http.Response) (*GetOneStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageMapFileResponse parses an HTTP response from a ReplaceStorageMapFileWithResponse call
func ParseReplaceStorageMapFileResponse(rsp *http.Response) (*ReplaceStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageSSLCertificatesResponse parses an HTTP response from a GetAllStorageSSLCertificatesWithResponse call
func ParseGetAllStorageSSLCertificatesResponse(rsp *http.Response) (*GetAllStorageSSLCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageSSLCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageSSLCertificateResponse parses an HTTP response from a CreateStorageSSLCertificateWithResponse call
func ParseCreateStorageSSLCertificateResponse(rsp *http.Response) (*CreateStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageSSLCertificateResponse parses an HTTP response from a DeleteStorageSSLCertificateWithResponse call
func ParseDeleteStorageSSLCertificateResponse(rsp *http.Response) (*DeleteStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageSSLCertificateResponse parses an HTTP response from a GetOneStorageSSLCertificateWithResponse call
func ParseGetOneStorageSSLCertificateResponse(rsp *http.Response) (*GetOneStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageSSLCertificateResponse parses an HTTP response from a ReplaceStorageSSLCertificateWithResponse call
func ParseReplaceStorageSSLCertificateResponse(rsp *http.Response) (*ReplaceStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartTransactionResponse parses an HTTP response from a StartTransactionWithResponse call
func ParseStartTransactionResponse(rsp *http.Response) (*StartTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitTransactionResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionResponse(rsp *http.Response) (*CommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpecificationResponse parses an HTTP response from a GetSpecificationWithResponse call
func ParseGetSpecificationResponse(rsp *http.Response) (*GetSpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOpenapiv3SpecificationResponse parses an HTTP response from a GetOpenapiv3SpecificationWithResponse call
func ParseGetOpenapiv3SpecificationResponse(rsp *http.Response) (*GetOpenapiv3SpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiv3SpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9DXMbt5IoDP8V1Nz71knuIWXqy45d9dZzFdlO/ESxtaZ8dutGvlPgDEhiNQTGAEYS",
	"k9V/fwoNYD4xwxmScpysduvEIgk0GkCj0ejPP4KIr1LOCFMyePVHkGKBV0QRAZ/mXEQkFCThONafYyIj",
	"QVNFOQteBe/mSBI1QjFHGEFTZJrCV4wrdIep0r8gtSQo4mxOF5kgsW02jkmC1wfoHDPdeEZQJkmM7paE",
	"ISUwkzjSIyEqkUxJROeUxCOEJYqWmC2IRLTaDgsCo+I0TSiJUUwFiVSyRorng2Pd8iAYBVTP4EtGxDoY",
	"BQyvSPCqOt1RIKMlWWEz7znOEhW8muNEklGg1qluP+M8IZgFDw+jYJ4lSShJZNamsVQsphFWGuc5LIZD",
	"eT4nkZLwVT5HFC1pohdJ8kxEROop35EkacO6PPJArFMsCFOhgVRH+hJ+RPCjHTrFalmMXO49CgT5klFB",
	"4uCVEhkpI2IHlkpQtoBx5Q1NN9IV45ZQ0B1NEk0flFFFsSIxwnNFBMrSGCvSsi7lMQYuS4mqQurD8DXi",
	"Zh/L9He3JIKgO4LuMFOa6HAcQyOeEkt4Xlq/JULW6byNRGuYdazyKLgfsyxJ8Cwhdq4Po8CO1ZzSvywS",
	"gJY+stGSRDeULapHxyE79NSWf1liiaj6h0T8roDXMl+Hr2eilCmyIMI/0wdNjzLlTBLgZGeJIDhev7mn",
	"0jC6iDNFmNJ/Ar+IYHrP/lOaxSlG+5+CzINXwf94VjDKZ+ZX+YwIwUXwoEerruZV5Ty7k4ywwQIRg8Yo",
	"WBIcW157Xl7m8b/a9qnSDM1pQlDHGuVHTqP4I44/ki8ZkerxF+BHrKdtBvvK03xtzvcbQO3RJ/oTYUTg",
	"BJnhvvJU33N1FkUkVYb0/ySqjnJOsMQsTkj8JyzDW56x+E9bgTssQfKYAxZfdfYP7mcYDUcJ/BPHVAPC",
	"yaXQl4+imgva+645o0wSfZ9pUpISnXOmBE/QheZR6Luz84vvUSr4LY21KILmCbmns4QgyZMMsFUcpUTM",
	"uVhdM7v8SN5RFS319YFZjBbmkBhRTOEbgmISUT07iWZYXx+cIdeV3CuBI0XiazYXfAU3qGUlI/vBMHbE",
	"BcJsjQi7pYKzFWEKJ0gqrDJ5cK0XLi3NHhYnl3RSrBQRegH+72//9/pafv7n/wxGzSs0ElQRYXesZ59b",
	"nGTEL/YUItJvBTblUT6PAkWVPsvB2fkFuqCMyGIMPvtPEik9hu6siaRJSLrbW/1LffaVZh5pwcg5ja+l",
	"4gIvSL5wzUmVEbYjt+IbEqbEuon1B0aQ64/eQJs6/gY/fX9+YMnaCZlDVt8h6h2sFWXpWWMh8FqfGJEx",
	"RVdamk+QaTsKqCIruYnB5PvnWT+JAH6BE4aPZZRgGWknaraF/pMz0sB0KKJ247zovrHIeBH24Pjz2aXg",
	"92vYg0RTOIIO6LuIC3O2Ywnic5TYNxy9JfL7ASjX8YRz1L6sd/ItTdybt0p1N8RDrb8QYGSabWKpl1MR",
	"MUKZ1OxOMyjNCrEqXRRYoaVSqXz17FnMI3mA7+QBXuHfOTuI+OpZlNBniX4dqmeCzIkgLCLPSHT0zAw7",
	"I2PKpMIsIvJgqVbJ/+CAiezkPjXxXn/tHi0GYzuFJpAao9JL4OB+9h2UO/mRLLy32tm/T5GA36qviGAU",
	"kHu8Sg0Dw3DvhDdkDY+t4H/V/u/ixU9XwSjAScLvEqql19/sxgQKL8Zl/PRL26zUq5/xLWWLV1dLKl9d",
	"4UXw8FlffWzdhPDqTXGBlCDF5JYkPIVvdWfCtJSVP28B1YkmyvT2JMRxLIiU+lEs6K15lLr3uYCLLR5L",
	"Im5pZJ7KZr2CTI4Jlmp8CF8qsQ71KeWZCl4djgJJIkFUWKyPZ3EkvwByr191lSX17Yu97TUtv3t94COl",
	"0oLXAUyBtNdATRqYoShpnoKK5xS2JOjN+RHKyde+insf5eJkPtTOrX708ZWGkip7GzyUN3ifGNMF44I8",
	"ItLdN3NOeH80dBXu2q5tb6a4lbkUie32Fi9kQ79+aWbj/Vql9sYqk4RECt0tabRE7y5vT5BtCgs7NQcA",
	"vaYy4rdErEEVYDmpUxPOcHRDWIz0aSECEXs/E5atNDcqjleazRIalVhSgWSLsFIcPO9PleNXn9lrJ5tT",
	"hiSJ4I6ibDwj6o4QhmKsMEqzJNF3gJVWYWqO3uzIo2BFGV3puRyOPJoMz5H3Hd4pNCudYe8BNksYyoQr",
	"GWo5u6L+Opz4ESj1WQh+p5YhZZEgK/uq6tfFtCqNFpB7c1AoTkrbqe9/LOA+KH7+vOlKyjWOdk3dCanv",
	"Yo1cy9J1eUvarzTZdadZuWUAX7D35EMFD49EYs8AcPIk+TCH+6oLtu1gNvlh9Ifn5ePY4gbRCZiWYYa9",
	"uswLVqdFnBAUs6F7ooUiS0gvOG2dC8igkOwPC5oXveFJPxCdok8Bx57tgZDKvcqwtlql5vokfBEqLBZE",
	"9YJSNJfl8+ue7P3R8fYsw9Q3HUi27VqJXiM4OMZ4AN/tCNJAUjS6GTDdvLm52iNHlL0h5F1yAIPpqd6p",
	"BGkoNTV6SfNOrrLDz03drrmh76haIpwkRpkPRitBWGG3anBWLf4s+NjKxRZMid/ld9QA/ZV7TDqxoeud",
	"Ed+axQ9ewfmLljeBHjvRgp7htQsuqFqugleB4BmLBZ9RYNdzLu6wiOdGo5wLZPlf9kRHy5sQLKhAhCui",
	"lly3+umNfr9kggavgmcGg5IlJvj56ury2eHBoYay4jGx6JWMPnqvZ8Vy1Zj7jAvFWZRws3juai0uxZhK",
	"86dPVsKgQA4pu8UJjcMKhxkKTm9wTGWa4LXbZaOfRu8MeKTnij468MXwGZN4TsJbyhPYORlS9li4fIKx",
	"0L/ysbRM10SsoJZi4IJskhinY7eXq7X8kuSf0kX5kyAxlfknuXIApEzGS5IkfGw+q8jB6zWV+FZTbYzO",
	"oYt5rWkSyVK5j5VKEvSjhfZQOSPdUohp9jAKDF8sSdP150dNjAQcjKw4zhjVAuNKmm/dWXbPJQAd4Wi5",
	"D5I4L4Bp0HyVaknRvhG65lpuCj0ZI5F6pBlzfkPJZoygFTwoAWxob7oN/WqtNz1IPYv4utT+obQB3gdr",
	"vGZ4RaPQoOueOH1062bFUsJiwqK1MfZoGAcWpP7GKm9g4fRdRlaYJiFOiNh4G5abbnp1G8kwVw/3kv+h",
	"T670rasFinsRLIlvrTbZpy/IAclwLvgqLGTVLZCRvbF5K/hKc8k3ZqQO3BIeHU+OeqGQ8CiodDse1O1e",
	"Ew1Omox6S3bwxgIs2Gp1iDDiqxU2L7PeJNs1BDq3AJtDga/N3sa51NCMJBORMNXCh09NdrWkEs0pSWJE",
	"JYpJKkgESiTK0BzfcoH4HFVggKQ5AjOfc9MRZMVvTR+M5pnKBHiGESybZqmIm9V0G0fnWlRiiXuvb2Tg",
	"nBlZ0XLhOFTWwWEz82DWpFT2W3p46BoEXWngdXUEQCqP/tkn+RaL6W4EjzT8Vi/tpd2d+nblQn1+xP+7",
	"rmWxbvUF62Bl5aYXVKoWFlaV9Tt1H0VL3U/wVf28no3/Dx7/Phm/HIcHr1rsxfMsSbT40ENmeBgFi4zG",
	"24yyPAwjLEmI4//M9GuCLzJZEhAG883K9ptXS377mueLd/d/PkRngAH6UWMAKmEzsSWWy9BKkOEcR8qs",
	"/+YVgY5O39ipPMkb2ufaeJbN50SMReEV9dXWQT83zPBudIcU48Yx9qujk/A7pNdVYLC4IsAi11aNM0nG",
	"S3W/Ga3tZLkWZHPtnxGwKWeha1l5lMHr12JqyHpc+e6GkHSME3pLdlg5h4wGFgKw/Qj8vXet/jIAbFJB",
	"FGExYGVm+FiUU4zI778+fcKoCDrVtbHfwC4IoucZKY1TuIwFeMxU3uL6vagpU68SSYgyJgy40/rczh/t",
	"AE5VATNHP4OrGXoPgxW4ZFWFCV4s4LEKg+PkTp/rUcDILayIxPN9nAqpiVAjGxr/t47daJ/l1ZIg0x2Z",
	"Rs4+qDjSAxhXeWMbhC5e1dsmHXqpdW5D3XzTGDvwjsJzFciT9LxP6fkdrG1JGvQs9pP8XFm5xpJ1CNCV",
	"th0SNGVudiqUShB7KHd8m78roKKphQq2LxyHzhClsCJGKeK8I92gi4TPwPKc8Aj+ZZwRr0I84QvNwBK1",
	"dKaa3XG/4AvNqRO1NM/xktVuMcC1dIXvy7LHl4wYX68+d14VoV/xPV1lK6ShIYCGDLTcBlGVr4yCGpZv",
	"4V01UIHnmos+fNjTo+S6MfR9w3hC2WLLx0x1bd47UA+jgAu6oAwnim+aTqnlwygo3RE7YlM6mo6NiSzZ",
	"+NiptH2wRolB++PpAbYnMiciTLBUuzwfa3MEoOgCS1V6EQJBPo5GHYwyKVbRctMqlFpaJyF7WWwWF4wv",
	"Sk8d+kfdGJmrw3KzOWWPM/sqt6RJm3e3B02zO+BkT5BTZjsj/aPguhoi29Va6/5gi97Yz7TS7dOERiTE",
	"mTnxOxL2FKChs8xwBQt8F32DF/7HQoWQD7E3q2k+RmEblSlP96Zzn6Y8LfTtUtyqKL3B+39d6vvLK1FZ",
	"mr46v0S/6OvwDN7QJVzCiKntrtmphYDOmapApHFCtjsosnOcdzH49vsOUj40U7fJo4wNgP2DK6xk6NzW",
	"N7rZlBvnbjp5kFu3EZTN6SIs99AyLRYpfSTjrIrSUK6wUE5FtYcjcRWlaKphonML0wz0VY9F8zxAEK8J",
	"+t7HJEvQNPCMMZI8zh5lkoTzaEFDnKa9rrm3WKrzn96hUgih3wm15FLq3KJ+xNIbA+WcnKrecju6OxVx",
	"dhpYLVa7HlCjl8F1zANrvq86SZmXqHn6lp6wwR9IkC+hlEkoGUVjiu7u7g5sv4OIr9BDYB5+98GrSU/P",
	"pb/iextaGH+DscH7j2AuCHkLMT+OVPOI/+BVsCDq7PxCFrqbtX5eu+i/h5Y3zwBLryO898YruolfDRvb",
	"voaRxaYnkU9zuvuYJQPIvSMczE/SbcFhXlruHyTWchgfNs20PYps5lZ10wQHuo2XTk8NNenFIvfUqnkJ",
	"Fr6NxYGbU2Hi87Fc6n9izVUTgqUCg+QoEJjFfKX/iNOxdTAalX0jcwHb3PE0GgthfR31fxMjiXs1BmCO",
	"I/dlh6tNx7YyiVwLrZH3Ww2wXKI392U/LaeYHzxaPbtJPnosWgYvFPNuYE2zMV9hykIOMTYN16K+U94w",
	"6CdJ0GsYCEEwz4PbyTAW+E56wjh6DmzpwTv2R/gNvYYRHoBknJPXYAbXA5OCIP3YxCk6h9/zLcgEDWOS",
	"Gq+a7eav6do73CdB0WuAbQdKCHukYS4Ic4OkWC13JKXOoS6xWuYUpAe8W/KEPNJg/w6wH8psYz8k03Z0",
	"i3FacErQpfm5hJNTiHGpdtnffiM73y1u3vYFEit8H95h+jVQ+BXfo38ndLFs2hoKwL644BkdFMFEWVyo",
	"bTbIxLWrrYhGzAXZ4PDoxcHkYHJwGIz6atdTbpxEcyA/TEDlbsL1np+eHp9Ww/c2qwA1yLHAbEHGNp6r",
	"AH64G/AegRpO8HARyEgvciNCIpcqqA3GKO3Eq2EbYXz5GVEywgkRYURTf8igbZn7ETQ9bCH4OJwIpdp+",
	"T9kOMvPZxeV7dCm44hFPpJPfEr7wxoZGOLSWRCJEH9FBysTnjRzhUNIFy41TO4JJsZTbgvFp4bGU6VKY",
	"EEI9yC0RdL7ujW2E86YNjGm6tCFb287ZQMioDSbbFkxCwSpJFzhZ7ARIJDtvo1B7IitRmLa3BZGJ250W",
	"1kURlHEpzOz9GHCvWPk5EaFhHy2u+VG83GVXyH3KJQnnMUyDsCrZlgYyrrlSJrfHW7qCQN8hzh9+qavi",
	"F5EjphJ5ezjZEjPT+VFRO9wFtcNHRe1oF9SOHhW1411QewRac1kmwkiLAXOT5LTXA6Hl+C0qeag6TCs/",
	"CZ6l6N1rcIrWf/dS7JpeznFskdE4TAWZ0/ttfA58KbN8BhIe3RBlUQUH2zmO/PkpEnJLkrKGJpMwe6PB",
	"gwSDOF5RSBRWyLq2kc9dxDmW540Pj45PfJKqMws0gfhkjIFKS9tcpnbeBeo4Tb2tZw7xzYTwPlvNCBB5",
	"4SMMMGhtMG/CDcZDJ0puS7KMhxEu3D13APMNXCZ9xMYmG2Bcs6dQUU3pu67CN3Fz7bIOf/7lthv2f/b9",
	"txv2f/YVuSX2qT8tkfW3su+W5juqJJCm+jnb60ZyD9/8IvyS0WgcRWOcLCpuL1E2oxF4it8JwngwCmYz",
	"Ac6TkT/zEgACeWUM7k9+TKGVhGuxMlrBv0eBk75bhwmjKNT4hrNMSP2k+x3Yfa5TOZwcnYz6GZHLe1Zd",
	"Ct39oT4gaN8oi/ldZcCTw5cnx5OTshpnMtrCin3TDyvdyEw6d+vSD3a1Dnmm0qyysuDsqnHRVyXYamAl",
	"K1KEbbPZNm4snXrAnV/R9usmhUiZhBF2D+ztlMA91R7T6QU6PzOpS93IhTC73+EtfE1ANc/J6fTi9jgY",
	"BVcX09vDg0n+12H+11H+17H3TABgyh4FsJFKdnM8aVsPEzUjGd1FbFBRGmoxeID/iO41537yU0tBsD8h",
	"biHnhDdkLdvaWAnmUZasEDEeD/zR44J/PHqqOSk19zZryXQMryjfD7cnt8/9oG6ftxjfTKUFOl97mLBx",
	"bIMYhNyY0pMRd8y/SEX04DENGK1+h29CxUTQ5nMB5oNtnC1ozX+B+p0X8qQuDRw/ahzP9c+oqHRSNT5o",
	"nooXpNUi5nNkzP3EXHkMDcSsWS5PeICZn8p9TEZILNblzMyex+aWwQ2p4JAP8hYbiaqFs5UZGFfY3DMN",
	"uehk8vK0Ow3lBh8g2Aefyw/sXweRmd+Hub/kuXkqo6OpoQI/FaVaTm+6wCSELbzG//y8FGe1qF2Re1Jv",
	"zEoJv47cMKUFe02iBAuCzi1m3qWDn/oncHGzfGgOY3/K17mxQEkmFRGhJEpRtvCmcTW/6LcOvJMURxjZ",
	"fgeNozfjXEklcOqy+TQNaKarxy2psN1umZAWpxTyxuX5Ujb2cPNvuQdq2Y82gitnU2yPLSxN1Athbv0H",
	"/2i3S3dZiz2mZ/vGK1O1CeHK4nQzMTt87fAleBsCCs/N6l7wxRUsyoaYwnrztsRCjnVu3I4+q1Xnny1A",
	"K7Z2x34MvlCtQvAkIQJRZjavJZlsPZxOUrYAl0l3KLwyN1SxqIRww6ULDrKC4GgJ+I+CO0z1UQ1xmgp+",
	"a5Lnblgjz2zcgfeypmpStKZb4ViQLxU33pgwRZXe6cXvNIVw93likjYLfDd2n7wyXnPncy+T6vHaebR+",
	"Bkc9uhzXOfNXGtzKWmbhO66mUTDj9srpsaB8PneF1zyCwzqtzXUbxAGKo4u9QNoVpwcvZTeCRRoETu5T",
	"Ksh+wxFuyNq6Bw6PKPqFrNGFkTBA55lmYtHqkVePa0WX0BpCSV25i37mGydF9kC4qpMSt1YmyPlYDF7G",
	"TqjsThBhC9CQwU4EpSOamjTgz4NRCc38gMwo00K174DeCapIaFSq/bLnexith+ZkNrRI0zl0cmkvOlPc",
	"ujIUZf+3tsoV5qp8OWnWnpg8jIYKah45Cg6DR7x8j1d5LRLXyr3r4J1pawpSVvjMR4KAJDpbI7WkEhXF",
	"NDYJcMPqKZQj/8OUJzRaV/PY29d5rToAmUOJGWWylyRqaeon6r0yuyyRk66g0oG+wRHjMbHz1WRBY6J/",
	"NolyXTkEO8+Da4aQHvoVZFzWPSUUPK131O0wW79C2ICnsgmbzqFuFmc1ZKlE/0ix1ALKPwBOkmyEkyQV",
	"GAapCpQVZZug6Imy3Iyb93YgqUQL2H6B9NJ9yXDiSiv8w7Nf4YqyfyDQi8CyIfTODqFRWGKJEiJlDe1S",
	"dVq1JKwDMFW1adjUyQelsgaWSDBbm8I1pu6DPwzCP04vz94WYnUqIQ0GtEF7LhLS9BGwIm5xSmzOiFoK",
	"CSiCNKxiR8VvYE9Po0cs9RGVOXWPah9/lwIdZhCInC9XDXoED0A3TrnUzyMOA/msBFmQ+7RJKR/JIkuw",
	"QEUUU72ekAUj9b2lQXnrtCh+Q/pXGNz0UG8rhlLW4NWotEVKkd46lfqHgTo8I/M81BHwau/yXNc1+UMp",
	"0aFeycuebSeYVXUSZ3qsbrWFbtKmqjAhXl8LWRPntQFd06gV4SJ/tkcgUiptt3JQZt6o/l81W44T4udK",
	"K3yf0Dnprynv8i7jue3A4xfBpWqfQZ6Vz2+HJpHVJfufytWHObwY4J0hiVWagW9hv4JGviAacKf2Vkm/",
	"4DiWCKOSrRpBvVSM4MlkynMUlQLrehuKfce7BMw08elPq9bxdghzmhBbqqnpOyllZhTCtUqg59NLZH7s",
	"7O8tjXVpioOhG7Lu7MwjmbYMnReX3dQ/tMXnvYLVCisaoSrAvFj9wAIdMlKJR0VPF4zEqLzcV3RFpMKr",
	"FEr3dkygnjKutJ/lS6IEGqrw46hNxemo1ENRgAqfl8kUhCWAaOm1PNJUDSi1l5+Ofne6bp6rEwY8v6em",
	"Bi5akWiJGZWrfAKYxfa0VebnXq9WIqy81mspEIQqCX61J6UWzKy9lQsoOTonKlqi6fSiOh6knvYfku2g",
	"p8VBaoee73ifLeqT3K2PuNMwRnpox0ufsE0dBNoAJIdQoSGrh6Y8E5NZtihnvqnxYcaZZWWFgfbo5cnL",
	"5y+OXp72CTH8klHScv3+TgQP77BgeiE9LXz6KRfHs0P0ZmscooXdHYboKNOFIzaLmfRDyT56SkjVR5iW",
	"Cp4Uqqp+0F2Ptop730bFut3qwoHPI2VUP/n649HotY9aaT2CXV87ReKOZckcnDJd7FKYLFdwdl8Ej1LF",
	"a19p5vxFvPKcc99+CbE9L0RXBbH6qjxVNvu2K5vlUd/DbXE/2s7/nSqkJfNqkHyHvfH84i264NblBsIX",
	"Hi2jqYX/WLC3T71XWxFA05Np0o2xfabJcwvBZZrMIe4502Q+TnumyWLoPWeaLMZuzzT5zZbwYwryWvqo",
	"qGeuO0VZxjOJpgorKhWNZLBDccBSjelB7qi7JpjbQ3lCc+TC5VGYpQuB432wudemMdyWz47QJwt4czlD",
	"zpSWmxkXK5zsAxEDEL03AIshNDHuB/4/lObL6L0GuFNFxr9zgcVwg1fmUxXGpyqMu1Rh/IZrzHlrxRkR",
	"aw+7Wy8BZ4Six6hR9zcvPde7olzvym39Bvkk9TX5H8HXKM3mxnCFfASfEbmviZh6NujSAH2s4m7eamGM",
	"h9sX+fNM5T1HrwHe3orCPUqJtf8eldP2WhDtLG7UPDPhOLVTDtllIaFeabR9HXejyjQrto+Ka/qb3noE",
	"wMIqEsCDzPbcdXIOFDjIJSQEphRytk/FnH4lo3MNGH1gFS3cX79IVodwXPwcyn5JkvSDxGQWQNPXX70M",
	"lySaNhUpCfADeSVAUST1x4nYhHWjUvCGqxZRCeNw9yKgYR1Ie8WOFE+FC76YAh7+p8HwomMJX2CJ0z0t",
	"/9n07PJxSplZBgmQkKS/E/ChXmHKFKaMsgUqBI1SqihZy5S1FQKuTkcOryYHmcA76wXbWkKNM6q4CDNB",
	"N9ZOKzV9Kr72VHztqfjaTsXXpimJ6HyN7pYEAlA0+a9SBX86by6cJGsEUBFGc0wTEpdFsK9Us+0brbEG",
	"6VBa9dtDC4KZfIlTAPdUwu2RSrjtUmftqX7aX6p+2tcpf1YkZd5b9TPj1hD8NaqsbayeFvV/8ure9sX7",
	"1y26xuiXjIQ0bn0o+upOQCf07jWa52nmCkCFYmMAINvp4aHhAShba7Xljl/SCfWtSW3qAawDY2PikrtZ",
	"A72OLDcxMdFWKsGy3b30PyXvrDZQXbP/d/rhfV7UVT8U83TEvZ52F9C6EjkcFtbpPkkpbS9buMeIVfAw",
	"56JndVrX2u/buhB4lXu2+rcz4QtkbS4I2vu9VXcNju5OA71LbuW9JETpU8lkN3gb0rSVTwPsArgDd+5p",
	"1xktNnLY4SwIZgNC+bms2cPreZVYjKCFBOUEXellxUwB2a2IlHhBZDPBksfsd309/ef/1v/x62zqecTJ",
	"iogFaLBNYFIkqDJ6JsghY1zE9UNemaB6yuY8sN7rfmWFfgG1VvTo9g/51fQtcTefm8hqveRStQYGG+G+",
	"54rUgghsRIObAwArOYi/0T+gM7tUDZIjLE45ZZ79fWN/0ZcCuEB7eEUtO0ErgOJrn/7PYNra3fzu6ZgJ",
	"TywRlPmyAcz55LrSBr1pNGqujjd4NElslgc+R0XDnqcxR82DSXtdRsJuqeBsRZhqvyfBwKQIu+2I2uxd",
	"I93Vm8vDPDf2+Be09Ia6ODAbsm5dwgTesFuvdrip8ZFEodLKoFssqGbYsg1umz65vHA9DHErfkvAOd87",
	"OCL34MesCZEzIpEExQwlsZEF/so7NO29PdOeezPt3JiMDd4Y2bIr+S5AHnSxyPTv0i9jGctFa6jEpnx7",
	"wdnlO/TGWj/q1YJj0k/3Zy/SzebWRiSkHqLoX74SLEr++eZ5qr0I2zv4aDIZncD/Dkcnk+PRyeRkdDI5",
	"HZ1MXoxOJj+MTg4no5PD49HJ0eno5Ojl6HQyGZ1ODkenk6PR6eR4dDo5+eybrV+894eN172TNPJ55uuS",
	"N5p3Ll7T1mPNqkc4Z4to0EqVCY/+tE2y9243+elGI4ORLxZ8Hi3omSlg3i9IzXb40R+ihqOkVxwWjpJ+",
	"EVhnabpr8NXb85/e6SkWs/3RG77qBHtPnfYNT7WYR4Jz5Y2IzVM4xTwCHod0U8RNIK8gK64I0kLpAbpa",
	"EgQKcOKyfJiw5llGk7ic2MrkIdLyjsM17ybR9Pzju8ur8O27izfvz359A+HEl2dXP4dXH8/eTy/Ort68",
	"PkDvIN8QRivMYgyhujZxqzeXyIKoEIaUPvHQ8HMukFUaSTszJSi5xYlGs2D7peSvhblUo4EXkGzmYHgs",
	"uy0Q37X25vvCzyVN9aMJz/U6Y/Tp4zukllhfkLEL9UMywXKJvrsOnl0H3+tOWrpp7oFLqdXYCLcPeg/y",
	"9WbIJeruXG+wYTvbca3qCEkSWRmxTKZ3S6KWJqMV42Bq0qBcyLhbbZ4SZidPFZKmfHieU+AAvZu7rYxH",
	"rUOBV4GsgzZQbX5vyhbmBUCls2ptsb3GCSImYoAPtD7n4LOgu/Xk/Ct8HwryRVbTJXUlZbPKilKWsYiz",
	"KBMCTnmexElPv7JymCGj1z5wScR8C2wPkB3LnSCkuVn469l/hB/f/NsUxZlepvIOEKnwLKFyqU/TSG+w",
	"Ho/fEiFoTAw2hggP0NtMaHJZcUFGLmVaGYWYEwmEFHO0yhJF04TcU7YAsFDOxrhQVqBuTFC1Su8lUPcA",
	"biKzNOVCVQtyVXDafi0v/2Mann94/37H1RxO2U7WqFMYZNzWR9IzlQGVh7GUVrk97OBcYikLr7weJwcq",
	"hoNyp5UJa/bSSGulOCL3SuBIlZg03NpwaSm4DtVyrEGbtB76q08f3x1cs6tlJkfoOptMjiPIpAV/ErTK",
	"pEJLfEuQuuMua7l8BT3nVEhgii6Zee1qGOXDmgxt9aaADGRmPrhm7+bmZMAEYyCN/LikRMy5WKEVVtFS",
	"U5S97T99fGfGyFvO9SHy3h/SXNrv3r/94L3CvQlViSrZ23tv+JSovCZ5n5y3nteqk4BKr5u39UM4a7GL",
	"WKFsGM5WoKsrZqqMv5W9JHyxgH2Zo+nV6zcfP+Z6UiMItPMRzYWk3v7WCx39mNtvRsjJlG+YIiIVVBLL",
	"MmV94IMuA0Az9gJHNKHKpJ9yC+6+88VqFNYy19p845P2jMNmqe1PzoWzGVNlcw67ljaLsI/tF3afvK3+",
	"YnNNkvJcq2X3IQ/lirIG6F/NBYSS/Qwh81y41R0C04UsD/xRf9OV69g1nOrPG6tk2AFs99LhmhqMGqfp",
	"oeV8lXh604BgNTHmcmQ2j27uC25tnZoZ6ivF6XQ9x+Pgmn2wpyFZj9CaZ3BbznmS8DsjMmjRmqGz84ux",
	"5gZxkcp2hKgWX2m0RBGWpPUE6hdFBvmJqH5EJWsnt+SQ9LnUO3dwzX7lUtWmYXLJ4kQQHK8RvsUUVDkd",
	"szJYA/+HxGvoGpzHr4P8FtITBVQYgUyvVBYFbfJlc8MDf9E4pJlIuSTzLEnWSHNZReKDa3Zu5Ee9gDbx",
	"L3S7Ds4yteSC/g5IXQcjdB0Abxk3ftDXxZKn49l6vORpZeLFOO/1uzNndsUw51CzR401GV0HAKv40pQh",
	"uQ4QxCpsogc0IxHOzGauK+secXZLhCmWCAvkLr0Dj4bOWAbz1NtzKFeQaM7YM8bZ0IUNx45DRfpVNXcj",
	"1xlC1yDoyvpbDdAjVa5gX9mUsihYvC8r57H6xID7SZoX6siJKGi2tvKSuQyswKRPqMI3BGHrHaF3xaBr",
	"KFCCPGaYQ8IXBWl/Y8f970I5HREQQ4iKztU65IyEMVkIQjr8OSAPR1dpqjrKpliSbv8wCmKscH9vkNdY",
	"4Vw37Ay0JpzJqQ17GVogG2EFxjCnDms+WKMN3h0m4+6WWZpMZ1nNpq/fOyYDsLNLj+x3wqQ7k5BYrWJZ",
	"gN+DZvr8NA39b8hyMnzNXsY4TYtk+KZwLaQShkd8Js3p2aoipYtUrdJ6bgYL3PAmafgMs/iOxmoZJnRF",
	"VQv6bw1yRl2nryhXOhdyIM7W6B+SqHEOawyw/mFzSQJHBPdzwiLN1qylKUJ5BwQdDIexO/xI0/8tmN0l",
	"dDWm+uFu/oS0ybAY5uAN8csZvvw2yU45RQZM3lfPGDRaJW3WbK3cg0gz9hlxTkwkBhWIEYqIoDwGWYhY",
	"nSi8wWekZOKbc6Ebjk1MmslwucRCb2b7nthnlrlPzP3jTpaLxFlpWYpBAWarV7AVHjTmB0GPyrxb71+j",
	"KolbXrMg/vV1umNFV27l8uTe7qqDiXqXRWBFzJrY7Whd4K5VhWu0fWkBtY6lXdEkoTaDfesKe305K+ve",
	"IMbaXTnabWd85XE8WXWRedmVlVIiS+wim7YzItEdGAcSMFDInBlhhpP17yQeOS2W/jPiq5lRCOnFc3sr",
	"SUIiZQUeKAqECFMmQapJ4WuFmowVhO8/Rj3OjdnhHszjERZfP/Sf+Mtj8JcVZbmQ1lzZXA1lde+NZS6W",
	"Vs/JHPPZGhJ7w5qR+yjJjMlGC/pYKpRiiJmBDVrhNSz5CicJEbAd1L4wNnKjv+V2yJST0JiFH+/21oOY",
	"yxuGI2xB2R6EhSb4vFBZjUGW9JvK6UmKSkpSERzXii4hzsjIcjpqjTeKRjdj0z821o0ik7U1l0GSgY7L",
	"7dtne0aIX5L7OFulvcqO17fDivkFsP2Ihq3g9YPDsgV/Muf+MP1RIRFBHzGL+Qq9LYZ58L53HnHsSzuG",
	"p7qCdztdzehq3r9R8ZIxp9G923rW8C1bRtyTo+W52VVS25K6v5a2fdTlGprexbTtI+ihjmO7B2w12VSt",
	"vGGRhG1jVkJIjuVivHpaNouInb6BEXPIOeEPCSjvVBPNdj83S9Jv8yRaUOt8gCOV7dGW7XuYK5XJOqvB",
	"yTtqrI79s2L7u8pKifc218vNNdqLStS9kMmrVufnoVc3d3Rc5hrwRMnjXQemPPd03msO9UoSpGGQyr3K",
	"sLaaZ3OG31Z298FLVO/Uz8nwrT2KO3saOiZQYgi7pHl3MLqqczZSrwZKT959bEun1siSVspXcjSZTFy6",
	"EZdfxM4QYM9L06zzrD8/Y/y3lrJ9X9nAu7NkVyQllynGSUqwh37zw1M67e6lU1Hbyj2l3f6m024/Umbs",
	"byHTdUclYp/JrdT+75Xo+iuksX7KRP3fPhP1106rvMhovE2/Py3B8l8p8/CWYtJXT1HcG9m/QS7j3nvy",
	"5yQ93muu4t3m+i0lNf7amYH3//b5KimA+wUX//1TBX+NzL7/7RPu9hETHi3z7qPmurVaKP0a78pyO8c0",
	"6ZvmFtrulCH3b5LZ9rEzbT5lzuyROXOnXIxgYA9zG363ooTNqWZyRY+/TTLHr6r/G5qLcftRrIjyDaY+",
	"7KqhndtU2tIhOitCl7XbNRmWYa1sn6ij40t7uCCMCJzkXuxVZH4yv6LM1u/flHyrGXvnz6XipMPWULGG",
	"T7TNQF92eNosWkpTZz7siB1wUX7NiTY2rbxUno0DbwHE52hRg9U7H1dlLzzIgZao1SuhCF3sZ4M37dss",
	"8LvYQr+i1dFGZ+bT38XiaCBsSHcSLV22ky0LmJ0bAA9WVA5lKgiO4frZt10ok4qIUJJIkH4c89x0QVPT",
	"RQNJs3CFa2+C2oqkWSj7DnD5CU2JC16JvBG+/ogV3fbZ1VKvlYFQY8EO3CjHZ0P6sPPLT7/itE/6MI30",
	"rziVXgBtr5QYk1WFJ5Y1/2SWLfoKPNXGZV97V0ivmnhvaHm9TjczIyxbv7ma/5j1XjQPwTldQBiJ/cb2",
	"6+8dtvGI2xS+rt7fUEPQFbm3zryFZ7taEvDjdAWk2zIAd++Op097ksTubIzNLuAhlmo2EZNUkAgrEoe5",
	"i5tsMbCYHuQ+JYJqcDjp0adecnJzTu1mVcnOwLtuB6a2jsYIEZEwmi/AY5KIMMW2ptj2zLLGX1ykbpX5",
	"IzMeBDHQVZZgRVDC2QIJknAct/DdRUW06Xj6//QOtDcLYRMN72s2Rd4RUA6jGVF3hDA0fffTp+nHQ/Ai",
	"FwQnSPK5GkvF05aJCJ6lO9x0P0F/Y52x/ikpXkPlLH3rh5itwxVRS95iKKwadTpuIGdtaklp2yt1rU1Y",
	"28GHfj48x5IYQ9AGDVa5adsFUTNZtQrKy8Mw5iHjqtCRUiZJlAkSQs7nOREhYRFv8WPWII7COy5usOAZ",
	"i61x7I7MrO7DmMla+MISizjUJGLcAvdJpj9jEaOp4ik6myvXsaH6xyI2WTZq2SdArx+mgt7ShCxIHEJy",
	"kmbDLxmNtlCG6kfp0F4Pfe6xn2FCHwH9yxz7S0B+CITCEmdci3oyWl+Xkm9n2ExLuRkadOkhR30kaYIj",
	"MkKCxFlEEBdIXzs27ZB+ZejXk1RYZRIBVHdja36GMENOqew9TxqXOabJNz0HKHSUCdIyifxkz7m4Ce8w",
	"U21eFHlLSVRG4862EPNB4tCdBU8LHuEkJf0dy70q8QgnuUD1D4k0PIhjPiiMFCwOy0nIe/vObziuqcsf",
	"0cspfgfH9wu+QJB0/mc3C98RveAL3Shvo6ef4b5ntNwUzAv6TTbWHLyir+qQzH6FLujfoQv6lRt3pJUB",
	"EZpkf0aC2cpmcbUkpRA7/XLVwoaBDhFMMhO39JZAHh09Dij+Zwpeb/1ko/c5ePPmM9X0eBsJd7hl6XOp",
	"pTsbqfVvn96do1RwxSOeGKBxS82IbIVD+/5N7d06kCx5JNPQxLj23XxfF1MsD5SYLOoNyddFQ6Jx74wV",
	"l+9eFwkr0qMQMt+YU2wKmnqZSaqFy4RH4Tzut1WXtgN6CwKxyJimqRCntMrG++m1ZtTEVhnz6x87Vhap",
	"8QrX/bNPxVVmBB/NJM4u3/W6VkxrdHb5rq5mKAC1SZKSqDDOVqkzgTR3REIOW9EhQpP7tJ8u/M192dd0",
	"YIJ4f/48GHtzsvd/YdE32XtHgvd/YdG1jrdYhPNV52OjvwHibW522Ms62ZF7rdTblRq6WNZKItvgdSxb",
	"hHd5J36YonOc4hlNKCxyyzAy6W0jLDXN7YutDyzz805GfLD3Igcih/k4tSWNFxTIdC2PNnPRhvB+DxPK",
	"SJf6Nn/l93/Ps2wVchFCgr5+VG1vc4FMjsA6gRscaoA30LmRC3KcNlG6VR1De9kO6gJWy0+B5WWV24kx",
	"bnxTKY6ExsmzL137ujhIA+TLRnsHY0j/el+IYxsCoNLBQRlwyBvtHYxbLOQgIJUODsrvCZ0NglLp8DAK",
	"sr5qwE9GDZjZpFCeTvpXudPb7JM0YO6wYOEs4dENiUMl8HxOo0KzM6Dg2ABlZILXNjW6SYyAkVRZdIMU",
	"ljdICbpYQFA3KopmebjeXSbmvUmj2rhi5jUmvjazfM4L/QZCvQnwxHf8yl8tZ6hLlAYrNysq604GP1kk",
	"/LOQfacx0L9gkTPcMho+z4IllsvQGY1qMlTGIme6cU8qGc9W+j31n7OjYBTcqedQVC06PoIqaoz4fd9y",
	"9bEDs8Kpybdo7FKSSkWYanGci+mcVl3R8C1OMIuWpI9+z4TjJz4z3BKDf3AZNGxWzO8YZGK8YfqvnoO0",
	"hGVvaecG399ysQJJIPNTzfhRT7AAfvvQbZx3K8xK31cjc00WSJdxspJCMvgDSRGhw5dHB4fPfziYHEye",
	"HT5HD8EoWMYi9+8JVvh+jBfk/398eHr8fDKZ2N9ziUtLQWNTfZULNZ6SKBPVBNBEjZe5G3Uzv0BeY+hx",
	"ct/FJBnjKLEJUvSAN2RtnxaPP6Qvbvf8F/QLWaPiVeIyE/Ty1N5sLLbgWkJGbS75acKVufDyvAiEtV2U",
	"A7P99Rj+wmjO3dil5NbFlnz3/7yyfPvzP6+vv7sOvrMfYae+vw6ur7//r7zF91uY1futlMHN5l/9qyVz",
	"9cV6zgUhlvrs3tWiP8/OL2qRn/rc5NGfZf7wx+7HRRhdvmMSo/wL02JU5iAjzWjdB//5spEixfHS6EIV",
	"hK+BbSdOvwIWDqW6ybUv2RoG02cNYDz0qxnoocy497AQpY0YNVelhGJtAweslytnWCnZvJfKr6NA0sQr",
	"kGyRII2occIXY4OhqQeA08e+1/SoK5zapdZ/fc6HfvQbzju41wCS1u46jR6AeUwEc/xakYKylyW0ZBR2",
	"qF4HLk401mdjkUaazKKxRmaRqknLGk2jKVGo0OciW5ITkGp/vO6GE2VR48Ok8umwgnxzJg6/+6+AoEOi",
	"GLZ/WouvsHfvzHiljQO7c6WW+MuXL8s1qSaT3bEFKrdDmYWBv0NBsGx1x+vOxdgACDrOeiAUuOPy+Xwv",
	"zNM8IGAIr3tj5ZrBScLvglxutPxHy9q1G8expVEP6WK/R6N221Uvh1GJc5YW23y4xaL4a6z546iyPLb0",
	"rW0Xcw3X+6C+xWJf3CxHzEv+/8ICVQ1RYLfZl2hYWYtWBAomrgd/1Ezmv7XuU7EzhkdpVGTE0z8flw15",
	"IEtKCBcLhj5m/sCL9rR0rTquNh1HW/bIzcqN/s5EPk3NQ23mZ82Zt0d2GBcl55jbtGfvz9/bhfQanUWS",
	"sscA7dNNXFy+R5fWK8PkXuTxerurBNIuWgidmV6GAIPVDyO+WtmUIoPfTq5vOW6a3KfmDxjoc7lSwVZZ",
	"YSvbZ1LdFCKBu9guXnz45TwYBRcvPk4v4d/p1VT/+9x+Pjn/8H7IFetGt7Mxg99HCV5hkyAEi5utppMD",
	"9PshkEiLr/k46Fc9Tp4itb8HoCAqEyxctpd97EUltegQTTA/W0xaAtnzQOjdNjrXMeSqdHe7i/yvZaz5",
	"9dz8k++osH99fqwCKD12MNdNNHX5P785ex2MgstPV/q/H6b6n5/e6P9efTw7f6O/PLs6/zkYBa/fXLy5",
	"0l+cf3j//s25bvLh8urdh/fTbQi5OPYrykJBotu96EfL54PftJxMOJD2gD43H08+/LLrceTM5IXYhgnW",
	"4Mgs6ojb6g0pp7c/9kdkGiw3ycry98/z09Pj09Fw02bv06dHDC3uW6xJFZa+AXeGAv55uflpN94iGd0d",
	"H5nsARE4LePI6605jPQUz5T39F19AE5z8dz9cQJ/7Hj2GnFzHkHAepGOORufTE4akoH5B15tpOPRVhLA",
	"fWZmQXeTgTJB9yZP7fGpWDxIPv8Zj8XfKpvw+em5uDUuREi6rf4opyuKQ8mjG3myK8vp8341gY9tL1Z4",
	"MwwNRHGhlM1xNr0PG3FA9YgpyRO9xmE5Lek+spbZbMAf3QDotQMBa+iGpf2yW/lBGpNxASyFIncVo2h6",
	"qxknTW+f74D6pYELYylBSU8/vyow09H6rEYDKkSWwUynF+j8LHe/16BuiaDzik+J840p0ernVgGn/7j/",
	"MgMBGYILq8v3uNf4v9KgNgMWurIesx4fsFbHmDzcq0rv9khX2Roe/342/j+T8Uv0z+vr8ain95zVr9c4",
	"grUjbggavbq6PHfBZbVqCLu47wCU3l47pnWrsw5lMbkPXk0KA8LJ0WlpXYxiftRgKPBsjkx55D5su9qj",
	"dAW33h0acZuOpZRQ16aVGQXJfGz/ysdM5mP3qLU8vGVMd4QcrVbgF/mGtxl4ixdnyfhRw9g17XGo+w3h",
	"jWrUQyI7JIKuBSbL+BGVKa37k9NAz72uRc0A2G79S+MJcDSZjE7gf4ejk8nx6GRyMjqZnI5OJi9GJ5Mf",
	"RieHk9HJ4fFIn46To5ej08lkdDo5HJ1Ojkank+PR6eTk8z7MayViqD8e7G/9EmuMys3L8gRkmO5Wt5eL",
	"tnRr2QtW1Klc9/Gg/nJRiWs+tE5mg4RkMmOGthTwQO57ZtMDJeuijBv4wiI+L61DreBxJdf5b38E5vmq",
	"acwVFXlGVPTMeouWkoY/k1SRw2cnk8mBSeI6Kjqf9O58Yjt/znvckZn+cXzY5OdfKS/75tyRfeLwXOhY",
	"CecSkRcEJ13l525Cz6lCeusAYpfayxF+iaLzjoPJuSDFh07UZRtBl4v97CJMWDi9xQnX/hG9f/9/V1V/",
	"3/8Y/2zIfHxu0g6NXxtdSCG7uCUq7PZ/htuvHr7wC+jyxr3IZfuv4hw8BLGq6xTO1DIUBCer/VkDNcwW",
	"U2CmloQpGhkC/Ajjeqqn54Ust3E2qZVP92MyVZjFWMT5qScVLVJbOfdHw+fHav1P5FIL1BEpinD/WUvz",
	"1Yq7jzPZ6kUdLUnuyPnk6f7k6f5X8nSPCVuHHm++04o33xHIkTsS828wWODyINtn89508zEfW62dVQDP",
	"ojE4BOSfFHeOaLFUxV9jMOWZj/NKn3m5TyooF1Stx1GCZeNLPp9L4qBIERV/lcE7Vd/nbXjdU1DCU1DC",
	"Vw1KWNKKnuSRHDewSNZjPVRL/RDKVJmqNE6Pe9/3wugvG7iRZDjEuV7icVYwyXAxmE2Qs4WQmIN5Cjb5",
	"iwWb6Ds09NlFvpvc/zYZvzwbv8Xj+ed//pf+8Pmf3+8PSXHThqW4KcIXzCUQPv6i2TtAo8RoRIo1yQWt",
	"w8nRSUnSGpvPe4mc0CP6V+M9jUixGqYuJP29auacC7xYEabGkPIT0gK5b/SaQFYCrJZjzevIWCZYLsFw",
	"AV9Ci3HMVeML+x0RkYYUEw17nDFbUSsu/ab4OEv1B5ND4UtGxHosuVDjmZ3IHjhkPvcxlJt5qCxHOLcV",
	"Lzea96tL6IA3Z15StPfDwIRHbI/Db8OX+nM/JPXkwsfni5BmfJT/+aUkytifyh+/WLYNyOXS57eHnksL",
	"OMitYAN2Vv3qtqz0HvLygMtSakJztuxm7oPxAUBnZYypSfdamu3x5HB0PDkaHU+OR8eTF6PjyQ+f9+Av",
	"CWO1+gF/tL+ic5un0qDGu5K772O4D3lZYDNg3dSW8KgoAUHm9B4CrpZkPxyuJ5JXuSlWo+j1adjf3dgT",
	"p/yGyt1x9kGfmw5G7qMTNGzkT74HO/ge1PU/Dm3/HPbkjdA16JN/gvVPsEPb6FrHqh9TF+h2oWsTjLk9",
	"59VShUole4rFhhf2OBa87an1cXqFrq4uniLnnyLn9xw5TwQUctmTQjDIJBlbmDZ+IeUkJGxBGXnMxy2L",
	"x3qksU3T5l2Byw9v0BuDiUNseKmPR8Irz+f5p6QAKPK17kPaduDKsBtSpimOHkDWSQaR+rZs/Z70jFUk",
	"uPwz9D+Kt/gdXnFZHEElcHQTyii8IevHI0UYZSwjP0LuV/QLWVdwMjVDI56xIVVQuq7anohM9cDndtwy",
	"RnnF0/04ZPRE5yqvmupJl2HcS7yJM8DfY1Qy2g/KpWGFRRcllbwAk93aZKMozIslEwEouYNRTUMyKp44",
	"eWn4jkwdXlVB8dlBrNrnrAj1KPk9qlz0UeypPROIlLpbbeqoUG6O2nQwAw22Rl2xwXir8pABx2rMX2Z3",
	"WvOblETNeraT/E2Sn4lqBpTy3T4K7jBV4zkXY8hYUPq8xCyWS3yTG75rjjVV23NnYpVM0D2pgX4rrU2Z",
	"jj+7CL/xvozDFfD7jvl7Sg/TL8auwh6/5eA/fWpCrMKEYKn2cr9Wz6XZJlNd2KWUxrbq925BTYMox4dU",
	"M85pY9yhrdDe7cFf9g7e5MNf9gDu9OL3u/72d3yuuCw/dExrgy//3vIgD86A/DVyH/+9vJ+/PQ/neiLk",
	"J9/iJ9/ipm+xVFx8Te/indx9m97GXo/fvS7Sk2vvt+3aa97N+/XnbX0+PjnPPjnPPmX0fnIMfXIMfXIM",
	"3bdj6LfrpPk3dKPa0Tvoya1qd7eqJ+emfTs3fU2fpidXpidXpidXpidXpj/LlenP8TT601yJnuqePDk9",
	"PTk9PTk9fXtOT2Uzwjb+TsaFqeKytEG/+bWdj/bqSFTyHarUJ2rz8Bns1+N356k78Ph9dZ7KHj3lsX5y",
	"ZXkMV5Y+xZ8GlX3qX/Bp51JP3UWeBpR3ipY3Jc17rZY499k5v2LFlKJ4QOVooc//y1vPvjWRezOHc2ta",
	"aJcGHUwtje3+iTAicILOLt+N0IcpwixGSyziOywI0l3EyukYS345OIU5zDKaxGGMlR7taHL4cjz5YXx0",
	"eHX44tXx4avT5weTyeT/BKVpBLeHB0cHh+jkFB8f/fDDQUxu4Z21loqASThKs9Ahqu+aJHgV6GdZ8t3H",
	"79E5F+S7q1+/R/TF+MXpZPIJnV9+Qv8bHR28mPz08+/BKGDZKoxSSLusqYFL5QQQY4NekVUOPsYKpwlm",
	"BKc0XJEVF+vg1cnJi9PT0+PnIzBO51+fvng5eX5ydPjiuRaCFU7yXw6fP//h8PTwxeT0+cMo4DKvXxJc",
	"UJbdo5ODw9ODyfj0h/FCrzSN0P94fjL+NMuYytD010t0lRF0li3Qc3R4+Orw6NXJIfp0dY70agZG7A9e",
	"HZ4+f34yOTw9Oh0FWWq+++HF8cnkoemZZHam+mV5n9rO+2u3HJoUEPRAsXGNyp2p9GeQITbQap8RbHOU",
	"3yI9qvcXdFKdX5lqqr9YGvKc+IJU6vi+z1YzIhCfo4QvaIQTTWalzKGO/fvzqOc011gG+wu6WxJBkFqS",
	"3JJPJRIZY951qBJtdXZeEm5ocR5qxOxrUCXqP3pNtUTs9bl+mLbuq6Ppehfrjof0r4gytKJJQiWJ4JaR",
	"lEUEvUl5tDzwbERxKupQp0AxyP68URfqmWfpJnpXYYeN9bAFXe6wgIsEJ8mHOaQq7rr7Sp3CGZYE0hPX",
	"Ti9lsWx3zOyGrzsbZ5mFwKtwJ1gFCICoUVdYLIgKE2ru1U0zNc2lb50/131LL/jirVkYdEfVEuEkQVT9",
	"Q6JoSZNYEKalE56JiMigu3JAAam2TWbFt3N5TfgCWTBVX9egzpJnOLrRD57NAiXYj+8jzli/xhuyPx+8",
	"8uZ/LpWiMKqisrLv6PDkxckPx89PXox2EH87hdc8s409Vhd8gdz+dB+rDnG1tB1WTu0rfZaP7YMXK1/W",
	"aN0rtYa/BlKvyZwyLS9rtBaULZBtqlFEnBHEBVpxQZBUJJUHDZIxZ8XHWG+JEDQmSK6lnrL+n8ILJIlC",
	"szXiakkEutb9xwovroOSOH7gowT/VfVeX1N8DndUbQYayoqyC8IWagk14BowYU59Vt2CDE2HPmRymZta",
	"vWRSBti+K3dLrPS7xZIMwmhBbwmDvWhuBeg/GrDezZGt8zNCzICSS82hZgSRFVWKxABbr2AV+pAyQQ+F",
	"7NVKCGazTbPrQBPWtTEHjyvfG4gSmZep3lDOADuHV3Mb445Rdc/yyGMZ54P4oXm35MISl/4VHKXLK4Sj",
	"iID6DIMKL0q4CXYsar5CHUZDNUa+d4/IwDwFx4J8Kf6U7s+8ODEk3aLRmDITpBZBjzEw4MrH8q/S62Zb",
	"p16Yr5960VT/1oOEPezugkqlTyb87CRJjnh5X+yJPRjCACsnx2f/9tRcLbp1IOp2+NK1HI5UA5+K7DHw",
	"+r4kYkyZVFgLlI638Tkit3p4eP4qgedzGjVZAY5jYet1bqcYM3UvOlRBgDLkR7MCQ2c7TXNzHNGEqkop",
	"qxsCiutMwiW9whT045isQDix8cPmAglGQZLqVozc6b3JsigFt8286ZF+ACr9JYP/4iyGw1J4eHKm2yQ8",
	"wsnE/XHo/sh/OnZ/nLg/Tt0fz90fL/pYrR5jERseN4COZijz6Pjw+Yn56/Tk6ASIwkTY6kVcmuhZLVBp",
	"Vk4l103x3bCJtCHeQLToUkuWp4+EvZJ7WPG3GHm/nr6Pszoryr4dNHNMavnrOmeQ/9Lc3pKw2bxcQTEX",
	"CswWvdzIt1hbO4TRle+fxJpzqIeYPNRk8yvD/VuuUffQ7HwvmEYtWm3dYAtdduli8iLcqrpOMtxecTLh",
	"OA5TIkK1FATHXiLQbaoeb1UYQ9zI69IM9N1Qn+8iwxccxz2lh1QAuYSQ2qAdafdzL6SbVmWbOCGCfzfK",
	"bLVWbbO8NKhf6tZ9JuvTnelLmYiQsLwypp9MTTvk2vUkwhL0dZkMfzXQ3uTQ6kRY6dhA6tcCGSjhhJH5",
	"plwZqo/EdH099W/fNtWs+hUq9+j5PDWwHLoW5mfvyq2D1v2sVkTrpf+rdWzTATbpZRsFXpUu+ijh7AZP",
	"DXa7KuKq0Dzrto1C7gwl9q0x/fXqEhmHKIkySWI0W+c6dsWRJCxGRA/pUblsR3sll699FXO1hVtzhDEz",
	"ONeV4lto2txxddv5o0k8vYmaN/KnvOUwzVv90Dy0YurnVamPRaWmFlhDjVNu5rk9W2Ur6r9tnSBUHV4P",
	"jfRPerNma2W0bpsVuVJxgRdtOfMeKguTT9CzbWn7jWKZvj4nnBEkMgaWFuM+1HO7Ut+VksrOCyVtu00+",
	"MIL0bBxPre4XtXHGOP7AkrU/juBhFFhfP48jkfVSbF/J+vi+5fTVMHQFDEsriAapNiCerLmj7V4NK86o",
	"4iKc65d80/j5F4wGrzMqgFQe/bNvP+wyWAeKpp10Lb8kpux7qwOILe1eslXnoqIg45NDuPql0n95fTck",
	"ER1ntI6xbmoddL06dvObuaooQx8tRb1+P22YlMrOF06oCg4nB/r/NdZ2nZk8dNLLq9Pjhx01WDuYmPoI",
	"ZT2MsR1CWuleK9Yy6NwF2bUNA81Gpb198GHi44YM68ckxO60G8D1r7IwFME0DrxGRf1+GhY57tzFH0o7",
	"61HVY9Vj+vlUQtPB8/yySAajwk19LiBmKva/xtwyTgGidy/rw+rhirMxoyx4dXJ89Pz0xQ+jYAai2Q8/",
	"vHw5OTx6OdEMZpWGs3UKeX7gg27v/obW7oOQrhVjoQDXmcOj0sdwhe+DVyenz+13iiv4+MPRKIgjbsDG",
	"gnwJXp3AHxre4SiIpd7AySgg8NvpyShYCpmGh/cm+xB8ONIfDp+f2o/H8PHIfjrRn05d01P9yQEB+x+A",
	"ofoC1f8yRUREUqXP0PHJ81GQYKnCaHmjH7MnH37RjGcCkqiJlQATiSY3DeD4aHIyCszsn9u/woSayLLJ",
	"xH5hVsJ8Jl/sYp28LD6ZFscv9YT0d+Btomd0evLih+ejQEaZ0B9fjgKZQx8FErrZv21cSvDpEryR9Wrr",
	"PT3y5GbaxVW0FFHhqBdChjTX2e6c4YW+cVyg3pZoNQFq5rELQsXLYY9IzbEpJ7M3gEuCE6MB2htIQeV+",
	"d6JR/D749P6XYBS8e/8uGAXTD+e/vPn4MRjBaYN/rj6AU+nFyfmH9/rfF+b7F9Oraf+wnQoeyYIPoAVH",
	"2LrrLLp5hNMCbLiPB8us3+NZS6Yg1+3xGBmA2x8j23+/x8gA3eMxMgD3eowMyD0eIwNw52P03Hz/3H3/",
	"/OP0sny8PvxyDv+631+437c+d9HyJuZ37BEOULS8ca+9fSxwQkM8E49xLxYS1Q6gc6HQB5yyx4M9RHU3",
	"GDhIkI8CPJdIt6eOHHgFohHU9gkVBLW9AeQ3dMBrp5VmB8X39IdrxP49TVYzlh3xLLMA8xJ5BGq0L5s+",
	"V7h5+uxpfchui922h2S3darh2HNthiK5xAy762H4rVU8N/tsWvEe7d36eFDrk0GtTwe1tu/hPu1pr5Sj",
	"D7UX9SMcKHif44XaPo9OebOL1/6+oEXLxSOQtIYsrWpy36Bnu11CbXDruSUUuM5Z9YmVuEdBxm6YlhF9",
	"6uS0L819AQXJ3mfwJc/OvG/Au8kRrWAf6eLuKUw9lBVge7oiBkhdD2X12r6Gr2jo9gh01yPXxh3FI5GA",
	"7HfCwPIb70kmk/0I6cFpQnu1FLeP9dTzPND1+/n1h3/Xz+/3Hy5+DEbBr2fv3l+BQyWCZ72X78l+1PEw",
	"CtRScKWSfUnBkLeCxNvJTeqRSO+O0MXyMTbsTpCYyscBrPZ/Hz1023s6vFCMycyZ76rmABMk4rNzWQP+",
	"2eW7bjNYT3NgYdrr6xRYNnbVjf8l/6mm8ySPZBpmaawZd6vPqA0rMqsGfke5A1XLtlUqr1ft968NMPTh",
	"fHqJPsHILt8CVNNoDl8yNef2ueDw6EVuse5pgHaG5BzID5PRrlbljZkTStM0iTCAzlp2Y4XvY5Jgj4vL",
	"lCgJITkWXwRvh1ucoBlRd4QwpO44wpniK6xohMyWShd6J/HKrriLazq4WlJpQ6SlSwBvnAcKr7Dhjmhy",
	"0xr8avF/DfOsOp45B+4VZRuXwWzT7suA/qx1sBPoXIfas6BPoN+mYU2KOV8MvqALynCiPNkB3MAeXHyX",
	"MrmHcLv+riE2LdWWLuVNVDqOo53lFQeOQPp4TutWzm96mGdHDr/i6HZJKn7YddeOUqcGStAV3MzQXPAV",
	"oCaRScD21/bQGQVyadMd7OphXSySz+8Dlnewc3W51+NmV9glF0KTordBpUy1D87hZmtoZbFXE8DWgAyV",
	"9/I1BwrYk6e5hlVyM28SwnZJH8pwNmR9sFeLSZexKbFGuS0UtjGfC9/BPr0Lb7T8ovFGkpXuheaP23IT",
	"4AMedvyOIclXtXJwcgS+bXc8S2KU0BuIYY6phjbLFLFx6TS6GQP5uBTf8popbsAZFkoZgqSNEBFtw9o1",
	"zbT118MQHC2h+zWLSZRgYcQGE9AOYK8DF89ygDT6WbREEZZEjtC1nadukpKIzvXlopbkmrE8aRBcPJTd",
	"8uTWgabSj04+ZT1W0M8Bss4yN/nyl0l2w3W5nRd/hTXXLsxwmgcGNS9MAWG3LOp4w8wyuQ5TniQ2y1CT",
	"Xlf4PpSpIDg2nr9yt1CMajiFTceySqM0yyRetIY+1ituGGnZre355SdkuhcQnRavP7SUiHEqeESkJvw0",
	"Uwjg2GTjwr7ISvljeoFG5yadAqx/0X839IrDEHEWWb/WqDFQSlMi9zGKAWSASiLlvrCXZnGl/tk+LOwo",
	"vyd0tjKpyPoPglc8YxCp9PHsVwjnIQsMUSIwgBs/M0/t2RqYkh4JGDMn+iB4TkHHc10DyGSey+U6ABjX",
	"gUl3gOzJQiavGuIMQdI6O9ytFtHkTgO6YYSSrUNOM/Zh6j7HRFDNNkFOnvIECyrR4QTyMiTY5jBmfEGU",
	"liRdVrSt8CvBAG9ryM1mSvw6yZrffMlIJY5kmzU3QDoW/cfpazPcHja4Y3/NGIJkkjjZf6uBph/Cj28+",
	"Td9cfvh4ZWDKNKHR9st0QwQjCVJRigCSRtlpBiSPboiSFdo0ofCULUoJ63Z8bb+BbogLZLvBkRzPM2Zu",
	"RDMQykeuoqGwvKkoxnGmeDDaMzJ6FLhLKlgYqQ8UjyQXbXunJ6mVQTDxKFMNywgU9QEG1yLrGOCtze3S",
	"uL43c9SzODZyoMAs5itm7kSgKQCTa5isDUHD14Jb2Nfg6VW2pERI6iouN2QVEaeh8VDaUyrnvPxKnI6t",
	"65O//EmconP4Pa/NVw/EKIHYGAWf5xZuTH+xOb5qYICUvfLC7ty0uYyaSz/lPIx91f1ujE5ZtoRPSC3P",
	"7LQTlBMVWzS70kS2JUOoD9tUp0MeihAeKD1dq2uyc48eWhQJeabC/gZxJ4OGs1SGfb2+K536e4CXew0w",
	"xA90maz4Q/bmF3leMhIP2aQoW4W644Dm/RzUbGMpk2HwhRjcfuAYseBpSuIw4YuePeaYJiQOQTbL8pdi",
	"DxcwzfH1A7F/Rk0aJyRMo55b/p981hOVhEqluZnsnQV0ANKu9QAK113y51e/5voxNHAELbwNaD2MjlyX",
	"YSjp55QWG8P8Pd+jH1kBGa1mPdOyzoo0PW2ppU2LvmaqWt3MHMqVhQJSeOwP57ROZjVdq7tKY/d0ECRN",
	"1lryvuPipniNboXgpSmfDgQWzgXpuc6mfSZJT6+4lPMkxEnCo95bA10MPxnQQaPUfwh7mdsi5/51NzqG",
	"7RbXgjBUUBqRdOYylym+YyRGRePdSK+AA/JjQrAkG1LMu5TvtrU3vbxPtywyFuYP8R4mqWGMKm8+5LLX",
	"jMeFYN+Q9ZDhSj01UxneG2ohhQnnN1kqh3ZbUSnJgF7OD28LPPOu200z7261cCFoLvr3HzbaYAJQPE17",
	"S9a5gqBHU8jEn4vi/TplgHnYU17IGGDvvIN6dGjJru8OtvkdvC96pbvZWCpiU3GIUTD8Hm95fy4EXnWY",
	"RUyDrnQcEV+tMIs1dinH4xWFUqjjscsPM0Fj++U4EwlUy3n17JkiUh24LKO20GOwWsNf1lZuWa7pC0Hv",
	"WKgxZ2NBEq6li5J+CXK9agD5A7wRF5/jWZ/r1ZIg+yNSHM0gOdDIWGDnCV6YrLjWRuNN7pwXqmwChp80",
	"WJFZ/YwdCcsRonMU0/mcmMIPS8wqVTGg68E+XR4aK9juUMhTM21BIkHAGwls0I4gJMIKGShbJPU2u+Vb",
	"Lv3Ldqulex5s9LqxpOVooWxMtEeh/ZT0d4Z0x8qTuPlLRqOQMqooTnJF2gBL/L99eneO3pn+XafSjitI",
	"aRJ/8aRJ0GLN8IpGY2KlSy1c2zJylu3pWVobZrAg6uz8QhZKsrXeiigxCsoHn6KQWDVVnnwdqhUKYvxy",
	"oAKILcXcW49oCay8cxu8N3RT2/KjrQbWoJv+1NgkuQc/Vi0ZuDpxk672vUyxipaDvPA2cIlch93vcuvl",
	"XGdk9U7eZ3+vnCb9hLQFvg7Hk+PxyUlQSslCWQgnXh+eB38it0r2z/iPk4ex/ueo/I+fZRtsoCKfVHiV",
	"+ssX5Xn/2xy5q3EL9gE4qmA+CmQWRYTEZENyosZCtSyx3LTGA/0S7XgeTD5acG0J5IxV09w5/TznXI82",
	"r7laTq1tPMPKCbT6uId9tCjt6hrm4JQXJjec1YbsSMhWV8+biNAwxWsgWJcfMveu/OHw5VHJufL08Mir",
	"suRJHLL7/TqxAFA+kzwhijwG6J5RtkPhCjLvqQwaCnkvaVu9kG9xQveM8dYOvlhIMjYkPtbk6/egsmcg",
	"1He8yzbckTm5qB5lO7amg+81uQKY8lae21eRqZx7tPnJOVbQybVtk6F8u2A4dXSkl1urTLCw5F5fzeO+",
	"8pcwbTe7eh4AGsjnTXxSo/GzwUJDsdqOnhcIZYu2y2Nfvsl9Lg3QaO94YThRJJ/Sds7Duv9Gp+GOLMW+",
	"XNFLgkp9ENWPVvtUx0nlJwMk1/Y3ykvlLyEoYZLXP8F3LVVQXOmTUjUUUwWlz/PJPFlM4lPFEdR1dyV4",
	"KFM8xxHNMv3itdabhPRO+dFcJxeDZeqkQP56Zv2kVkRKvCAGj7iKwU76BisEDEf4g9vCSjLpvKSYHmBs",
	"l6ZRwjqv7mcLZe31MnLAC9f0r1QlEE5yK/OmbNHFuKH02TCmnSd4L4b3MmsjIoY4jsO2VL9Toozjd3HY",
	"0d2SMKSZCFsgjBi5Q3kyYP2Vxfwf0qWZ3qIa1cbk2ZC+cOwyW/YMNzKdTGz3Nn53FWWIAea8ERslX9xo",
	"8BLeLx1XR94tBsrAkoT5U8XjJOF34UQo5RfAcJKyHXzqzi4u36NLwRWPeAIP8BmObow+dqDGYatddf1g",
	"AcZ5NPB2IBgdQIq2j0y2HS/ccekrq24d4/RXO4B0HnwG2i3F4EQhT7aZIk2XVszadA7tGjqPQzcAHEEL",
	"JqOK7A5LJKG/0sIwODG/Y4/AFMB5MByUFKdWcR+y/hgXVACGDDBwYuqf07NGEuLAhlJIEmWK3hJkFFjI",
	"uswCdKkeYUHmXEQklDK5Pd6CAE1vlcjbw8lu3Q936360W/dt5m7yP1lv2eFBvZXu+7mlelbUeAQqWmHd",
	"iWEWkS1Wsn9F7PYIJxeD1Ax26utX0gK78Iepg6ZseB3vjZvD+NaHkfHtT6Lre7hD36Md+m4135Ttesvw",
	"GcjklbqgeE0EVDDVf/SqV9o5AhvnDuuFccKxcuP5amXtUSCzOCZsHBNT1G6Fxc04bkstx9lYNyDx2GUo",
	"dvDlMlP6u7GLbtvQvypJ5r2NkNkNBJzntPDb/yhAl2Hur9AlzcSChHkCkv0xr22Yb8s5rjoJ9hcTTfv7",
	"9fj2aFwKlc3fsaWoo6XTxUREqHHE3F83JP9S0gXUQY2Oj6IAnJ/Mf8dG0AM7OP2SkTH1H6wexR175gZ/",
	"sNblbd8MRefx7dGW/UPoH94ehdu9IxowwohtAybhd+Cdsl/iHfaeMupQvw11u8UBt8PBMWP92KcvvGx6",
	"gc7PisAyPTwRis5pZJ0B94yDHUTzK6v5cSs0nV7cHgej4Opient4MMn/Osz/Osr/Om5dvBVljwM496Uc",
	"uKPKxFAN7ZXIUFEI5NxdZ9S1GZDfz18Qjgg6rzAZxhkJSjrHHYc2Ayx5Py+gNkhlRPP4P4fhw6Bsgbqt",
	"Lyh1qSlledRLT/9R36dgQiEzE4mLpBIEr1BqVR8VzwhnLz+LYzRtrcflVKZt6lIHRQnMJIWSWEY1WtJ/",
	"thVEs/nlTiHVkD49ELYKi4hjfV3l7lE4yX/L0rxm2g+TPOBVv5cO8092Qe7IrJRnZe8K2TLKZacsgzu8",
	"o/RpEZj6pb6eb7ze7w3PahVowbKBdFlyh/68p0xTm0QoD9X1pbguQ4EFtVVFuBpd+/x0Kpi2++sUJ6PT",
	"zNjPEmsJ2EbsNq2xw5UTfbNWr4jCMVa4y9Bb26sWY1uP/JCPW2hwg5nZbbAN7HAMq28Rx8ODw3IRx7u7",
	"uxJD+mFSzhWa01Z1W5vxwk+2nSfbzpNt58m28/VsO6a0rqQLnCy2gJbzhaLMT19a2ZNVKcrELdkF869j",
	"ltqsmX4DpqeIZ+xvY3qqh8pQieaUJDGiEsUkFUS/8CHd3hzfchPxqvuOIIrnjiYJBDaRFbdZ+TCaZyoT",
	"xEWjDozisTRhx61hXSjat0DbdP7z8D7cBe/DPw/vo13wPvrz8D7eBe+vTd+LrBHP0csTbonlMrTF+rcx",
	"gX4bFlRGC5G63rzv20nDaDyl51mSrMfwoC6/qs3XrTaeR+C6CQe/wp6OizbxcS4X5VYyssARaFsiRdTY",
	"XER+2+6OluEhQeH/TQzJMsUtSvyy9fgvcp9WrNZ/lcu0Yi7/q9ykFTv9X+UarTgIbIF0+Rr++qhXTQZP",
	"/g1/Tf8GyLw1WGn5N3CM+Hu7MJCYil4xOJeCzOl9KYRszEi9jMp3hZB88OrZ539+/92o/s3/agl/NiBT",
	"QeZVOzBNb/U5pentc+8cXVgfT1VdbP4OtJbjOEvHNP0vumBckLGxK/5XKiAkxv74/XejAY275yDkINVZ",
	"LdFBLa1BOX6ulNsgz2vw5IEyHIzKZzJWye3Yxhn6ovmb1nXD/DcFH1KNhWnry0zQWktmFOyuVfxGPGyc",
	"vnc7RxSjFb+leFxA8lhWnhx5nhx5Nu/oVm7EUMdkGxegKA33HXD/rTsjbetuvbWv9daO1lt7WT85XP05",
	"DleNq9Mm6b+jKlpSttgmtVae/Mw4L+SwkIZV9WVA30VcmKQ7MVRVyiQZ234xFQSSlX9fz5MHSfIg01Yp",
	"Y1bwBxLkC8gtklE0puju7u7A9juI+Ao9aMZuaqs5xxhwkXhK6tWW1Ku6WHsTuq3bklfkrif/qqDwue7A",
	"gqY5cUGCr74U3eG6VXO9qVKv9eTqRbby+74OX/5D97BhspvcvkL9Ek2smPMV/L/mX2LmL5jQ082LZauQ",
	"i1BgtmjJQL0X60tq3tlblhu1vWvYjszse3h4TYlCGLmt0bRjM8rR3wt3QUg0ol8xJEaw3kQRASkzS3zQ",
	"rHew4HxhGFwdqVfB4fi44pHqph5Iceuhr5xgmjTU/8DkPYY5PdZpth072UrxvZHcCrcmSl5MqBp6X06p",
	"ql2LB0h/p7GEHySNiSYFLKHcoUaHRgTUzDhJ0ByLlUR52QgESUewcu0OrtlbaGGhFa0cIJMqQvMwt0wa",
	"dF5M0n5XMDaHXkIUWvPsmjnkCZJUk2eeTLRerXHOBVpxQRCObzGLSJ4OFko4PVti0Bw8q3S7ZoTFKadM",
	"yYPrmvcjTB041wwnzvqHkwUXVC1XWgTjGYsFn1FT5A9y20O18YqXpJtjUKKk35r+4HXnyjCvPm+O2Mnp",
	"8xeaLzb7Hfn6hYzcVft+hpSuIdZdXa11/aXtqqWIEAjM4GlrZenphEVVvLA0yyjhYGfITZZHk8mkug4P",
	"DfHHLmpJq1orplgsdWdNW9vMykDDBKqKVOTWpC4X5foiGMAet6BbWhosku1zcCOqGbeNOyziOd9YlLXU",
	"0lMT3FKyilK/bWfbfEMFOx3KIDdrxIsFdbNwpD6qLOXnnjmILbwNWcg0x9JssCeSu6ycPZbVQ+M/pNWd",
	"HKuMMZLoV17p7IJtMR67j9DQLHj1uxtC0jFO6C3pc6bc+I6Ic17QzEVxdXVZciawReRrpWh6kYkrS9xj",
	"/ffhY1HxfhhycJoP4w05paZU+d8e1Cs5uctd4PXTTd910/djPrQmLtIWGXGl0mjZXnIu5itM/S+YJUkS",
	"3rMUXaEzbw2P8cRrwW+hLQ3rRSEWPW8rKaLKwY5FSFPzsgZz+bzNrYdH0e5D9Hmj+SzMQpVmP6xzgVCu",
	"MLNr7ZzJ8z+oPvQW3Y33S3vcziiQKSchxHR4jvflhzcIftuU7FeuWbSN0z5nirKMjH1uEc2U3UXHmDOV",
	"8MWYcbHC29hvCFtQRsYtKULtXTWWRI1vcW+soD6DbD945Sy72yv5oSLbXiAlfLGJJyV8ERrVlXPrG8/1",
	"M37sHCK9XoXjO0wVZQvTVra26yisbRoQITp+N0kq5ZDkr6PAcO9Qb22Z6trkoxbxqATF1n0au4ow20OC",
	"Sjc7wrnFYuxXDPWAkdKUJJTZvLYDj5RdByj/uw/qFGShBTOhTyAcVP9Gg8fBXODF2GYa3wL1khzRM2Fw",
	"WWbKuWTQyV9lC4M9gx8RnxtJKeIp5DeF38DA3Fd8KDj5Qw07M4RPlNB99CBtyJnfShg0DV7lgVzzHoIx",
	"DN1SJwdgmUI50grr3RfQNqygz7Ya/Nq2teD3HvR/gh/3tK0Gj/pqmyHattWuSQt6eYbfXuuLo2QTnjgy",
	"kYFYLPzbAJ5RTXHyr2ijKhGVQ5szx0HG8IjVQI05q/SLimo/GGHO+VSa71yZNw+c/KcGINvWFv2Ar+zT",
	"ugLb9LOt+uklfELjDifKUWXbmSqfZA/Z/mp/3tO5ctjUT5Ybpu1swbAtKBqUrE6nAtX08ilbcpieeZ8l",
	"iZnd1DQYMj8zYn12OSDv3CDLCI6Utx4d9K9avsvtKzrtMK9qdzSyBXNeHJPj4x9Ox0fxJBqfzGeHY4yP",
	"XoxfHkez2fHhfH40Oe5dRycsFc1rS+7Y1wttUEEcH2N6qK9x1xr5Kb/Upo36z9uADrUD1fe5jv2VD3SD",
	"WppOaDXKhQOpl0JhkCrhyDp9ynR68ezqYopKIEyFuRuyls0bqLCF+PQOzksaymq2+GR21hKAR+UKUyY3",
	"54HxCzT+gGtNiqmL1iNbA6dSZlZDuU13xlWI5zY4rlJe1jw3eqebKY2y4OMok4qvxgovwH4rVq+uoeGr",
	"vDqVsQBDjpffOSPXQWCxmZE5F+SbQEcSQY0SockYlvgwnFO2ICJMBWWqrdXR6fMe7eybuXpK3uozUqlq",
	"cBBsk0FRKi7wgoStL1+ZGYbT8VuIE80vsaK3BpDsbN162Mr8ZHph3FZ9fK/KQXyXH3ipmFi7MqdoPkw6",
	"+V2NU3nQ63BCkUlYitCoSa84L4CyUVK1PrznZX73I5YEvQY1NRdrk7tBDQTZDS/XiVMWh91ZMpqwX5vO",
	"6EfKYnRuO7cA7cqZ0Q+ygdAA3yeNxqYBAAaaWhiNIbryXGwCbfrWQZYoZjjMD2lu76kA3WkNPJO35vtt",
	"qcL6s3joogp4O8qoQm/QhhtiN+pwg7TShxtmOwpx4Bs0YsFuSyUWrodOnAvebutRXoilMTSFrfKN0aV3",
	"OVrkwltXye+OpE9F99bHZ2t2oV5v2pqJXSZvYE5eG69n9d7YFWgBI7uFujBaYv3MwGrpXV8on0julcCF",
	"qq7Xpl5wHKM3uqO54qxSXcrEmaR7maChSFRKhNN0I5aH5kdFAgA9YNRIAiBl0qLAHzyWHsAFn+omyJrZ",
	"rFE83MoI5aM2DWcpOOOZRPqB8u7ZB5Q7/uYP0S8ZqdTn696Kf9Ot0dSUHLt0zsIG1C21Ze16Qbp0HUqd",
	"W2hnAwR0qXuBABxl8HhKyC1JKnbL01GviEHgOdsGOFQx/BdAyRMGlqVDPdQNTUNJknkIhycOI+zJM+eb",
	"OEnmyPRB52cjhG8wuj+dvESCc4XOz1ps4AorGerXZZOppVjKO/9L05Uz79aPQauRg/O5dXjwuHHavlb9",
	"qc+4ursuFFDGyaoPDFc621nTYdkefEW1IYJWn0vCNE+Fhv3LZ/tXqVVEt3sYryo+EV2kojugM+hQ0ABk",
	"ot3R/6+GSosfXqsWuoQYqqi96yj23nbf3Hqow72IPF74RnEKB3jyFSe3zyVuJgQjtJirAJ65UoaQ0RvT",
	"ozjMNCYezeVGOD/TmKB/2X5e1jB0bSpspfcagRPdRzdi11qVPN+63V5M8zqb2bgiH6FDtX8BpYeQ6TkJ",
	"effOo1kacy6IXO6STKItihrgyyW/C2Mio80zqvZJyIKwWA5ZzumS36EL268KbcXjrCp39oP2q+1Xhca0",
	"sOaE+G2ShtWIDkIR8iEyQcPhgTGeO4VGN9vEDL4mc8oIwsgOnZd0jQTBikCJVabE2uTRgWH0C0EiUxCT",
	"C7TCNjYq9yHW32IpeUQBggYpNEhspaRaPE0xaSmiYroA9ylGsO2SyVett9VIubugb/uaFGQ2ZBRwmy9e",
	"kJJN133ua6uFX4tZlM2umsbaowpzQu8TdASguuIHTYvKZEb2S5iu+8DZqNbWTLR/qGFxQB98c+3Q50LP",
	"fPNqZjYAcAVn8R0zpgmfQwTk0epSeUCD8m6DZj/UchY4CuUf4XnsPkOV4tLvUAjeNICsSuY382cm3J+2",
	"xSKhKlraNvaD+ymNzH9LX0zsP6WvDu0/xVfKtFLWN1/LC3aA/KNtC5+JEOWf9cfyz3NMk/Lv8Nk2KIpM",
	"6L+ltO3gT2jiL+9w3+pkVmY1+W7Ye/w334qo4LPx/CWC8rgX3PqTB2B5nzz5LmaQ6auHr35NmaQJE+jy",
	"LcxlWPTHtoW4PRMBz2NIsjQqLUzO5GeUYbFu87L7/9h79+bIbbNP9KuwVKcqSUUatcfevBufP/a0NRer",
	"ovHoHcnJ7sl4uygS6uY7bLJNsqXR2v7uW7iRIAmQAAmweUGlKh51N4GHwO+54IcHD6QO0Nb0Gb222Hgh",
	"Vd5Ar8q7NP7sLf6CZozkN1qgpjPStILNKbp7OeOLCqN+LEyj9SFt1AT+GIEiRiiLWTm/xpoUqcksWx2F",
	"R6hhUnxEvpvcvCn8+pgo/FpeFPD1IPdDxuCq/F5eEmikOBWnvvJTXvKaUzIKVlUl5BBkhVqpvcM38r9U",
	"azj/9TAjlA3YleRklLyu2hPyI1323YqPKHZDAwy1J+Q7EeQGkUrcggOkG9nKD3ngIv9redGPKY95ErhL",
	"5IJeWpxmU8IFx0+mHRyl0EWKwvNiVVVSNPD1ECRtlMHnz/5f/7xPf09/3/+++93/y/8QlUCTOoAgDJ6i",
	"GBcRlSNEfoqdW/RrJuyqyvzl93/8vv/9w+/b39+LhMaP5vQQSZ5qXWTicE0pToMfbELQ8czq/QvOOH1O",
	"ggxscEHUFuqKZwJF+KRLUkyXKGU91vB4T0Fdw6B32OTXA1Uz4Wn+IB1hL97vQb4uw5E7+HrA/0hpMYbI",
	"vwgf6b/I4Jf+ol/jE2f5v1DVyfOzY0S/+eWcf+yyew3A4pWYQgARPi7c5cYm6cal7nfC9xXQQZaglWo9",
	"/rv/xOCFIb26TV4CUaUF1Dtuk5QMEJgSlYnCt+LUc5lv/uPjP67Ozs9u/uPT3S367939Hfzv38jf3119",
	"/EnqArNa/2Q4cfdfvdDFdMlm7yZfOr5S3iTvGh/0nfO26Mn5AHv64/yMFGfVMzVwytE77cDXjd6WC0zl",
	"HZAmdfeBOwhRUqoOeGG6kq0MTsVM8n/hf2CFynUpyf/FKNR5b3siGgIJAH2gVPgeLoWB9yRF9jTDP/4i",
	"UD2kcUQD/4b//O7jP/rrWxxt8tOrvVuiBxt6t8XQ6BqnUk/NNGXI49P8HdST3xqtD9+znaK+tQ61JvWa",
	"+8qUhlqEQRp04ZEiJ/2gmMXHjKuT9x9/vkfaSP/xHfpHb418cpMN+HpItID/33ks+AvXlP3TTZy3Xw8J",
	"Od5HutflrP5dij/FEtzEW4cc4CASqFz80GtYGkLkfDbyc3qnl6Z0uWU/PamW98C/Zbb87q9unStyiUh9",
	"ZUUXN/IJI8V66A9OJw1reS/PMOlTfxf2RFJO0N5eS+ld5nCsdMXdNPGcb/7++tU3f/vvr1avVpff/A1V",
	"2Q0iH3w9+36Vv1qR4cq57ry2NHQ9D6C9MzfLXG93kSZPsGf3kB0TgG41uyB3QeRLk4sIZKnnhiC58NDa",
	"nXyM7f35WXh0UUYl2SJKvQvX9y/wblbqXQSRV/tjVfrrG/wXRCfe1yv+WNGFT3qIwQU9+w6/fHAj/znw",
	"s90FvnSTfOqhK2OKv7I4JX/4KblvOP+T/Oux9Mwj+0wYby9wBir+m/ldFHjgjF7JEKCTfhde6KZp9cP4",
	"8TEFtC+c/kD+xYpT9MlT3TQI0R0eSYxeH9WqvUB1t0h574vUK2k4LiBBK6bh5hJAd4D8GL6ZjHeh3I3Q",
	"2DDow8VzQL5HiiwAMg35XOELUmvXpCo4N97UMxwTY5qQJKJcwch3Ez8vsAVKTqsqbUN2/wDC/kCfd9Dz",
	"+BQ3R8raFvG4BpVYGEriKYTBwtKQxGYxgqqhlB9CXOFmnRsQbXGmJhU95aQz/e8//4/vSRmbX/76+fOf",
	"P5/Ra4SQR//L57PPn//ye/6Lv2hZThp+8zv8nv1ri1bwI2MshsjmOtdh1U6TEaYxlC85+nbXyXeiDa5T",
	"h1MsXCH1Xb/UzdK/z4p6Igpob7FX20O2EdyY1IkEYyIaYwBEm1kvDknocXBj5P7X/BxNfhRpDxL4LjCu",
	"QzsFCQqiQAKH/NlNIvyqUZzhCCKIHmN0PuLhuM0jErUFqpghZCOtRsfzBwo3N0Wbpig7GNTysKaAsJuj",
	"6+COcqcNZS9qZKo7ar1S5dcNoHscC7iz7m319d+ri7+vL965F4+//PV3+Mcvf/2LnjHOI+qer/TBTb44",
	"/6Roh4F58S45N/fN6vV3DDV3gf/WEIfkiwHViOmnwAOF2PQuwPwOGdl7BOVkJqtZKhhj/SXNUcP43+bX",
	"3hSvUbpQsD9UtMpbXEzICEyKao5M1H+6SYC2lakFSdJsk2WhUiqomClilpWCobq7d+7vb1CigLcppxb1",
	"4qiK5f4vQ/nDa8SckDeJPG6ZkK4vo5PxGG5A3uSjIX/rmxrAKiPDvCNXPu8OZM417q8wjfRKB+V1uEhF",
	"Ge6LY7TpGPJFxIeAqToShkWjbCxvo7wGJ6XIc+kOMdjgWggaJazycf2tHK5JUBYbtT1qqVGty0JoRMqh",
	"uwc2HbbVhGIzXJ8yHNCz6FIBnMCCufK8EG73Wx5VrMBZEKWIL8ZHEomktXsi4/Q0AShcsfaMP+/jtDBW",
	"iI7dcJM3OzmXnN7VuPRFBA+z4HXyQ0tIeJwrSc+FdHEM7RGokRe7h006OKfzioifv1VWOSfdI3w2Ijyu",
	"nOOGJI+Q2pVq9qTA8ZeVjAkEznk3QScbWuLuN01qRPcqtA3HP93EeXeqbVx2I6W866zx9cqB/dB7wwO+",
	"Iin5KiqewWzesluqoo1idve2IRsXNkd+2ng8lNmaLV+LKr0NXdpO/kP8Qm2b0vi4af9dadyO/LZ0ccxV",
	"9750Riq/S29K00uXxrSl3Ht7WGVrl9VKbbu0Zf7UbsbazVit+3rNohjcvlPrfxK7ctVNsIrVElijXzTj",
	"w24Y6dowap6GwXaIpMUY8ZZQ8zvMYw/olOS+TismiNfU7RQihIucYoYTrvD3PWbPKIHPtUi1rRSt0peE",
	"khv6ftsAwyOivkVQMN0mjXwDiSwn/e3Ht05RyLd84dSohX5fXPdk+eN2/rh5RMuEcZ3g43J6p2fyml/q",
	"BIQde6Khxbxppdfyvbq8/+bupZgvhrYRU18MR9TKfZEG28kv8sOu7BfLW/3R8FYN/Ffieg3lksIgzZz4",
	"0SE/wHUK0TMpvSxOWuK8p5davaqSIJwiSFf5/cykdwffH1flt9B39cfv0SMowAYZSKAl3AcRSTNmypCK",
	"qumhVlnUlESo4wWNjyKRyLSZtty/x8yW3IDDH7eVFLvHQmPxxVd+cS/GnvmtX/Ex892s6wVgVyp3fzVf",
	"+6Xrxi/BZV9S93xlxwhsHo6Pj+ULKyq1yND3aUFwqlcO+QE34dxQFo62mQCUlFKqJPxapcVPpAHcpuDq",
	"YuHzzh18oFaDhbS0SfduGFarHKu/PewEXXQEm3PIqzt/RtfPg32cvEDfkSVuEAHfSYPsiK8j+EtdsENw",
	"APLveBscgNP4oon39HB83DAX5HaYW1JB9BPwQPAk1yG58rxTf+RCF5Xu6OWa3Tp8R55W6hLnWnXrkORG",
	"yXUHvKcNiOLjdicHCtrqW/SMcxd7X0DW3Eca+dpQcgf/T6Y3DRCR7ksTPqT70wCOtr64hZegtQ+PbpOp",
	"R9SZjqVp1dwmaeaAr8A7YndHuuCuQdEN/f7mhVZ2bR+Um6ML10we8J3/RWuoIvI93m5J7nTPq2PQeMNu",
	"buItDvl3AP57S9KfYW9p5oMkKW3IHrMYxlCa+iQd4Pt39mDfDUGwRXofzwfkf5yf6VW5NA/TAARgtzSx",
	"snH6SZKEORkwBXrfJEPmpl9MCXDvpl+aeheqrlBt3cMhBNnm/4Ak3njx4WXzGCfPbuJ3uO2fm1WKy/rF",
	"jw59DqEfdncBu3OK7tCP3MyFH6EfYdFwua94f9js3a/5jpj8tVFX8T6nrm/oZhURZvPophl9Y7m6fW/w",
	"kw588oIZK6ZR0VjKN84bnvyydHSHxob80802ceRVt1hWq9V5y/UaqAqnG4axJyfaO7QIctbwCbzsuNq5",
	"Ed5uefQ3wN+CTZYE0KgBXwdy/C24yBt0DnEYQozQJNzdN+wwP/t5vaae3eLHnDiheK3ANcEhUFoD64/3",
	"97eX3zj7Y5gFhxB8JaVIq2KmIPIHEBN2Iy3j680D2OAqxCDdZLsEpLs47BjRrI9ZvHezwHPD8MX5EoSh",
	"4+Y3BRSZa87BTTPHZS5yowIUIgVRkAVuuHkOIj9+3sgvXq7xgw5+EN+iC8cgPmbbmNyhwd5Ih7uDWlXc",
	"XLdJswSUt4AljA33DjzSErqdjiNCIUHy9eH42G3Y0dS+pvAkC8WWN6+FmLvXm0fDSKDhsgoUHg1AIYi8",
	"eM+HwuNAUOCIUJYgizM3ZDtXn4O6MKjRQg58nyI0sKxEBE08wcxhlDslPIzugOuDhFTLp1CoFoCTFucN",
	"zkRyfkStkjLJaFmEexNAr/PrU0T+CyOS6akP6kjjdL5/yuf7irmLkzRY9PaYuHugoE2VXt7Bx9k3GJuv",
	"e13zdVl22Hhx/CUADVVQRIEkfIwpSoIaC+PtMQmUG/v503W1pb37dYcL9uZY/vb1f/ztPxojuYYuCgxg",
	"aKeYCg/B5hDH4SbduXoitTvYkHPthwCCjTWmsDO4EEp4CqprWYQ6xtB23hQ7JZyFWRikGYhAsslvRd65",
	"iZ+Wr+OhV8yiy3YuoAt0ffxvvHMvMyI3pKPi/mTcESsDAubm1yM4Ag1zkPf4ATbr/Cds1lnjlG685CfF",
	"3TYHaDnxW/XyKLg55DZIc7gfkkeupAxYUOctWtKQdmDAj9c4am3dwuf8clsJQGXH1Rr6hB9y7g4uXuVg",
	"vn2zi7MeTuAWJARUznofHyO0qYqZlLOiTurGc70d6NMNuWbuJo6/HA/OFWwuN9QHABK8iDwefDcDpVVk",
	"l5gCHVa7wGemSJOOmzkxWR4ic7MLtrvNo79BOindkfMzjE1+DLY7590b5xN6lrYYxs9dG7yJn8vtGSNA",
	"2pxXA/1xcNMUYgVx7RU/lgCUXkluYyiv/v/Ople+XnXadfJ2wD+iBTctF4TYmAD4jvuYASxgeev34CYp",
	"oSmIdGnmJhnOqxpMugfwGCd4kBOAUxZqoiIRg2iLrW/HyLrwrthM4LacIMJLHHRXBpSQbNmhPo8R+tXG",
	"B4dsJw/Zezf9glr+dIywacfZlzvgIyUI3Yzmx/R1I/Gzc4Nbw1QjGWp6IytzJrX3sGGjkbcmpi5/PQae",
	"mL+kC8oNus4p+7rRsOX8nz9fXzn51kwR1Dj3/5Pum+S70Xn/0J6i6MoA9VsWCGICRT2NNHRJMLKW2DwE",
	"ftBjTGDPxQz+EJB0JXRkllldFEuLME7Tnv2hkUZGES83buKUFI2JE7gMzO0/y392MSvIG+SGhGzTHFy0",
	"x0k6gwpdsCJIiCx56UuUoFf9BFty7tnGU7S/uomfI1DaGaIxZPkoqIx+o57Itu1H1Owf52dGFm058Z87",
	"vpS7bKPODklWcnJCe5CmodgcoMCpe9x0d3dTCZZo5UmS6dKvaRo60ayOq+CwAwnKrcN2BfWYfa3Ef3KN",
	"M2t+OB6PgYcCsSDCb3RWXCuy8Xf4gIt843Ql8+ZH55amz+VjhDZdN4ckeHIzgGWXvBX67gbvvTq3+OFC",
	"1C/gJYx1RGCwj5t469zf3Dn/AC9kFfYIaODU+XLuejd0e/CGNs81zGhB4sWJrwdHDEVG77yOvfRAYntk",
	"/ZUuIhf3dg099ZMbOj+A7BmAyLl/jp2c5XV+JpE/CblSaKw/Xt0VGahnVdGCqLdoOJTUIJrQ3Dy5SSq2",
	"N9swfnBD7GM7mwZ6Sj913qPmkN8TzO0hiT1t3d1irqOpvwT8moBUW4/kMP5lnpXc0DW6CE9Xx1Q3G/rL",
	"vkbaumNSKMVdCjH3f8LgQYy5Pdjn++B50PN3VZrw/w+DB5rDke+LY5K7xql/w96o8t+lWy9R3LyXPaY4",
	"suGnFsNvkW9EP6um/CI6LuXedgdXzs9x4gvubvSgP+f8Jr87EQvGOzqBi0ivLv5+sXn1PTeBuJIynjdU",
	"75iRk0kp/xm/K3eo4GCgnI0w/Ph49v2/m5N76RObBxfZ3t+EA8jPTm9unZxjIpJ1bgZN7R8ccPxSzYv/",
	"maLhOch2jhuGTpD9KXW8XRD6CYjgcj8+Jh57cx83v522ww4qHiLJHPf40XFRujf8PEvisAZNLchBjVSA",
	"gSNFNwVNCEnbNUoxTfzIDFlVHN5FiTkiJPS6gyhVMXgiPB+Tx7Zlgkp8DTK8fvnXz5/e3TiwV3cLosxB",
	"DaE9zDNyFeDmMRDWuKocQUPry2xHwxLcNuYAA3yQJ4jw0bIgjjZU+1vbXTvpwfXAhQ8QBwJ8h57ewT14",
	"7sF9CMIADQank00K4OogE14iVu3O27lwFedC3QxD5wHAmUVLaNISwIWwybGh/LQT3shFauQGEVxcYwET",
	"kB5DzN4f3MzbyQ/puvKq6HE0mmikuTQT9QlB9nIHUUbSWd008DbuERN1CH7IR8CPC7ztsuxA7zmEqu6G",
	"b2KvAfpvYu+4B1FGd6mOSUhaSb+/vPRjL321c9GlLq/iZHtJZ4eU4shcDyEA7N0APpceD4c4yf4/+ogX",
	"78/oBbV5l3f4R7XO9i+vmOcu4W/c8NI7ptllGG+DCK8XS5cA316j9TqAZj7aOm7kO3s3crfwD9KWE0Rp",
	"5kYeSF/B6PIp8EGeZeAwQDuvGFXUDoBDc/45om2lmQtNVeQ7YbxNX31GJ2WI4ucjCtXlNnQj4Kxvr8/O",
	"z/KTQGffvvoGLTkOIHIPAfpg9epb5HchFL7/7ewS+UGQ1SfsE8iOSZQ6bg6oJI4zB0T+IQ6iLH11xlQo",
	"ufbPvj97D7L17fVb+gNUOwnjHHX1erWis0hy0xHThHPpLv8rxWeXsJlrM4K5FPSyUFbyO3IWqXyLKK+5",
	"XL5Lsrp/iy4ORApx3O/d5CUfCMEowPlwtyl0V2+C1IufQPKCCx1ceuExzWh0F4KM417foM8d8ksnBRmE",
	"FZ7wffyEWfwo9gHKH0PmJIi2IXDIrTvl8cetXZFu4STnp/xgpFTu+jpyPDdFHMw+fkK0Xql1x4+dZ+B8",
	"AeDgxInjwbiwdhgvgC39egToEkuiddXfFBNKaQzYJvegGH+Site4pMiGsVEFW99xzohVhxVPg4+GF40q",
	"HGO/OqyaYCOYWwYwdKZ++eO8WQVpG+ieXY7WFVNuTOGICJv8NQbTu8rL8wbvEKec0buN04w3/OXhg7+a",
	"tMqUZcRcIsod959gtAfDENf3E+h9nncgcv4rxoGGS8dGIFTx/IY8X5KsmyTQx3YWIy9HRWVouvK0mu+t",
	"bF0QS/ND7L8Y1qFqXYGvF3ESbAO4hoSi/YSHAaH/jxMreM2gejs32gK0VfMdlqVZ239wfUJ/6TISIiXn",
	"mokjx0q89QMJKwF/JbQSFlazg5UIFXVYMZHepVfsOqEFN9ct4exXlCDkMA84CXhMQLqrQY/+ntnS+pT/",
	"lDdv5e5Is6i02hM6uo9G9VvxL6M4cw5xmgYPobZgqP2l+SO7A26I158NARJZOvkOOX+XOuQxTqj0I/3G",
	"GOJJ34PFR+KXp0NK3hmPKF1MN43n+vb63Nm5if/sJgBFyx/v2KUrb2CvcaFFY8OK5B5sUCVGgI7uNfMp",
	"HmJ6DNSnC8JL9zltG3M3DPNYEfjO+l93TgK2QRwJFtr/uvuEvzY56O5zSnsRD/3jMXSKUqV658GNSM2g",
	"+LFhhJjZIGdk2bW4aH2w9n3HdSLwzDT16nN0lQAfRFnghqkDJx+aQ+pMnYAsAd64mXuglIsTpE5yjFA4",
	"GyCZ3169zmkgzNZj8tW5Xn9wkjgEDr78Bfj1yb1KgJuBfH7PzAQN+cxqiBa+MSVVVVHw9objoRHqGh58",
	"t/p7+yPrMAGu//L2K+L3NWGaB7hm6AqtyeVvgf+HBLPkRkxfFcLx4QXvHwUcEOLHWRA2royZPq7f0IXc",
	"wUVeiKzjAv+sDjPxclKK4MkRQYgdPL3ftU/ST3H2Lj5GvmaupzTabUapyRnE0LD86875pDpvrGdQmLTA",
	"NzRpq2FMg8gTnQQMheuSBwN3afoJHELXk1BiPhbI40p4+KRficftu1YD+y6c+NXdd50EzxwYdvFbXhyl",
	"x7B9w6kc512hpxxc9YcfDOOfGI2EPdLF6MLg8vB0joRTEpmUmhMFp/hHhiJTgpIxhaWsSLUyhHC4ph+R",
	"lua9u3JLxqUQbaUelUPTHIKNLq3cB756dbDotNz5WEJUlZlu2ZaEUWrXWcytttoUTiBQFRuLMUaptTns",
	"E6n2UWvShBIoNCv0iH3ZajhfRmYuwfMxzUi1oztLFZKh1rfXdeq9OTmKdJ7OPUOKDIdUkhQdukuS8aYw",
	"AzT/LQEhDL5aBv9H3P7cx144KApzcFnOR5GfkbwzJ4vzHNjHOHFc/8mNPODX88ipvDgVVbi8Kx5aygQK",
	"hqz/fF6SUnQSxk686qRtcOfrB9qBaqYEU4x9E/hnEik7j8cw3NDbF4yGdfmoyQZ252c7UnTo+9/K5eov",
	"/lmU6m+qao+Stmn2SFP08oc5tuGhmEsKNzK9cnwCrXtIDpN7tRcUcQy0F/MYyvNzJOCGjvkmIIzdrvDU",
	"H2TSyuJjYkxKMpXBQWuZM5zJ69XrIXouaxdOMnJwtSaSFIxnlt7YjE5aM0r8CX17cf2Gk9Tzhh5hyZ8l",
	"jbUq7gQJo4dcN+s2QcEBXf4GF2uSdBE1JI9JvOeYErq0hC2KOCOhSeEDlBxa5CwuyTfyy8vzMZmtupd8",
	"3eaJxqIrXJ6NztdoGLYm9ZCg1JhSwdIAL6KumaB78MBurHHdSbewW6DcxgV2QTJ53NrqeYaYqyFDTJbD",
	"tDHmpAhcbSHmwUWlpFGkeel6YSqVf7C+unHCIEIlu9wM5YEy7EcQOekBeMFjAHwHd8BPxQrDtRd2Xcky",
	"kp/Vj1dBCVmrVz025YUbWnVDo6kzmuHlhUtjV0pQY7C+vrqRcrDPuzgExZbE1U2Ks42hkUCfboMnEEG8",
	"5nMqTBPTitWRrXYM5KDlYB1L+plAe9Yla2bKI4p6n4071J1Ih2YkzWo638+3Xf4WRD74KkmpUFiIdulh",
	"UwXf0u7xSNJ4gxWpuzDUf9M+PvmqNX5XOeg7cms1I24mn+LRkDNUIo63bWVmpBQmiCTVBQaIs9cVwwGj",
	"ZW34KV0NKG/dssuhRmuF5kiGbyqPb3KQzbqDMQav4zr2x1fkwtya2SoUdGu3CXWedGwwRC2LW73eli5z",
	"rTmaqTlaDWaODC6iLaVsjlIWmqLua+7HIKQXwbRSyu/wb/sSyriZE/F0JqN5OpbLY4AJMhhc4k86UMAU",
	"ZD1Y4JMCbHrOqwTbkTiwBlVa53gzzAg3yGBJYa5/yqelRAvnpqC3l1Ijh4k0WqnhFtNSqR+JBbDR91y5",
	"YTLBo2GGiaZxvXArNSyhLirE8AI0xXwsaclhPjncBPRWdpiATQs3bP3BaAPaUfHDYnWmZtcMQSzu13LE",
	"GjniRnvUsvzV6XdJs9YqzdkqrYazSmaX1pYqNkcViy1S91X4LssOG3R1/IZKs0mOIZBjj3+8v7911uji",
	"+fziyE/HsH+CMmwYtUubha3OkF4WD//yCGchmNii4TxcdGCkxcDtwVGPCbTT86UtqjAS96qksOswdIRA",
	"M0t0K8lpqW9+PvSPDZNXosNFZsmAX1bjy0VvoJdBVzN8lRsYRRLaxctcKXbhlI+GdBdJKBWJtLLynZRS",
	"hae3+niaqN1S+3xqv5c6tXL/QsRq2Q2wujSnxcSoNhBUzAiCUsVbmNleUJHKbjho3HDoZyVb6A+zMQfp",
	"yNpKaytHEHIJoTQ02WI3Q8xthvSwlj1ZGW8HvC8K+yP49zp2RK5gS3PdBSHDuqx9DwYgFeCiue66s0Eg",
	"13Mv45Rwm6gbZUE8Js8pVq51xUwNsC0hFsZuRDRsROQTVNt6oLZCi2PrsMGAHtS/pdBsfzgxH5bDLhhm",
	"vXGAJ3lcWwVIJqEDl9sQaFci1S0AZf25mqL+DBOYWmq/gdpvhr8cgY/hr42yt75j7FHy+Kh4oaKz9tkg",
	"6S7s39Lsumn2FoslQ6Zf6fPXDH2+DJ+9cLu1Gt5umV/QW7LbMNndZLN6rvwB7F017x+J3JzuL19yEjOO",
	"qMk5p/qzA73QDH8GNhUw57PflfZmEdmT+z41EifqIWv4HpOfbFG+Nc+wDUCHt4hlOfEGTrw8VTVinLUo",
	"+lxkB4a8kJO3YujFkrdbKk5QyMhjlw6zpsuZmR4XZ14I1hgGyJHncvqlSqAvTLUGjH4tnd5Ap0tqhhyv",
	"zsBRG7luXc60YvHxUe3NlqBm0g2S7s2SWOZdN/Mua9xkKHjNXp+h4a2FW5yFW53Swg1EMFiO3jBHL2Xd",
	"ejIRZCxV6XoyUvrq85AG50zXl4d6oYR9CTgVWDMY6Eral3HZk7Y/PSYn6ko5SB+TN21VxDUPrUOw962S",
	"Wf6+gb+vzFaNwC/bF52OswOJXxJWe7a7jOninglnhLLLjllz+aW5Hhebz4rWEiPIMfrSyqZK6i9QzwaN",
	"ky2130DtK6iJHL1fgqU2gt/6oinG7eOj+dvsAsfSG6T626SxZL9usl/F3MkQ/vqDAobzt0ZvoUZvdWqj",
	"NxhBYfl/w/y/tMHrTWV0q9Wvv0r/Egr029L8dezU0N2/Hr/eSvy2CL9OuI/LwcoU3udUzBxkO8AW2++1",
	"H1CeL86GgM5Sbr1L6xsuqt+1jqatoLmoXYHx1tBvKs3YsXC+uZL5i9S2YYNnuznQuDmgoCyy2wNGCuJb",
	"vzTRaH6MWwTjqnxva96fYJdAxe7J7ROYLHFvrd9yrd/q9NZvOP7CbhcY3y6QtnzdmY4w3m4yN9mCTG6j",
	"4CbeOvf49303CG7iLW5phjsD7LAub0eAAQmD23y+O2wBsLDrQf2fGnLT85M1II/EQbYo2LqEQsPcfoss",
	"ltPn+rjS9JSofNZQaPFsatw9I5hWzr7d+JQlYuSwy4G5kvTMJI+GnC9kEnrvVjZeUolUWPjl6M8wkaml",
	"2/l0uwT8W/l1BntaeHXrO6YQIo+KQG9WdNY+myHMm/u3RLlGolzGYrUst3X7a9K0tVsLsVur4e2W+eW8",
	"pbjNUdytNqv7yh8+BZJN+hxk3i6Itgp58MRMOXf0WdlceCIKd+Fyh+TJm6QZ0rMhuwXjvTzeG090FTwM",
	"vjlI6ECG87vpzIuPAZ7T855NoB+JJ5XXy7UIvIaZc3kJLYnOT4wXzVqJUOebHd0OVo1l5wuuSLgLvS7u",
	"h/feLQuQijx2ETJX4p2Pv9Fw8FzxJCKJVmJeXe9qa37FWHfeKjd4YG1pez5t31VjWrl8vsZI0vpCXcG8",
	"vvVQ0wz0R8X0y5sJvu03w/9LS2W3AjRuBXS2gi0MhMmwQcxDWFu4DFu4GostHJTosNsL5rYXutnB3pRI",
	"BvaH0M1kdhsq3DFuwMkb0LHlcJ9LM7/dhmKkl7XPUMVJDdN00uUWN5XmhF6bfuHVBqR5aZNLYzcU1HA9",
	"xhVGWTauP82BZHZV0SSJXU9oXE9U7EOTtdHnPC9/OyTgMZDdSqjaMP6qBDepsCxh9xDEZqxZC3Cn/CVJ",
	"/l3rmiQHkt1AGN0GQj7Vo9k6UFBZif0CQ8pVi1HnrlkDhsR2h4C/Q6CkGG2EmCG9KHFh1ussJ1hfnTJY",
	"N0x7LSRaPynhNWCg3pXc6slprcMQv8oM60XQgV0il1WnsJSoK92MlS0NoYTZEfJUDR7PKCtlyahByCie",
	"uejt0i5/Q38qEU78kB+205FlkjwkR7CMLA03xiffWF5pwrzSyOgkvo+WZY+0aEpOGc1XTcyHmJYbauKG",
	"BJGoHBWkBeQl/sf6gxlGu6vhol2ztI5lc0yzOZoj3Szwviichb6Dv9dy/hk2NL9Tz8xwLvCocwEOFqV0",
	"prucambg1vko88mQNkGHVsXvWLxas16tS+AzfT65WRZ7KJmfe8tOT/kgMmMftDgyxTPHhWCaDxrn79UW",
	"qhcS2MMKs2Vwikkez3niXCahu24/OiynPmqMzvw1Z5gg1BI7gmPB7cBvPwFcYE/TsV/rL8YcEI9rT7NZ",
	"xRmbbGhvs7F/u7+p8/CuhK1qO6er20dXV9bWYs3UYq2Gt1jml+2WozZ4xLbNWnVf4WfeYePtgPdFjqm+",
	"v7p18M/73kl1f3V7BRuaYYohM6bLoqsLdDA4pRPdgaiG7V1htPW4iurESJues6vidyTOrlmt1sQ6oak2",
	"TFY3S2K5an4BTXZ2Slw1YyF0ODI1pjq3WXqvoGo1OmV5CilsKD9XsrqY49Fw1blIIn/dylTLqY/K5VMd",
	"NOdqipozSARquWo+V90K/FamugC+lmunrL8YfTQ8Kq66UcMZo2yGqW7s3RLVGonqdkPVsqIu/KPO26aW",
	"4qSXba5WQ5sr4wt2y1KbY6lbTFW/pT0ZP4WkaigOGRzZ1GrcK5py8k84Mw0MNmkfNj9THrs87svLvq6h",
	"qAxuBgAd+e0yRPvR3KeH4zT9JQfkI/KbrSq45uB0AAa8VS5LhIuJ8MpcVfnwsl3R6DrVyfGSpLo5chmL",
	"VQ8WSyLZFcWcCfPSVI+KN2claw4KpEh0aTVT5NKXp2FDhsSWXxfz6/IKIkW2lyCpi3O3/md6EfroePg2",
	"g1A37+ZY+TZZLDmvmZxXsHISTL3+KKAg7K2tW6StW53W1g3FQFhm3yyzL2vn+nIVWDBlnh8/pqOGCqVS",
	"cYuzpvZLY71Ubp9FThXYBQY6s/slYPal90+Oyal61DrSR+VT2xRxzUPrIBR/m2SW42/wmOXJqnP8JfOi",
	"03F2YflZYfXWbJE1XbxIkpXKrj7mzfSzcz0yqp8RrSVGkCT7ZbVNqcTLQhVt0EDZMv5NjL+8nkhy/iws",
	"9VSEsd5oqpH7CIn/FsPAsfUmqf8WaSz3r537V7B3Uux/e1hw3a2qjLV6C7Z6q1NbvcE4CrsLYHoXQNbi",
	"SdAZnuvtgPoVdwypj1vgroWucOOq/OiQawvy/ssi3j06LxQ6aKLklgToWScFaHqcLFa8dQ731BcR03Mp",
	"aNhGFTwzElXwimbYUJAs7tUGxnoCY49oWFW3pZ2B0uVw2BzkfLT4ViARMS0wCDxIDnrlj2WSOzPJeLZG",
	"wx6LFEKCJy47OxVw0+hnAsg2Hl5ZupYTjjXAso2mwKhUQSN52NrasYd3q6HCO1NswBLiu5MyAH3CuyTb",
	"wFFpX+7n6VHxowOfgMt8kGTBIwQFSHn5B7DxNIsTwHWFSXaDOm6xPbf4xH/eVskM/XoEyUthh9gOJ+se",
	"8xlZFgHBwRQLaYwWOT4C2QwQZckLJSM4mMxDON4t+SKmgkihClna1QigO0E/ShRiXExJSaiKbhUQZqFo",
	"ij1pksQSKPp2FhnLBM0KedW6gVLxupe/Ma1K0isMpFCEn5Yk49+2XDNFIuZFzsCxCIe+Q7wyYERTNWzW",
	"ps6RB+LbxvEQQ1z5BIFIK1fUS1UbguYp6OdCwnRLZPHzDpUUqY3dMuPyKANmfZ5dR5yMklNfRxij6Zax",
	"kDgtUydvFSWXEUjX1ZN1WMaDZyxTaFB/XN/CXgWByB3uedSZPMUALYBMI9PKmo18jhh8oc8aiDRMdeW5",
	"Pa1uNKfG7ojbWVweT+5yx8ZQMVKJXQuaNpPslFgKS0/po6dqU8rXeiW3opb2UwtT+SlAYupJYEDKHfJX",
	"mDb3Z7ycTzFjo6F5JJWlheKpI56sTgn+hFHTRDA+SGhmCRReJpA0QLnUyYfYDx6DslX+U8pLDxJg9a0f",
	"ZNYgTyhuHEgxi7kuY+l48G30OClOApmIF3lLIxE3ErF6nRyibXCzZ8nrpHeEoxhgrfl4DMMNXfkadYj0",
	"zWlvS8v/ydFTwI/Ot1zWD22gy0Gkte9XwDVmHqMTbPX7r3zGxkR7lIWqrlUJQgyRHU19W65DE9dRVXOh",
	"vaCB8SEBHpptAkwjBgSToNaGWBtibchcbIhCyKtElNbsTI+jkq0WR4DeuS7V+0f00+Za31SxNRrKVdZv",
	"tybV1dRH8QzmTFVm+JWqZW55zK1yfCrIeYPtZJ1xThqy7mHuUe9q2KiXYtFUEtpCwt+TJqHVLIuG8LdU",
	"+HqXZeReb7mrIn68vydXVEtfBi26IgI2hW62flPQibO5HYId12WRwwxCGLDmk93hFggWcz2ufzg53qa3",
	"7VlD8Uj8X4t2rSuGyuwtDy3C2Osd+Fc4lyeodLMDayy0uDa1yxwKyfRe1ixhgMoiMYLYorFzTbljJnk0",
	"BFAhk9CFt3I/klqkchdzNwW6mqICDRObWlqIfyJSAv+tOQ4M/rVctWy9xyQC5VHtjjZrOmuhzeyQNvdv",
	"90g1nimRMVktq27GW+q8N3lBXnvhhms1vOEyv6i39LY5ervVaPVc/QPYu8JFyEgeJHLzNcjSKxZCO6Im",
	"YYuzpbrZkV7eNchV3FTQnE9/V/KbhWRPBvzkUJyoj6wBfEyeskX71jzTNgAp3iKWZcYbmPHyVNXocdak",
	"6HOSHXjyQk7+mcUeXLmEqeLEhYxAdvUwa9KcmelxMeeFYI2BgByFLqdgqjT60nRrwADYkuoNpLqkasix",
	"6wwctVHs1ulMLBwfH+HebApqRt0g9d4sieXfdfPvstZNhojX7PcZMt6auOWZuNUpTdxAJINl6g0z9VLm",
	"rTsbEcbbTeYmW5DJsfU38da5x7/vm4t+E29xS3Mk6NlxXR43z6CEQW0+4R0oeRZ3Pdj4k2Nuen6xhuSR",
	"+MQWDVuXYGiYeW+RxZLuXP9Wmp4S285aCi2+TY1kZwTTmowuYX3KIjGC2Ph/rrw6M8mjodQLmYT+u5VJ",
	"l9QiFRZ9QQo0THBqeXM+by6B/1a6nMGeFqbceo9JRMmj4sabNZ210GYY8eb+LRmukQyXMVktS27dHps0",
	"bQ3XUgzXanjDZX5JbylucxR3q9Hqvvr/9Rh4myAKssANFdLR//Pn6yvnGj/mJE0J6bI8N2yRNDjXdHTO",
	"WC+P9K4jh8F0BQQdGHAOMHsQ4SMB5fT8pQjqI/Gbcpq4DkPn/v7WWT9mIHE+EWEGSVKXE9Ay5vw0dY4R",
	"qFDndUOj04Wq8eglaUVZNd3pdGkbVpavLpVdZMyVW6/P9Wgo9ppoLdFCK9+upm0qtPtSFW3QkNlS8Xwq",
	"XlVPWnn5Oiy10PPWG002hB8VZS9lGFBqYCluN8XgS4ljiXyNRL6ywWuhEQzFBaQHa/aWbPYGjofqqBmM",
	"prC7AOZ2AdQsXnc+I/OU6q7fX+kqu35/Nd+q68ygLovzL+DBwJXOdAeCH7Z31bvi+qmhNj2/WAXwSBxi",
	"s16tiX3CJfvMUvbNkliqnk/Vs7NTYugZE6HDlalR8rnR0kvFt1udskCFGDbsnyv3XszxaDj3XCSRx24l",
	"2eX0R4Vc76I6try6yEVZFp3Porciv5U2L5CvhS63HmP8AfGoePFGFWfMshkavLF3S39rpL/bLVXLqrpw",
	"kDp57sW46WXbq9XQ9sr4ot0S1+aI6xZbJbG8f/S2wcY9HCQY6Uq6McNEv7t6f+0wUEm5Cw34qzXsSZUR",
	"HPNl23D80Esti3umM85Sz2R+5aL5KmScLEZK69VeVRTA0+7Mo2nq11kTjI4qmi7JVEEJgwpD0XRD7zaW",
	"1hNLR7mKc02Eimu6/A1xzlIEc1S3LDmZzC2pyL+fH7cnNDFiwM71Zv65kcPsnI2FHm5RGQl2uIZ9BcgX",
	"EdqM8D54IGj5X07g2IbrNkalD6xJM9aUzzcqXQ0dlZriTJYRlp6UMdEYlJbyIVwvlEvqW1/dkHSZnjl9",
	"ay/sugSuMrQVpF/dlGzfr0eQvBTGz/XCDflap8Ez6ZvR5CyvIEAONQbs66ubDqmB66ubXkmBGrE6+92E",
	"AqwjcYoi7VmXrJkpnyjq3ab98dP+8IyUEv6wzvd0bmppfhQXerP8msxI3Yeh/u3m52wZHDrFo8nuoxJx",
	"3G0rcyOlMEq3EM9eVwxHjJbJ4WfyNaC8ddcvh5qWFD7rDkYZvY5qn1GgyIW5NbPBKOjWbi5qTNRrMkQt",
	"q1u93pauc605mqk5Wg1mjgyuoi2rbI5VFpoimUV3gibY75WBlzfC39fNu5hV6l3+Vsuidh+Z2cz3MMhn",
	"cmE4baFD0h3tx2bdycJzXGl3JaHKAKFzayzprqFvGxhrCowfCwXl2AYVd6SSdVdYlKZkuz+1ZNsJbYsA",
	"pzbXbhpMbT5ho2Fqm7VEgq7N8a4CcyYSmwvGh4/2LC3LS7BrA3QbIdIJzzS1ztrtuQaeq2EDT2N5dcuI",
	"PE9KgegMPEeQWdd1nWtT62xq3eCpdbrAanPrbG6dza0zlFvX4N7GklsnGcjb7UubXGeT62auLDa7zmbX",
	"WYdg0+tsep1NrxtNep21Rza/zubX2fw6HQvvB9f7AiJ/kz4HmbcLoq3CJe0/4GedO/osubq4lXimwnBX",
	"FaTVvNFP5A7v2VzVIhry5fHHAgAx+OaBoQO9LEJqV8Z5FBidnp9sRP5IfKeCdq6FEDbMWCvIaElsPokt",
	"nLcSry0wP/r9rRr3LRBekQkXe2HcE/flW9YcFYnsymOu1LgAgqMhyvnyyUQWrTx6B+2rrfKVI+B5K97w",
	"4bZl3vnMe3e9aSXmBXojSdOLNQYT9dZbTTX+HxWVL28tRG7ADNcvL5el/zXS/z3MYQtBYTaKaOAprFFc",
	"iFFcjccoDkuE2D0Ic3sQXQ1iH8ok6FIWAD3VcytiHYY/BJF/qsxio6uiYHklA/A7M1ANZEsFwCfF7pd+",
	"I19A4JSomqCHDEZWP6AQqOL9AnN1A0R92nBfY7iPBrlmIPr6LqUaAsjUiM+fqiwCCI3faGs4AB70YKpl",
	"7Adj7IMx1R7ga5oE+65RP96DbNbKYTp+nDSHbsSTMES6COBtvJBGfFMSyDqAGUazq2GiWWPMTWALEZjk",
	"abRHsp57yI4JUCdifOCFiIHBDTgJ8OKkNzXzBrd6RaWaETWTj/Sy2JkKTliipjzZHfI/qxjsmvd5YtRN",
	"z9mVsTwSh9ekYOswdN5U0GI2mbNJGpu9yXVufm2CSlmbNXOhwe2pJWhWBdS0q4s7qLxeS0RPwUx+bvdz",
	"Z0vwVGd6NFxPRRuaHXsrAWRIt2ox5cwVa4AI1vJDDfyQklK0blBWlULjXqV1N1OIsEe1P9qg/9XY2tBu",
	"aYMEdsNU44apmhVrWbMb8uzctbu1Y7O1Y6sh7dhVzmoaZQcsVW6OKlewYT2IhMcgzMjAtxZWeId/27eC",
	"L25mjtmLdDCXVzKBQIOtL40+6UCKU5T1KLt7WoRNz8mVcDuWmvRiXVrngDPMgTfIYClwrtPKp6XEfOe2",
	"oL+jUiO8iThaa/G2GZfK9QlYAhunz/b+JDzBo2G1ia5xHXEriS2hLyqVeJegKubjSVsTgE9VNyG9lZkm",
	"YNNSjNd6hPEGteO64FOoz9TwGrrcU9ivZZ01ss6NBqllDazT89Kr36xZmrNZWg1nlsyury2JbI5EFpuk",
	"HkvxXZYdNu5jBpINFUehPO+P9/e3zho+7XwiT8sW6G3mlWHDqF3aLGx1jjSzePyXRzwL0cRgnguMDsy0",
	"GLk9uOpRoXZ67rRFF0biYZU0dh2GjhBpZglvJTktBc6v4ftjw+SVaHGRXTLhmtV4c9Er6GXSFU1fWVih",
	"iHYFM1eqXTjloyHfRRJKBSOt7HwnrVTh661CnihytxQ/n+LvpU+tewBCxGrZFbDKNKsFxag2ElTsCIJS",
	"xV+Y2WZQkcpuPGjceOhnJls4ELNRB+nIGktrLMcQdAmhNDTjYjdFzG2K9DCXfakZAAVT3SxBb9O8RyJ/",
	"OTpmnFGTs94fYUd6odsiDG4q0M6nv+suCAvJnpsfJ4fiRN1uDeBjcrct2rfmmbYBtjZaxLI7Gg07GuWp",
	"qm1ksCZFo5fssG9RCMpbovTarZCwVZx4khHIrkhmvTnBzPS49iQKwRojAbktCDkFU914WJpuDRgB2+2F",
	"hu0FSdWQ201g4KhtE8E6nYnF4+PbKmg2BTWjbnB7oFkSuyuge1dA1rrJbAJo9vsM9W9N3PJM3OqUJm4g",
	"lsGy+IZZfCnz1peOIIOpStuTodJ3uIE0OGvavjzWCyXuS8ipAJsBQVfyvgzMnvT9CEA5UW/KgfqYHGqr",
	"Jq55cB2CxW+VzPL4DTx+ZbZqRH7ZwGj1nR3I/JK02k8fSBkvbjodI5Vde8ya0y/N9bhYfVa0ljBBjtmX",
	"1jZVcn+JijZorGwp/gaKX0FP5Gj+Eiy1Ef3WG00ydh8f3d9mGDi23iDl3yaNJf11k/4q9k6G+NcfFjDc",
	"v7V6S7V6q1NbvcFYCrsPYHgfQNri9eczuhU80l/qaBFVjmx9ozp4avjuX9RIbzkjW8lIK97H5WNlqhdx",
	"jhwPsi1gKxb12hcozxdnY0DrUbje9YkMVybqfBLZnkFe1O7AeAsRNR1u7Vh9yFzdoWWq27ABtN0kaNwk",
	"UNAW2W0CI1WFrGeaakQ/xq2CcZUPsoWDTrBboGL45PYLTNYJsuZvweZvdXrzNxyJYbcNjG8bSJu+HnRH",
	"GG83mZtsQSa3YXATb517/Pu+GwU38Ra3NMcdAnZcl7czwKCEQW4+4R22Aljc9dgCODnmpucqa0geiY9s",
	"0bB1CYaGOf4WWSy3z3VzpekpUfqspdDj3NQ4fEYyrdy9hPkpi8QIYtcEcyXrmUkeDUlfyCR04K2svKQW",
	"qbDxC1KgYaJTS7vzaXcJ/Lfy7Az2tPDr1ntMIkweFZHerOmshTZDnDf3bwlzjYS5jMlqWXPr9tikaWu4",
	"lmK4VsMbLvNrekt1m6O6W41Wj+X/r8fA2wRRkAVuqJAT/58/X1851/gxJ9GREg9bJA3ONSOeM9bLo73r",
	"yGFAXQFBBw6cA8weVPhIQDk9hymC+kgcp5wmnvAiXzkBLWfOz4fnGIEKeV43NFp9qBqTXhJXfzK8tBEr",
	"y1eXyi4z5squ1+d6NCR7TbSWcKGVcVfTNhXifamKNmjMbMl4PhmvqietzHwdlloIeuuNJhvDj4q0lzIM",
	"wyW/S4ljqXyNVL6ywWvhEQzFBaQHa/aWbPYGjofqqBmMp7D7AOb2AdQsXg9CI/O6FM2/v+pYMx9BgPwT",
	"zpRoi+D+au4l9OsDv7wNghqMGJSXEdBhe6CO0R67A+PA4/Q8rADlI/GwUjq45gDV8JaAlFx2R4C/I8CZ",
	"q9J+QM2w6PSearsBNVG1bgbI2qyydDWZ7CpkrlsBtakezU5AVbLmuKB1H0BJz1S2AZapYkOGxXYPgL8H",
	"oKYhrTsANUhq2QCwHmiaUfqo2H8Zi1A38GaofxlZLPOvkflXNHMtBIGZOIB0YI3dYo3d6rTGbigawhL+",
	"5gh/FUMnQVhsw/jBDVu5fPwzaNkQZVpqg7vgeY/bVeU91a3G4zEMNylAj5hdcZChWgD73jjdDODIJLd5",
	"VH5zIvc4GHI6+5tOoNTvn1g8jsQriVUEz6oxDyTu2LLfHDeypTpW02RplzGKCmiabIUtaLbcgmbjdze2",
	"PpmtT7bM+mR1TzOycmQi4zGaqgx209NWFxuwutjk9MEWC7PFwgTFwqxtt7W/bO0vW/vr1LW/rB2ypbxs",
	"KS9byqt5pZzExwPLw9Y35PAvWszILT5xc0xBgjg1ZDeIKfn1CJKXwpbQ38iYk3yGxhWhk1FbFi2bz+2W",
	"IiLfBIAflKJuXoCMfzU5HE3PK6H5GVVgzEhU2d2DX5gKh4W92khYYyRcNgscqyDthS5/Q2deyhQtj0aV",
	"siSozZL9KIe05Bsl07F0WzUjlhZbntEQtCLlOW+Oy9qU4P0ClcB44DdpVtaIN2Co2VZ3kBMj/CQua9pt",
	"GDq49mIzaSzHbAFx6EmJkB6RJ7pnFcDWU5p3KZGVVklWYpLRYHsXqD2HNsfd+fzx/v4WvVR6R3sdczIa",
	"d5iWRX9wZrZySSyeT7ndx3prThYjfW1JkS9u/i/BZ4F5aBxMju9KfZ58ZVBwkGDyTv12gSw7opEdqc+u",
	"yGh0dFZc0kSU18bBGkqFdUkOLGyqyGprsUS4WQlL1Ip3vZG85UxMcSacqRsNgSKvaBKpblr1hBftTU1J",
	"Bo4tbd4b73CdCsTbkk+kEE5ST1rwTVq1jmAmEfBqBBHw8eDbCHjyvIzW4DeMt5vHOHl2E78XQxPGW4e2",
	"I0pKf0f7mdMx9NIALou7Yee8nCtFZlqOtGFGkMvWoHdtyA+nndkj6gpYHV2Gd0muemolmWSTOd4NEljy",
	"RhN5w5gMkcVQdFpKTA3TvWChmaeJw1YbDhwKjY4YupaPmc5JQzpnoyFiJBRHgoFh8a8C+1L8NiPMnyRM",
	"tDQMj4aRAngb/9IV38UhH2vX5x20rk4RtJo8ELSMqPWkhIuJoLV0HcFDEHVgX9BT7bWb6B0IoupNPwSR",
	"32MVPeKa5HhYl8XJ4HcuUApnV46GgU/Wj8VS9HB3LRqZmdPianrbDnD8R8XKFAKVMQMn1hQPI+rTEjAa",
	"s2fQINdMhAYXpsTFIHsjDtLFpkjEyrQZHA6KBw3d7QU5QzE4aG5HQ93w1U2CrdGoIe9BNnP1MB1I2uNJ",
	"DceTRBBv42s0Ipy0ap3APMPa1TBhrSmmZgFx7UkpGhMhrb9N3P2mGzeDnpVlaBh+ieu538DGfiAL+9mw",
	"M+zwLoujYcDBYDafZTm6pmik7iXZbRBl3qaQw1I20hAeFXFTFWs4+qa5Z0viaCRxCv0X2BBtzk+J1WHM",
	"kkpc3+gCcesNdskG9ZbZOQWz06qDEiSPCYVhY0ZL9GjzX5buIXSPBO7bmB8TsCfNW0cx0wh5NWSEbIoJ",
	"WkyIfFI+yHB0PIbL1uaZs2PvZxv3/Ww2o8de6WavdJvNlW5yPm5k17yppemf6BoOywnZm+HGezPcElTI",
	"XiZnL5MTXCZnPYi9f87eP2c3VSd4/5w1XfbKOntlnWW7dV9ZB2fqkMQwxlRPd2QzzPAuHW0rr+oNLd6P",
	"61vYs2Blckt7H3PJ9tIwLYCgJpMLEcbMD4Mx8mlDQI9jb7baVwUb4midNr68MuzMMI0uGC7JVXcpZNJM",
	"hsMNEth4WHM8XOggV+sVXYtqua6qrRCU7RJTxkITUu6U7coW6poG8cvO2aiY3xaVEXC/74LIF4AerR1T",
	"CsyG4GkyMB8oRrPsLK/WlhRGuUTHh9gPHoOqcf5TyuM6BHh96weZtcuTCyEHU092xsuoMlS+fDkB5Qls",
	"DjIYL3I2RyKU3LtBCJINiLIkqPAUhwR4CB4E3fLMRbnRSl5emaXFP02pY+Zusn5Av3lLRJS7mb3SbtPN",
	"mOSnm2LxPFU/XZnMZaX7VV6+UIkCPi8VUqUZ4cy+KW7bgW2/0JLqQgyrnxBlJZw4vKfn1RncvIyKGaoL",
	"VgkdC9SYoobaRLDckEZuqDTYIvOl7NIF/FCz6SsYo5LlUzlY1OrYcR8Kpo/F+wCXai/WxM6I0GIhMxpC",
	"S0rPz1Xj8Dgqxd2albUUhY9VU5cW47/YM7UN+ZKSapazcm1qlickmXOJpBPrE+2y43Rsosqyw1SW04LW",
	"HSfNc9K75CiUXQ+NyPCG1PA05zxhuenFrvO6FrEyxMtk93LPU+f3UiVur5xCBfaH7MX5UO6ikasTXx5s",
	"r5tpBu4IKbbGS3YpKowybEu55vf0JFtdyetmRN3haSHZ0j43KLaZJT6obWLWlHisdDwclowa9aCwUtXL",
	"FGcJ/5MFlzbJi5fkJYd5ST6JyfvqAvm3fpBZk7+IaHd1kmh3iDyxZcW+p8wV0xT1QgsBf0IGV+lEG0Pm",
	"MM1wnflPTDdy6TAJSOPwCSRNhDT9zYT3ftjxXxb9E5UgQcFbAEWu/EXRCk3ioqBo2JTBtA/T1eQgOb3N",
	"kWKiRkUXVcUqT3wBEVNkUXP/lifSxROxus61NWq+UumIHmOjcjqoZqWkKCF5k8Ugd4BN5AVZxhlRUAxG",
	"RsNCtSuqRFU4RuEUSSerYCOJhi1fxeOrZLSjrfhSR+UgLVgFsbH5UOSWdGxuKmdpMcH5STOWtMTmByA4",
	"8ihDZLEPS9w9AEDSmFZ9C1SPNrJNNlkwJOj0E55Lk7Us1qv06gXcKWRe5FgvhBecrVwvkshiSfncYiHI",
	"ZJE7Pf+bg2JcpxWrYlUAAAyfVGzu3lJjGlOomKHm2yRFD6xEjzHGTOXoRbMbxs3LWzMw4JELKHm6EGM5",
	"I7qswMho2LJWvZUgy4o2NKofEwVb3TtpiG1PFDadKJRQoDY+zYj7Iu1bHbLB/kBkm2ywb4prW0y0f1Ku",
	"TVugzzsWqJgzxrYjjCBmefCPffNFEmD1pEU41wrcF8n1UuO17Mk+JWSOj4tqyCqG82uUiLKn+cxTUQdQ",
	"2gMiNkHRJalzTz3O6PHNCgea9ljedEiecfE7PCcpReqo5j4x4dYcIH2acM7mLfHylnoZ9uqlyw9B5Kvv",
	"8aOn2jf3HxOECJ+rIesw/CGI/E6x5IgvasUDuqxlCH7nApJwXuXWH/DJOp1HcaO+434qRE2POYMjP6pF",
	"SSFQGS1wSk0tRkR92kWIxv1wNMg149DHXymtSpCJUdlMEHst3KjYxnCAO2hcN3IjNqOVDZrb0axs+Bom",
	"sbLRqBvvQTZbxTAdL9pd5YZdZRG427aSNWKbtGoN/9yi19Uw0aupbd4FhK8n3eDVGrkWN5NL8C1hyNyx",
	"LXOMQnCZP+ZZ8pu550a2sGO6LMqlghDBNeztXvJ5F4fACYM0g62ymHsOsh1SdPTlNngC6AREPtMiL3lq",
	"vE3z3sQSikd0b2KDdq1LEHTCIAKpMVfXIstsPJ5eB1aanjQTWIn+Du3ytyDywVdJRoaRih+fo8aKneR2",
	"N5dfvt1kduoXxxMhrmF3/Fg9IF+1ButBlIEtOtpqaZrx0DTMJI/qvm6ieiKn3crbSGpQPU9aHCYuRHmG",
	"iUbtxjWfy5HAfuuWIYM9YisKfMN3lkc93jK0XmP0YfGo9imbtZy1zGb2LJv7tzuXGncuZcxVy/pat6cm",
	"TVujtQSjtRreaJlfv1vC2hxh3WqwOi71uxa1Js+189cPrvelIVHwDrUzN/Z6maWq62Wq7xRKVJMiZTV/",
	"SQCknjF4OmhNz7mNsOR0Q4FLo6WmbZnpQSLwWim7O8UydgJPppRB2FrgU2iOREx1k9Hhothmk8ySn74b",
	"WcFosbpJkNI61eQ9yGatI+bDSktB8ynoJoi3kTk6EU6atZ5gnhHuargI1xRlY4s1m6ZrtEe3mfsQdijZ",
	"jB/TUKz5Hvc/I46GjOiyKJqMTiPFJZpXOYIGPau7kDLu3/IzMmAdFT3DSFRGDJpRU+SMsFfLzWjkZjKi",
	"lFUj0ct3KREz2NbornMsMDY8/NpgfJa0DJ7c0bAyIkWT4GR0awiN8eanHsaDSHvIs4GVEUO8jZPRjXDS",
	"tHUCM4tpV0PFtKbomCUEtSdlY/rEs0m8Tdx9mXk5JMBDqxsCV/WavqRVasIOSQy9xcXejdxtjYfmr5/f",
	"g+yWCte3YqvRsm9UyIUV8C3mJq/nhmf5A57kCunSjCm2sC9umNb27QIdUusXNzTmcr+myveSNx9V5V5W",
	"pkoZSTLjpur2inu2rIqukr25rgmNgYIzElApzSaEqeZL8JQfw2y3ITjwbinyK7InfDTbUr8TKfVL5ms8",
	"1X7bdelcNVZDxYDJizJQV1GRpghtEjoxQBBoU1e4ZX9lAJ2zJW2ALm5cUjPzjRaeXrRkTfwkwtLVkGGp",
	"sauOFhGXnvaeIy1haeI+tyam/Li+hU/yQssgcg6hG0ROBr5mPCdKni1N+pCr1nbHCCW/RC9RhncNJVUg",
	"f6Tv6qS5G6w4v/CYZiBpcHv4B5WRlfF85xXPerUD3pf0uJdyrXv/vzkefUClF8Mcjo5ZeQ8ikLihg5Vn",
	"0FiEFyFwdYfR2bJiiHN5bo/pjpBIRJHV1fE2TiX1sWJWH50UZOdOFNOBwOhxnoMwdB6A48MQHFpuFKkc",
	"0x2gNT7zn4AIuWFfcJ1i+iU4bHijnKPj0Q1TcE5H/SGOQ+BGvBscGWmJI6EyBFGQBW7uZY5RFuyh60F3",
	"lOFQ639efMIfX6zJx/Rh5Aub5ee4mu7ix1H44jy5YeC7cOVfmuxzVAYuPmZIqpcg2jpBJpAMtrOh7fSU",
	"7YYUpCNj5Kxvrx0v3u/dyCeV6QocOSmAf8DRfnhx/vT//onKhxWyELA25Gf9YkkzkaGCPdJKSna2gz+B",
	"Z4HjxgpqPZWyp6oHyJ1np28QbOer9S2MrhN0YOCHYnpPuG82p5gLBUnCEKkh6pJZKIE0DjuVW2D2jvNG",
	"uITjp7yLOd0EWwzcsjaRE2Y2Ke7oDMsl7dMW8gx95Sth8/7stbCyMB3VxnJZqKq5IegwtLXc1LfdW9a0",
	"t5wUCsqxESpuSSlFP7csPe6FFdsWAU7tpvE0No3zCRvNrnGzlkgk3Nc8qeK9sXPD+vDRn9095u0etwG7",
	"Lc0+x7UKnsnz1n7PNgBdDRuAmtpEXkgEetJd5P4BaBBt+3EisAG+10VNz4oLQW+0MB6EzGIOL9ijHP8R",
	"RNsOnAds3/IdMlAcF9chIJfhfBrjOAxtz1h+g/IbWBkrui/rVtQ4DYiTPnwG125wsGh5jInwGHCyxsNh",
	"cDVBhrtA9k+Rr5gJloeNzCxHweUoBMBt5SZUcUt5iaXb4XkFiKthAkRjHMT8I8TT8g89A8QRXojRaQFq",
	"L8SwF2K0X4hxCmjZCzHshRiW4jB4IUaDJxvFhRgyAbktg24vxFjyhRgz1RF7IYa9EIO5EMN6Anshhr0Q",
	"w16IoRLdZgm0Su0RLBrM510cAgc/0loQHDc89gp4cyrAXZqXsYSD8P3KiGGrhWKQtASGnDYcYpv4mUmD",
	"YW+4DTCipzYcq4VjDeDgI43PDmIej9Oa8HqVaRg4A8WlGSiO5cYUoXZUjKKpu1OE/Vser7eeCzVToN4N",
	"y68WY8Evaj96PR/JjrQ2u7Aazi4Yqzu/BINwwlVPRpWyZgCk1zyXIMqSQGbtg27MgM848JGXIotRYSX0",
	"Fj651GBhg8ZNg2WYwQKNYGg89yQVQqmEy+zlhcxrBRE5EFBRDee+7nhp6S4SkznBoxMB4AO/MeK2ivQy",
	"vtCblUuMedf3DXlacf82/tZ5eWGzrZBwvccUJCESrseRtLwRLvnzc97FnPifYuCWled1ZGaTAo7OsJx7",
	"oi2oH1XL+7FrP1l4jso1lYUqA4TOrSlGqKlv65M0+qRjoaQc+6DikpSyuXKron6STWxWBBC1J9qmsb7L",
	"J2w0i7tm5ZDIxuoEcyYImwvGhw/07M23DelXWow+uwbhAjhtvYwFJTYVSsKCuFLnm5F4qhcN4TFb5vLD",
	"Oabl0yYQH6X1h2gBMT0MTY8bgwMzupWHaNVhcsVhVxsDrTbQP+rmQNbzXP4G/8NZbojWCzJxlEPb5MdR",
	"zLdK1mPp5mpmC5RxLU54HrUpJLN6cLLQzy5IJBYkQlCTrCRuhpEFto1HzeZBNcajpnKgFhCQnvTcR+cQ",
	"9Kmwwo0EIPdyIi7dV5rSf+aGu9+uWV+HRmY5iDKwlUFiYUVOXNJJdCmU0vU4GPYS++xOSK6No9eRkScF",
	"ldZxq0ZrGuMuxOGG5gGvvv+n4v2LmrtYpuaxvvwt8P9oHXAYLpSH2kkzNzs2DXh7EXDUTuDzIwP0udhF",
	"H9wsAwl87H9//uz/9t0fF/A/r9n//PX/OTuvmc1fjKNAOuYcwZFg7pwqYAjfsqigryDyD3EQZamTxc4D",
	"ikF95zFOHNd/ciMPFHdopiDLgmibsiiPH/4LeIIUGnLj41vagUl1z9/idApfGy/AvDidvjdB6sVPMP5t",
	"nsBL1wslrG4YOuurG7TSSZ1jikopw7CFzljsfQGZsKIB7PhH3C+ZqzXs1eA0uV64QcKqqKQhUr40eMwU",
	"wc/IcMhMkpy5dqO8L7Tt6euaretWq573i9Mnr990su5DWm2KkqnYbWZy++CoVBuIOVYgA6yKjdaFLryM",
	"h+vLt0SeXnXJhgBNuqFDp4SeqSzbWMCBfE74mGtOa4yqyfa5oZAHz22cDowe/TQLBc4Is+J5otWNO55G",
	"Zj9wcrti+A2yWMqSCs5mMrm68PcH9wUGynXIrn3/Fn9HkXp1M2pcVgzayKDZaG6ZiSiObXRAp97dV0Yq",
	"3e46DwbbUj+hca0cA4QCoIy41Hlyw6OKGS4K+UkaYl7UqFh+qfxe7wYIMHk16ybuz+kuZuHPXxrsXmMg",
	"SCGEJ4EA6fqNsUhwkhBaDeia5xdrvnQzl6TsnOY63n+q8VKigt1EzDta4GqkCxjyOhvVStwGL/XKB5iM",
	"OB3pfvWyyXKjVpeQF6rpnjsDNyiQaXN9fzPCmtQi8bjV+/rEaMo26qRLjjokXQaGciXw5Oxbl+rOeUzY",
	"riPkWqtmNRlZ8U650I5TjnhKQV11OhvxJV/RuLYZ072o8dRBY8r1Tmm7UICKXiWFUQZFAKKsN8joZU/T",
	"A5q5OGGEVX0l4C9EBpv2NbXkJyHelUOAIHqMWxYy+T7xIYmhKXHgM8meJrvWrDNZgt/iX1/DDgxCgAi1",
	"QS8y2BZ685DQKbhmPm2Zh717aF9QUmO5dw9487dl4fjBPbwje8SNluv60UFq7LhhGjvpLn52jtHejdwt",
	"8IvOnDB2fXzlFJFekBcbRF549MEmb6OUfJjPwqMbpiDPqnmI4xC4kWHyAw3zRLxkbbYZZH2A7yEBKYkY",
	"/hPYx08AERSwJ8IHF5E87Z5TJSQEblJArQ1lH0hDmj2kAMo+iWVRj+hl/CD9IkAsyorG0S8vUbbApri/",
	"YL8HfuBmIHxx0pfIS0lmL8pOaut6A5/oqyWcpci6MqmnPvsii7U60mVuoq3oC9c4fozAaRFr2LpNaQlQ",
	"nTDerLftmMJn5XdMR2elTmI19C8R9u5hlHu9Nbnqcz2+XV4G0p08ftdsrNJeBTXNQeS4zjZ4ApGEfb3b",
	"xc9NmjYW1qQFFmO1l3DgixTdagZVYTJVUqfEk7n2/Q/uoVu50eb90rlav5dR2r4XkeWbfPZVE561WU7J",
	"xBhkNKkA3LiWJDYEwussC8spULr6FHY88NL/CrMpLYLgQH0BL5c4N2kcx/9TBbx0WgyxvoKmVlMuPGjc",
	"VRk//oYIDV6mGhiQyZZeS+W7KBB3WEW8OMES+CgBK3aA6+2cwMfB4N49tO2XWBM2SExySOAkZCS8R3PH",
	"t374q/oBRnaA/00a+CX/GT4hN6r9ntaYBgN4yls7CmqoGOOkWeB92WTuQ9hhPYgedvDD/ARM+IN73LjJ",
	"ezzZlzhNohl6Uyd/1Xy/LR8AlYlgCPr2RIpiDnCoQBpsmY/WfWum2YkQncwITsVPM6jRABpTHI+Cmms5",
	"GVXzw+v8dPJjEMLfQ+nwLqoD3curz8fV6lsPgg39Czj4AyxonJQ+RHaUfJICKEMGfBgGe/F+74ocOer3",
	"TInP/Qd4cZ53gbdznoHz7EZZfkwChfVxIujrC3hR6+iD+9WJjvsHkOAT8LgDfP49QdNMzsAfXOidyX40",
	"r2svPkYZr/OiXkit94+PjynIyJsGkQ+VF6TOLn529m4EVxdgn8IhSL8EBzhxrVLEqMVmMQYyJF0YQTP2",
	"wXlbI/dKdqLlCs84cY4H30U15tD7XWDbTpkSfD8R/IjD4GrXcG3xLdT+DQaH2py+wJmCmsZTsFIEjNWx",
	"6IgfC4u9Jz1qwI+OuXJ1PymkA3t3IENgQ0cYu3qoNMhAr/tsUAN8b4OaPnUhpUawIQmXVRQ6JbOSQwT9",
	"LXeQIsiA+kU0sIMFXnkGB2tUWwqFQBWsw1k1VNZZ1Kct66xpyznFylVVZrGpVzsXAqGR89rql8XwVZ8D",
	"v8cEoc23t8VMpBgzmrXRFGMWaIHM8RZk/NSuh5kYqk0HUJMurWysDKYQkq2nYVQRSZ61tnYaAd1qmIDO",
	"VF3kBUR0J62LrBTQHWItJTfvbj++5ZXZ5Hu/Q7yY2ppoYDrV04RTg/6P1J2UKanpPrlBiKgo1G/jGSE4",
	"C/R0kDkDU8g/lZKIgmFkNQoqTRsNmxbPOs9BtkPJPIRiFvIcsOEm17M/hllwcJMM+qv9BfIPDZQpKvNy",
	"PCA7V7+NH52EjQEWMYsd8sPzM7zdcvb92UMQubh2SskwQncFf/PGzdyLYtck7wp+vw/2gDyVga/Z5SF0",
	"A3SAps6o9mUsala7BrN8IuhV+9UJmVz2YzvG6niVsTIKa/u8a+HSnRiY1pAyfweju8+8JWje80jWoblA",
	"PGvTuhJtmBF88mlkM7LquRvE39Bp37HRtbKEw8lhsSexvCzhpautKFeN8eJDz30gOJ64maag5Q7+onfa",
	"wZgoEDikZPjGjFdT20nFtMsHWeyeUv58U1x1EtQoUBSmKIccW+PaSaqIxQEq+nbSxYGr8NRoZpX2YPDi",
	"HA2nYCemLYzTozzCSZ4KjSgXVBbvNZrdjQIB3QNL/EpBJBFqmofMPLdCmo2iDVujChq1GlT0X/KZu4WS",
	"9Y5lcTNUZwQhShHYruHPT2Fli1efuvaQiVtqFM0BXPeQGjVW1LyVCbLnj+CRRPRobsYX0TNicSYRA2om",
	"EX2uHUN4IvVwH4snCPeDqiNtiv0nqNNC7M1voYHfa1wLDZcgRn2hwWiWMmLJusPCdVKxml3piPO/ciBw",
	"Y7iWJDDGCyirEs0Hs+pkA0fzOWiygeOUT/U3e0ZNseI2iY+HXqwFEhI3I+lyCXXxHj5jqYs+KkBmb4HU",
	"BYO6TmwFi1pCVzShtqAr5o/akXgdNDnjoysYsTiTSBA1fb6iUb+0+h51noIMck5UyPMSE1ReEchmyEvg",
	"9xoXLyF2MXI7oNQgdGQmLGAnFYpZZkLITLQFbDLURFdlYrgJq1A2ShyAm5CKEmdAThiOEPcgTd2thgxh",
	"2pB0XsUH/IClJ/poQT59S82t4MKue3YFaU4tv2IJSB6JMyLzMz7SoiQYZyIpsGaSZ8HoidlMC6rfauVt",
	"WBFzEkOOwJikMjcAbn4kBn2z8VSpYaTqnmCRW4jq2kuCxLCgnWDQZqmM5iSLBo1qrbXTqFAKZIZVLBtD",
	"DkZpyMaQ02Y1mnW7Q9jIwCxVqJqDLEDZNrAtvXLumb8cz42cB0DKn+Ny5dkOBImTZm52bDwZzbSj2Y68",
	"Q9IgWYo+iESC0t75lwUuQXTcwxl4dIMQ4HtfNock3iYgTZliy8NcIQAnuTShg9cIasNFBbMsShqIhrvM",
	"TTJKNbCzhStoYXCSe6Dq9b/hw2ahVC7zReywE0ekrHwWO89x8sURlowv4opWD9JUQ/4bY0jiAem+rDUJ",
	"XU28/ruSGOCruz+EAD/jg7Pvv3v99/MzauK+P/PcKIoz3EMdAedOAlxvB3xyx9jXYH/cO+4+PkYIj69X",
	"DvzhEyjBsKiGBCUuV+HAQtTHm5GpU4mO+zjGNwrEB1BWCm2Vz/lD1KxyPV2G5FWCUHeZx5ooBHNaygJW",
	"0xVdUututt/RLLulASKbSdBs9LkL74lP9WpQczvWi/paJr/V4fMWo1fxfh9kZTsPvgLvSC4lzQcA7Vzw",
	"AwJnn27r2w6o4clhr39d7dXpQoMctyG+pCjITJTUl5DKFmPtVZ6vppNdA4tyNPFUkHCNjoZjZ8ijQv9S",
	"mvB/5jG26Ts3tF7sWgv7+aUguQNzNo6sKr5skuRF5mYqvAStUYueK4rUCu59c7N0KUV7KwOiVLUXPnoZ",
	"uXAZJZyK9+RCZtxPvm3YWDMZzW1L3caPaEHlQDWA6+gtyGgXceL8GQYg8WNevP3ceXC9L+gf8C1A8hfB",
	"ghtpFZfGIS2dnZ+RpuDPUFs8NudcIC7spiauQBbCHSuQ0qQTbGf4fZ3DwMhzU3z5Kl6VOgFi9/HL8GXB",
	"TTZJc3729cIHBxD5IPIQt4yaeEV/hls3Gy5jKG6wbWjWqP82YLfXUQaSyA2dOzQIDtFOPWr9HmQpnt7S",
	"RWbwb6HaxgmhK9RLoe/czDmmgDEfqDF8DyO04GkG5//cAa+2r5y9e0jPnTQNHQ8kWfCIL1F89Uqg9qip",
	"5RhePHIdTS96+HILIpC4ocJcwmXS3o3cLfAd8jSaUFr4m8u3497e458bL6ROxJpYLXXpES6UFOthe3V1",
	"N2+PgqbaLi6JTUZfXHO9No+DVWB/XxWY9qO9BDuLu9jLQHaRZglw92YKssvimAfj+phUS7bTCZ1szXZV",
	"5HLVQ8YCKmWyibQTh6d+kH4REtE8DWqMU2uTTATfDF0AvibIOChnufkQmM1Gn0dqQSFcQbsM1wRSPXHL",
	"yU9k4pu8cMkalqxYmwmeiA/uPONcl9yYDVXtqgHEccQHFk2IGiWy2tms9EtwyIllrZeOLTPumPYNl7Vx",
	"nnI6lbJiK8YscFncccm2dw8yS7UP7sH4Mg29xaRXZ+xg6liV0fbkL8Eqzdag12HlsjKh98Quw2oBJw+b",
	"H/K3ntvtWApo7GawOq2wchlkV1Yf3ENb+JPP4alWUrkA41tB1cdb98qJ20PDiml0E2pXSCozq3NllHcg",
	"tyIqvOLJ0HPKVRDjPduugOx13GLa64589ue33uCoi6LbTtNww268qd6re3dT2rejgrxqXnvc3d1csZ2a",
	"zDmrvuA0L94VjHOnVUmlsZaVR3mulHOgpsEBweVOZVimfAewgkJw9aEyEkztBK2Jl50lmUCa5WkXe1Uw",
	"93cMKlchVyZNdmHXZmmaoTGxmK4twKq+HllIjiu0Egh58nujRQDsstJFBxXkEV1a2Y4G0b8MF2FN6gCK",
	"IlCal7XV1oSxcHkRuyizd+ql7OqU0Qu7AD1xIEVFsWdXJBfgSiswbmTVsVwCTQY1WjHhvnzsrtECza/4",
	"wWnrHkhMMAOywcoeNJ5ynHkNgw7lC7rUirrqUSbKlkoYbakEmdOM5gohKOitrWrQWtVAvaKBnDlv8sCj",
	"mLbVUMZUW+W9q+ne4d6OmcYI4AR1EE4L1zEVNehfz2BgsOtceRoum2B2MM4nvLT9bvU3qQfWaLBpDGa8",
	"mAMv9DkADy+a20s1OG/czHVuQzcCzvr22vl4ABH8b7kNbsmG8g901E0QB5ma14OVl66+S1HrgP2cM7gb",
	"GPO6h+Dp247D/PRt+0h/pH3MacifvpUb9fzl4fDDBoF3TILsBXm9BzcNvI17zHZn3//7F+hz8Il27BOP",
	"SXj2/dkuyw7fX16uXqH/XT59i2jU4ru08uUvuSC/UVe5vrrhVA764EbuNoi2tIpBOZRInT+7/pMbecB3",
	"9rEP/lJ43h9IqQLYZPmju+cg83ZBtP10DEFTl7TwgfMQqHQclHu9ggvM0gfhMc3QmrCGYvdZEDLhxJg9",
	"iDJxxyVvUeowyW4os118dJfFSUmuN8AL3QRcuYfsmDQODEFq9VonoWQEsGmpt23i7vOxqlyicXvtuMcs",
	"9slZ8NJBcfp8fk6cafTd1fvr9eFQ+gixelLTLPk272g9jIY2t2H84IayLb5Hv2al/vH+/vZqB7wv1Q+R",
	"0ufArX6RVj8lrpj3wCdiT6rfXUc4KaQCopt4+y5Ont3Er3x6m8T4lG/p03s3gYaa+fCDG4QgeRtl5SnD",
	"H6fljw6lv39y94AW0Sg+vQX1v2ut3yYxNK9oXrgoQIMMZ4wEbCSUfeXcx477FAcIFWnmooup4S/gb58B",
	"/XkQOUGUgeTJDUmFCDdhCoQ/hMB53oHoc4QS0fFDFz4I3RcnRiK8cv61A5Hj0iAyi6vlxVNn7/oABZVs",
	"8O8ck9BBfKODg7TPUb5MgA89umEKoKRBmh6B49JwD5WrwE2cs0siHBGilq/fwPei/sbBcesr53/FR8dz",
	"o89RBiU+pvT3KVskI3Y8OKL4shvEjuNw082K1l8514/ldwlSBy2NoLxQqZPAR6u5zxF6OEjZmDrY74Ef",
	"uBkIX159jgotwkFvCTmfQBqHFdx8wjVbWh0NRpy02b+rARR/Uvc2pa/vwf4Qor2t8jeBB8oWTiBtGmQg",
	"df6cBvtDWK1MjyR85dyhnxBcpoGPNk9cTOrktg/hE2eehYCOQfo58uIoAh5cJGSxE2TOU+BS87+hIxUn",
	"EA0X9E8/SAAiTdPS9CAxSq9ZikxEXxShSekXMaj+fV/mRDkbB6SqgBtEqNgPfRbXrmEaywLvS2224If3",
	"ZL3BfIp3xpiP7q/qhvv+SmSI0Td8O1zr7D5xPZA2gaG8ecZbpOa7aOgWOIAMGFRVln9Fio4J82wHPkcs",
	"h4JgkiVuToXffry7x3bEc8OQZsBz+n2Jj04E6LGj3FSVmt8EPrGH8NfP0Ogie4gXZmUxz9Fv8k5L/Pzt",
	"z/dIJHStHO7/c4Te1C0t8KDdyekKZJXyNl3uayDh42NNmE3gn5cHag/gE0G6h31A5Qy8IAtfUON0EFCl",
	"LroOqbBVJdWpQZt8/nMKkjCAK+1f/vi/AQAA///+f38QI3IJAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
